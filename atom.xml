<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ㄅㄆㄇㄈ</title>
  <icon>https://sulfurandcu.github.io/sulfurandcu.io/icon.png</icon>
  <subtitle>bopomofo</subtitle>
  <link href="https://sulfurandcu.github.io/sulfurandcu.io/atom.xml" rel="self"/>
  
  <link href="https://sulfurandcu.github.io/sulfurandcu.io/"/>
  <updated>2024-08-30T01:51:48.000Z</updated>
  <id>https://sulfurandcu.github.io/sulfurandcu.io/</id>
  
  <author>
    <name>刘汲桐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>嵌软架构设计思路</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cm04joaah0001y0rq43qza0rc.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cm04joaah0001y0rq43qza0rc.html</id>
    <published>2024-08-30T01:51:48.000Z</published>
    <updated>2024-08-30T01:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<center>系统架构｜分层设计｜模块设计</center><span id="more"></span><h2 id="嵌入式软件架构"><a href="#嵌入式软件架构" class="headerlink" title="嵌入式软件架构"></a>嵌入式软件架构</h2><p>嵌入式软件架构包括分层设计和模块设计两大部分。</p><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p><img src="/sulfurandcu.io/%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E5%B1%82/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84.png"></p><ol><li>避免跨层调用。</li><li>同一层级的模块之间应当避免相互调用。模块间数据应由上一层程序获取后再向下传递。</li></ol><p>?&gt; 同层模块间能不能相互调用？即使是通过上层模块传递，那结构体怎么处理？接口可以不调，但是头文件要包含的。</p><p>?&gt; 「xxx_interface.h」中某些宏定义来自「xxx_driver.h」并且需要向外提供，是否要在「xxx_interface.h」中包含「xxx_driver.h」？还是转换成函数对外提供接口？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用程序层（APL）</span><br><span class="line">业务逻辑层（BLL）</span><br><span class="line">功能模块层（FML）</span><br><span class="line">硬件接口层（HIL）</span><br><span class="line">硬件驱动层（HDL）</span><br><span class="line">硬件抽象层（HAL）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- code #########################################################################</span><br><span class="line">  - Application : 应用业务层（大程序）</span><br><span class="line">  - Basic       : 全局配置项</span><br><span class="line">  - HAL         : 硬件抽象层</span><br><span class="line">  - HDL         : 硬件驱动层</span><br><span class="line">  - IAP         : 应用业务层（小程序）</span><br><span class="line">  - Module      : 功能模块层</span><br><span class="line">  - Protocol    : 独立规约层</span><br><span class="line">- doc ##########################################################################</span><br><span class="line">  - 软件设计/</span><br><span class="line">  - 硬件设计/</span><br><span class="line">- project ######################################################################</span><br><span class="line">  - MDK-ARM-STM32F4XX/</span><br><span class="line">  - MDK-ARM-STM32F4XX-IAP/</span><br><span class="line">  - MDK-ARM-HCM32F460/</span><br><span class="line">  - MDK-ARM-HCM32F460-IAP/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- code #########################################################################</span><br><span class="line">  - Application ================================================================</span><br><span class="line">    - configuration/                    应用程序配置</span><br><span class="line">    - inc/                              应用程序接口</span><br><span class="line">    - src/                              应用程序代码</span><br><span class="line">    - unittest/                         单元测试程序</span><br><span class="line">    - startup_xxx.s                     芯片启动文件</span><br><span class="line">    - system_xxx.h                      系统配置接口</span><br><span class="line">    - system_xxx.c                      系统配置代码</span><br><span class="line">  - Basic ======================================================================</span><br><span class="line">    - base.h                            基础定义文件</span><br><span class="line">    - conf.h                            全局配置文件</span><br><span class="line">    - util.h                            实用程序文件</span><br><span class="line">  - HAL ========================================================================</span><br><span class="line">    - CMSIS/                            通用软件接口</span><br><span class="line">    - Device/                           设备相关定义</span><br><span class="line">    - HCM32L19x_DDL_Driver/             华大驱动程序</span><br><span class="line">    - STM32L4xx_HAL_Driver/             意法驱动程序</span><br><span class="line">  - HDL ========================================================================</span><br><span class="line">    - CPU/                              内核相关接口及驱动</span><br><span class="line">    - URT/                              通用收发接口及驱动（UART｜USRT）</span><br><span class="line">    - SPI/                              串行外设接口及驱动</span><br><span class="line">    - I2C/                              集成电路接口及驱动</span><br><span class="line">    - RTC/                              实时时钟接口及驱动</span><br><span class="line">    - TIM/                              定时计数接口及驱动</span><br><span class="line">    - WDG/                              看门狗狗接口及驱动</span><br><span class="line">    - ADC/                              模数转换接口及驱动</span><br><span class="line">    - DAC/                              数模转换接口及驱动</span><br><span class="line">    - RNG/                              随机成数接口及驱动</span><br><span class="line">    - KEY/                              按键</span><br><span class="line">    - LED/                              指示灯</span><br><span class="line">    - IOT/                              物联通信接口及驱动</span><br><span class="line">    - BLE/                              蓝牙通信接口及驱动</span><br><span class="line">    - ACS/                              交流采样接口及驱动</span><br><span class="line">    - ESAM/                             安全芯片接口及驱动</span><br><span class="line">    - FLASH/                            内外闪存接口及驱动</span><br><span class="line">    - driver.h                          驱动接口文件</span><br><span class="line">    - driver.c                          驱动接口文件</span><br><span class="line">    - driver_comm.h                     驱动公共文件</span><br><span class="line">    - driver_conf.h                     驱动配置文件</span><br><span class="line">  - IAP ========================================================================</span><br><span class="line">    - configuration/                    引导程序配置</span><br><span class="line">    - inc/                              引导程序接口</span><br><span class="line">    - src/                              引导程序代码</span><br><span class="line">    - unittest/                         单元测试程序</span><br><span class="line">    - startup_xxx.s                     芯片启动文件</span><br><span class="line">    - system_xxx.h                      系统配置接口</span><br><span class="line">    - system_xxx.c                      系统配置代码</span><br><span class="line">  - Module =====================================================================</span><br><span class="line">    - algorithm/                        算法模块（CRC｜MD5｜SHA1）</span><br><span class="line">    - comm/                             通信模块</span><br><span class="line">    - middleware/                       中间组件（cjson｜quicklz）</span><br><span class="line">    - delay.h                           延时模块</span><br><span class="line">    - delay.c                           延时模块</span><br><span class="line">    - debug.h                           调试模块</span><br><span class="line">    - debug.c                           调试模块</span><br><span class="line">  - Protocol ===================================================================</span><br><span class="line">    - PTL_DLT645/                       DL/T645-2007</span><br><span class="line">    - PTL_DLT698/                       DL/T698</span><br><span class="line">    - PTL_GDW376/                       Q/GDW1376.1</span><br><span class="line">    - bsptruct.h</span><br><span class="line">    - cc.h</span><br><span class="line">    - protocol.h                        规约接口文件</span><br><span class="line">    - protocol.c                        规约接口代码</span><br><span class="line">    - protocol_comm.h                   规约公共文件</span><br><span class="line">    - protocol_conf.h                   规约配置文件</span><br><span class="line">- doc ##########################################################################</span><br><span class="line">  - 项目需求/</span><br><span class="line">  - 标准规范/</span><br><span class="line">  - 测试记录/</span><br><span class="line">  - 问题汇总/</span><br><span class="line">  - 软件设计/</span><br><span class="line">  - 硬件设计/</span><br><span class="line">- project ######################################################################</span><br><span class="line">  - MDK-ARM-STM32F4XX/</span><br><span class="line">  - MDK-ARM-STM32F4XX-IAP/</span><br><span class="line">  - MDK-ARM-HCM32F460/</span><br><span class="line">  - MDK-ARM-HCM32F460-IAP/</span><br></pre></td></tr></table></figure><h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><h1 id="第一部分：系统架构"><a href="#第一部分：系统架构" class="headerlink" title="第一部分：系统架构"></a>第一部分：系统架构</h1><p>我想以一个简单的例子作为今天话题的切入点，假如说我要做一个小玩意儿，上面有两个灯，一红一绿，外加一个按键；红灯每隔一秒闪烁一次，绿灯则是按键每按一次它闪烁一次。怎么实现呢？</p><p>最简单的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_TurnONN(LED_RED); /* 红灯点亮 */</span><br><span class="line">        delay(200_MS);</span><br><span class="line">        Led_TurnOFF(LED_RED); /* 红灯熄灭 */</span><br><span class="line">        delay(800_MS);</span><br><span class="line"></span><br><span class="line">        if (KeyIsPressed())</span><br><span class="line">        &#123;</span><br><span class="line">            Led_TurnONN(LED_GRN); /* 绿灯点亮 */</span><br><span class="line">            delay(100_MS);</span><br><span class="line">            Led_TurnOFF(LED_GRN); /* 绿灯熄灭 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能实现吗？能！有问题么？有！</p><ol><li>在红灯闪烁的这一秒内，按下按键绿灯会亮吗？（不会）</li><li>红灯真的是每隔一秒闪烁一次吗？（不是）</li></ol><p>怎么改进呢？</p><p>首先，按键响应实时性太差，咋办？不是还有中断嘛！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_TurnONN(LED_RED); /* 红灯点亮 */</span><br><span class="line">        delay(200_MS);</span><br><span class="line">        Led_TurnOFF(LED_RED); /* 红灯熄灭 */</span><br><span class="line">        delay(800_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void interrupt_handler(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (KeyIsPressed())</span><br><span class="line">    &#123;</span><br><span class="line">        Led_TurnONN(LED_GRN); /* 绿灯点亮 */</span><br><span class="line">        delay(100_MS);</span><br><span class="line">        Led_TurnOFF(LED_GRN); /* 绿灯熄灭 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个问题搞定！完美！</p><p>第二个问题咋弄？好像有点棘手。其实问题出在延时上，中断（前台）中的延时操作会干扰循环（后台）的运行，同时还会造成 CPU 资源的极大浪费，因此要摈弃这种形式，改用「状态机」实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /* 红灯目前为点亮状态 */</span><br><span class="line">        if (Led_IsONN(LED_RED))</span><br><span class="line">        &#123;</span><br><span class="line">            /* 计时 200 毫秒后熄灭 */</span><br><span class="line">            if (LedRedTimer.Switch &amp;&amp; LedRedTimer.Counter &gt; 200_MS)</span><br><span class="line">            &#123;</span><br><span class="line">                Led_TurnOFF(LED_RED);</span><br><span class="line">                TimerReset(&amp;LedRedTimer);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TimerStart(&amp;LedRedTimer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 红灯目前为熄灭状态 */</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            /* 计时 200 毫秒后点亮 */</span><br><span class="line">            if (LedRedTimer.Switch &amp;&amp; LedRedTimer.Counter &gt; 800_MS)</span><br><span class="line">            &#123;</span><br><span class="line">                Led_TurnONN(LED_RED);</span><br><span class="line">                TimerReset(&amp;LedRedTimer);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TimerStart(&amp;LedRedTimer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 绿灯目前为点亮状态 */</span><br><span class="line">        if (Led_IsONN(LED_GRN))</span><br><span class="line">        &#123;</span><br><span class="line">            /* 计时 200 毫秒后熄灭 */</span><br><span class="line">            if (LedGrnTimer.Switch &amp;&amp; LedGrnTimer.Counter &gt; 200_MS)</span><br><span class="line">            &#123;</span><br><span class="line">                Led_TurnOFF(LED_GRN);</span><br><span class="line">                TimerReset(&amp;LedGrnTimer);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TimerStart(&amp;LedGrnTimer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void systick_handler(void)</span><br><span class="line">&#123;</span><br><span class="line">    TimerCount(&amp;LedRedTimer);</span><br><span class="line">    TimerCount(&amp;LedGrnTimer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void interrupt_handler(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* 按键按下后点亮绿灯 */</span><br><span class="line">    if (KeyIsPressed())</span><br><span class="line">    &#123;</span><br><span class="line">        Led_TurnONN(LED_GRN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这个小玩意儿算是完成了，我们总结一下上述几种实现方式的特点：</p><ul><li><p>第０种实现方式｜顺序执行</p></li><li><p>第１种实现方式｜顺序执行＋中断（顺序地执行的前后台系统）</p></li><li><p>第２种实现方式｜不断轮询＋中断（时间片轮询的前后台系统）</p></li><li><p>第３种实现方式｜操作系统</p></li></ul><p>其中最后一种使用操作系统的方式这里我们暂不深究，只看前三种：第０种实时性太差 PASS！第１种实时性稍微好点，但还不够好 PASS！这样就只剩下第２种了，而这也是我们最常用的一种嵌入式软件架构：时间片轮询的前后台系统。</p><h1 id="第二部分：分层设计"><a href="#第二部分：分层设计" class="headerlink" title="第二部分：分层设计"></a>第二部分：分层设计</h1><p><strong>为什么要进行分层设计？</strong></p><p>程序分层和模块化的目的无外乎以下几点：</p><ul><li>便于阅读</li><li>便于维护</li><li>便于移植</li><li>便于裁剪</li><li>便于复用</li><li>提高内聚</li><li>降低耦合</li></ul><p>这是在网络上找到的较为通用的分层方案：</p><ul><li>应用程序层（APL）</li><li>业务逻辑层（BLL）</li><li>功能模块层（FML）</li><li>操作系统层（OSL）</li><li>硬件驱动层（HDL）</li><li>硬件抽象层（HAL）</li></ul><p>我在此基础上稍微做了一些调整：</p><ul><li>应用程序层（APL）｜业务逻辑层（BLL）</li><li>功能模块层（FML）｜操作系统层（OSL）</li><li>独立规约层（PTL）</li><li>硬件接口层（HIL）</li><li>硬件驱动层（HDL）</li><li>硬件抽象层（HAL）</li></ul><br><p><img src="/sulfurandcu.io/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png"></p><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- code #########################################################################</span><br><span class="line">  - Application : 应用程序层（大程序）</span><br><span class="line">  - Basic       : 全局配置项</span><br><span class="line">  - HAL         : 硬件抽象层</span><br><span class="line">  - HDL         : 硬件驱动层</span><br><span class="line">  - IAP         : 引导程序层（小程序）</span><br><span class="line">  - Module      : 功能模块层</span><br><span class="line">  - Protocol    : 独立规约层</span><br><span class="line">- doc ##########################################################################</span><br><span class="line">  - 软件设计/</span><br><span class="line">  - 硬件设计/</span><br><span class="line">- project ######################################################################</span><br><span class="line">  - MDK-ARM-STM32F4XX/</span><br><span class="line">  - MDK-ARM-STM32F4XX-IAP/</span><br><span class="line">  - MDK-ARM-HCM32F460/</span><br><span class="line">  - MDK-ARM-HCM32F460-IAP/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- code #########################################################################</span><br><span class="line">  - Application ================================================================</span><br><span class="line">    - configuration/                    应用程序配置</span><br><span class="line">    - inc/                              应用程序接口</span><br><span class="line">    - src/                              应用程序代码</span><br><span class="line">    - hal/                              中断处理程序</span><br><span class="line">    - unittest/                         单元测试程序</span><br><span class="line">    - startup_xxx.s                     芯片启动文件</span><br><span class="line">    - system_xxx.h                      系统配置接口</span><br><span class="line">    - system_xxx.c                      系统配置代码</span><br><span class="line">  - Basic ======================================================================</span><br><span class="line">    - base.h                            基础定义文件</span><br><span class="line">    - conf.h                            全局配置文件</span><br><span class="line">    - util.h                            实用程序文件</span><br><span class="line">  - HAL ========================================================================</span><br><span class="line">    - CMSIS/                            通用软件接口</span><br><span class="line">    - Device/                           设备相关定义</span><br><span class="line">    - STM32F4xx_HAL_Driver/             意法驱动程序</span><br><span class="line">    - HCM32F460_DDL_Driver/             华大驱动程序</span><br><span class="line">  - HDL ========================================================================</span><br><span class="line">    - CPU/                              内核相关接口及驱动</span><br><span class="line">    - URT/                              通用收发接口及驱动（UART｜USRT）</span><br><span class="line">    - SPI/                              串行外设接口及驱动</span><br><span class="line">    - I2C/                              集成电路接口及驱动</span><br><span class="line">    - RTC/                              实时时钟接口及驱动</span><br><span class="line">    - TIM/                              定时计数接口及驱动</span><br><span class="line">    - WDT/                              看门狗狗接口及驱动</span><br><span class="line">    - ADC/                              模数转换接口及驱动</span><br><span class="line">    - DAC/                              数模转换接口及驱动</span><br><span class="line">    - RNG/                              随机成数接口及驱动</span><br><span class="line">    - KEY/                              按键</span><br><span class="line">    - LED/                              指示灯</span><br><span class="line">    - IOT/                              物联通信接口及驱动</span><br><span class="line">    - BLE/                              蓝牙通信接口及驱动</span><br><span class="line">    - ACS/                              交流采样接口及驱动</span><br><span class="line">    - ESAM/                             安全芯片接口及驱动</span><br><span class="line">    - FLASH/                            内外闪存接口及驱动</span><br><span class="line">    - driver.h                          驱动接口文件</span><br><span class="line">    - driver.c                          驱动接口文件</span><br><span class="line">    - driver_comm.h                     驱动公共文件</span><br><span class="line">    - driver_conf.h                     驱动配置文件</span><br><span class="line">  - IAP ========================================================================</span><br><span class="line">    - configuration/                    引导程序配置</span><br><span class="line">    - inc/                              引导程序接口</span><br><span class="line">    - src/                              引导程序代码</span><br><span class="line">    - hal/                              中断处理程序</span><br><span class="line">    - unittest/                         单元测试程序</span><br><span class="line">    - startup_xxx.s                     芯片启动文件</span><br><span class="line">    - system_xxx.h                      系统配置接口</span><br><span class="line">    - system_xxx.c                      系统配置代码</span><br><span class="line">  - Module =====================================================================</span><br><span class="line">    - algorithm/                        算法模块（CRC｜MD5｜SHA1）</span><br><span class="line">    - comm/                             通信模块</span><br><span class="line">    - middleware/                       中间组件（cjson｜quicklz）</span><br><span class="line">    - delay.h                           延时模块</span><br><span class="line">    - delay.c                           延时模块</span><br><span class="line">    - debug.h                           调试模块</span><br><span class="line">    - debug.c                           调试模块</span><br><span class="line">  - Protocol ===================================================================</span><br><span class="line">    - PTL_DLT645/                       DL/T645-2007</span><br><span class="line">    - PTL_DLT698/                       DL/T698</span><br><span class="line">    - PTL_GDW376/                       Q/GDW1376.1</span><br><span class="line">    - bsptruct.h</span><br><span class="line">    - cc.h</span><br><span class="line">    - protocol.h                        规约接口文件</span><br><span class="line">    - protocol.c                        规约接口代码</span><br><span class="line">    - protocol_comm.h                   规约公共文件</span><br><span class="line">    - protocol_conf.h                   规约配置文件</span><br><span class="line">- doc ##########################################################################</span><br><span class="line">  - 软件设计/</span><br><span class="line">  - 硬件设计/</span><br><span class="line">- project ######################################################################</span><br><span class="line">  - MDK-ARM-STM32F4XX/</span><br><span class="line">  - MDK-ARM-STM32F4XX-IAP/</span><br><span class="line">  - MDK-ARM-HCM32F460/</span><br><span class="line">  - MDK-ARM-HCM32F460-IAP/</span><br></pre></td></tr></table></figure><h2 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h2><p>硬件抽象层是对硬件实体的抽象，这里主要是指对主控芯片的抽象，该层由通用微控制器软件接口标准（CMSIS）和芯片厂商提供的库函数组成。</p><h2 id="硬件驱动层（HDL）"><a href="#硬件驱动层（HDL）" class="headerlink" title="硬件驱动层（HDL）"></a>硬件驱动层（HDL）</h2><p>硬件抽象层提供了片上资源的支持，但这还不够，因为嵌入式系统还包括大量的片外资源，这些片外外设的驱动或由其厂家提供，或由嵌入式产品设计公司自行研发，目前来看，后者占绝大多数。</p><h2 id="硬件接口层（HIL）"><a href="#硬件接口层（HIL）" class="headerlink" title="硬件接口层（HIL）"></a>硬件接口层（HIL）</h2><p>以往的程序设计理念是应用层或者模块层直接调用硬件驱动层以及硬件抽象层的接口，而硬件驱动层和硬件抽象层是硬件相关的，当更换外设或者主控时不仅要开发驱动程序并更换库函数，还要修改应用层或者模块层的调用，后者是很令人头疼的一件事。</p><blockquote><p>硬件驱动层与外设相关｜硬件抽象层与主控相关</p></blockquote><p>硬件接口层实现了对不同厂商的主控芯片、内部设备和外部设备的统一管理，这样在硬件变更时不会对上层应用造成任何影响。</p><p>以看门狗喂狗接口为例，上层应用只需要调用 HDL_WDT_Feed(WDT_EXTERNAL) 即可，置于外部看门狗用的是哪款芯片上层并不关心。就跟「我就想当县长夫人，谁是县长，我无所谓！」差不太多。</p><h2 id="驱动层架构"><a href="#驱动层架构" class="headerlink" title="驱动层架构"></a>驱动层架构</h2><p><img src="/sulfurandcu.io/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84.svg"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- XXX</span><br><span class="line">  - hdl_xxx_conf.h</span><br><span class="line">  - hdl_xxx_comm.h</span><br><span class="line">  - hdl_xxx.h</span><br><span class="line">  - hdl_xxx.c</span><br><span class="line">  - driver</span><br><span class="line">    - XXX_SOFTWARE_CONF.h</span><br><span class="line">    - XXX_SOFTWARE.h</span><br><span class="line">    - XXX_SOFTWARE.c</span><br><span class="line">    - XXX_STM32_CONF.h</span><br><span class="line">    - XXX_STM32.h</span><br><span class="line">    - XXX_STM32.c</span><br><span class="line">    - XXX_HCM32_CONF.h</span><br><span class="line">    - XXX_HCM32.h</span><br><span class="line">    - XXX_HCM32.c</span><br><span class="line">    - XXX_EXTERNAL_CONF.h</span><br><span class="line">    - XXX_EXTERNAL.h</span><br><span class="line">    - XXX_EXTERNAL.c</span><br><span class="line">- driver.h                          驱动接口文件</span><br><span class="line">- driver.c                          驱动接口文件</span><br><span class="line">- driver_comm.h                     驱动公共文件</span><br><span class="line">- driver_conf.h                     驱动配置文件</span><br></pre></td></tr></table></figure><h2 id="独立规约层"><a href="#独立规约层" class="headerlink" title="独立规约层"></a>独立规约层</h2><p>略.</p><h2 id="功能模块层"><a href="#功能模块层" class="headerlink" title="功能模块层"></a>功能模块层</h2><p>略.</p><h2 id="应用程序层"><a href="#应用程序层" class="headerlink" title="应用程序层"></a>应用程序层</h2><p>略.</p><h1 id="第三部分：模块设计"><a href="#第三部分：模块设计" class="headerlink" title="第三部分：模块设计"></a>第三部分：模块设计</h1><p>模块化设计可以说是无处不在，从硬件实体到软件代码，从驱动层至应用层，都能看到它的影子。</p><p><strong>模块化设计的目的是什么？</strong></p><ul><li>提高代码的复用性｜避免重复造轮子</li><li>提高代码的可读性｜易于开发和维护</li></ul><p><strong>什么样的模块才是好模块？</strong></p><ul><li>独立性高｜依赖项少｜复用性强</li><li>结构清晰｜接口简单｜扩展性好</li></ul><p><strong>怎样才能设计出好的模块？</strong></p><ul><li>多读</li><li>多写</li><li>多思</li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;系统架构｜分层设计｜模块设计&lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>通信模块设计说明</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clz2cld8l000q1orq40fzah1z.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clz2cld8l000q1orq40fzah1z.html</id>
    <published>2024-07-21T07:02:38.000Z</published>
    <updated>2024-07-21T07:02:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/cover.png"></p><br><table><thead><tr><th align="center">特性概述</th><th align="center">详细说明</th></tr></thead><tbody><tr><td align="center">较强的接收容错能力</td><td align="center">自动从下一个起始符继续匹配</td></tr><tr><td align="center">丰富的协议解析能力</td><td align="center">同一个端口支持解析多种协议</td></tr><tr><td align="center">灵活的端口转发能力</td><td align="center">支持在任意端口之间相互转发（转发时支持协议转换）</td></tr><tr><td align="center">良好的协议扩展能力</td><td align="center">采用星形拓扑｜方便后期扩展</td></tr></tbody></table><span id="more"></span><h2 id="较强的接收容错能力"><a href="#较强的接收容错能力" class="headerlink" title="较强的接收容错能力"></a>较强的接收容错能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/receive.png"></p><p>接收并解析一个正常的数据帧是比较容易实现的，但是有时候我们往往会碰到一些变态的场景或者变态的用户需求，比如说在一堆乱码中混入一个正常帧，又或者是在一个半帧后面接一个正常帧，在这种情况下程序能否正常解析，就很考验程序设计的功力了。目前的方案是，从第一个起始符开始尝试与指定的协议进行匹配，如果匹配成功，则正常返回；如果匹配失败，则自动从下一个字节或者下一个起始符开始继续匹配，直到匹配成功。</p><h2 id="丰富的协议解析能力"><a href="#丰富的协议解析能力" class="headerlink" title="丰富的协议解析能力"></a>丰富的协议解析能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/protocol.png"></p><p>我个人认为一个端口只支持解析一种协议的设计是很鸡肋的，无法满足一些变态的用户需求。为此，本人设计了一套全新的通信系统，支持在同一个端口上解析多种协议。其原理为，从底层数据缓冲区中一个字节一个字节地读取数据，每拿取一个字节，就与协议库中的若干协议比对一次，直到比对成功。</p><h2 id="灵活的端口转发能力"><a href="#灵活的端口转发能力" class="headerlink" title="灵活的端口转发能力"></a>灵活的端口转发能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/transforward.png"></p><p>数据帧在单个端口内完成接收、解析、处理、响应的设计是比较简单的，而一旦涉及到转发，事情就变得复杂了。首先，要想在任意端口之间转发，就不能把端口分成上行、下行，左行、右行也不行，所有端口都应该是平等的，且遵循同一套规则。其次，两个端口所用的协议有很大可能是不同的，所以还需要支持协议转换。协议转换详见下一章节。</p><h2 id="良好的协议扩展能力"><a href="#良好的协议扩展能力" class="headerlink" title="良好的协议扩展能力"></a>良好的协议扩展能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/topology.png"></p><p>协议转换最容易想到的就是两两转换，不过两两转换在协议少的时候还好说，干就完了，但是后期若是要扩展第三个、第Ｎ个协议，两两转换的弊端就显现出来了，其工作量可是呈C₂ⁿ级增长的。而星形拓扑的设计则可以很好地解决这个问题。</p><table><thead><tr><th align="center">协议数量</th><th align="center">网状拓扑 O(C₂ⁿ)</th><th align="center">星形拓扑 O(n)</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">6</td><td align="center">4</td></tr><tr><td align="center">5</td><td align="center">10</td><td align="center">5</td></tr><tr><td align="center">6</td><td align="center">15</td><td align="center">6</td></tr></tbody></table><h2 id="通信模块的转发原理"><a href="#通信模块的转发原理" class="headerlink" title="通信模块的转发原理"></a>通信模块的转发原理</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/implementation.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/cover.png&quot;&gt;&lt;/p&gt;
&lt;br&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;特性概述&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;详细说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;较强的接收容错能力&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;自动从下一个起始符继续匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;丰富的协议解析能力&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;同一个端口支持解析多种协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;灵活的端口转发能力&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持在任意端口之间相互转发（转发时支持协议转换）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;良好的协议扩展能力&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;采用星形拓扑｜方便后期扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>调试精灵使用说明</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cly6m4gfj002qscrq77a5a7cn.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cly6m4gfj002qscrq77a5a7cn.html</id>
    <published>2024-06-30T01:51:48.000Z</published>
    <updated>2024-06-30T01:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<center><a href="https://code.visualstudio.com/Download">「这是一个内置 DLT645 规则解析引擎的协议测试工具」</a></center><br><p><img src="/sulfurandcu.io/cly6m4gfj002qscrq77a5a7cn/toolkit.dlt645.png"></p><span id="more"></span><h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><p>按照数据类型可分为：</p><ul><li>time</li><li>bcd</li><li>hex</li><li>bit</li><li>string</li><li>block</li></ul><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>数据格式为 YY、MM、DD、WW、hh、mm、ss 的自由组合。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;日期时间&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;time&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;YYMMDDWWhhmmss&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="bcd"><a href="#bcd" class="headerlink" title="bcd"></a>bcd</h3><p>第一种：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;当前电压（Ａ相）（XXX.X）&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">    &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>第二种（数据块）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;当前电压（整块）（XXX.X）　&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &quot;XXX.X&quot;,</span><br><span class="line">        &quot;XXX.X&quot;,</span><br><span class="line">        &quot;XXX.X&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>如果数据块中的数据单位不一样，则建议使用 block 类型。</p></blockquote><h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><p>需要显示原数据的要使用 hex 类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;通信地址&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;hex&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XXXXXXXXXXXX&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>一些没有数据域的控制指令也可以使用 hex 类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;设备重启&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;hex&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>位解析配置如下：</p><ul><li>lsb：表示该位段的最低位</li><li>msb：表示该位段的最高位</li><li>XX.：表示该位段的枚举值（00 ~ FF）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;有功组合方式特征字&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bit&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XX&quot;,</span><br><span class="line">    &quot;bits&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;正向有功&quot;,</span><br><span class="line">            &quot;lsb&quot;: 0,</span><br><span class="line">            &quot;msb&quot;: 1,</span><br><span class="line">            &quot;00&quot;: &quot;不加不减&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;加&quot;,</span><br><span class="line">            &quot;02&quot;: &quot;减&quot;,</span><br><span class="line">            &quot;03&quot;: &quot;又加又减&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;反向有功&quot;,</span><br><span class="line">            &quot;lsb&quot;: 2,</span><br><span class="line">            &quot;msb&quot;: 3,</span><br><span class="line">            &quot;00&quot;: &quot;不加不减&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;加&quot;,</span><br><span class="line">            &quot;02&quot;: &quot;减&quot;,</span><br><span class="line">            &quot;03&quot;: &quot;又加又减&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>支持多字节的位解析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;主动上报模式字&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bit&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XXXXXXXXXXXXXXXX&quot;,</span><br><span class="line">    &quot;bits&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-14: 分闸&quot;,</span><br><span class="line">            &quot;lsb&quot;: 14,</span><br><span class="line">            &quot;msb&quot;: 14,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-15: 合闸&quot;,</span><br><span class="line">            &quot;lsb&quot;: 15,</span><br><span class="line">            &quot;msb&quot;: 15,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-16: 失压&quot;,</span><br><span class="line">            &quot;lsb&quot;: 16,</span><br><span class="line">            &quot;msb&quot;: 16,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-17: 欠压&quot;,</span><br><span class="line">            &quot;lsb&quot;: 17,</span><br><span class="line">            &quot;msb&quot;: 17,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-18: 过压&quot;,</span><br><span class="line">            &quot;lsb&quot;: 18,</span><br><span class="line">            &quot;msb&quot;: 18,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>目前「fillin」「fillat」「endian」暂不支持。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;资产编码（ASCII）&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;len&quot;: 32,</span><br><span class="line">    &quot;fillin&quot;: 0,</span><br><span class="line">    &quot;fillat&quot;: &quot;front&quot;,</span><br><span class="line">    &quot;endian&quot;: &quot;LE&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>block 类型中可以放置上述任意类型，支持在 block 中嵌套 block 类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;电压整定参数块&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;过压整定值&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;欠压整定值&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;断相整定值&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;瞬时冻结（数据块）&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;冻结时间&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;time&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;YYMMDDhhmm&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;正向有功电能（总）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kWh&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;反向有功电能（总）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kWh&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;组合无功电能（c1）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kvarh&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;组合无功电能（c2）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kvarh&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;center&gt;&lt;a href=&quot;https://code.visualstudio.com/Download&quot;&gt;「这是一个内置 DLT645 规则解析引擎的协议测试工具」&lt;/a&gt;&lt;/center&gt;

&lt;br&gt;

&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cly6m4gfj002qscrq77a5a7cn/toolkit.dlt645.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>开发环境配置指南</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2.html</id>
    <published>2024-01-30T00:52:09.000Z</published>
    <updated>2024-01-30T00:52:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>vscode + scons + arm-none-eabi-gcc + cortex-debug + jlink</p><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><h3 id="1-1-安装-vscode-软件"><a href="#1-1-安装-vscode-软件" class="headerlink" title="1.1 安装 vscode 软件"></a>1.1 安装 vscode 软件</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.vscode.png"></p><center><a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a></center><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install vscode extentions: C/C++ &amp; C/C++ Extension Pack</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install vscode extentions: Cortex-Debug</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install vscode extentions: RTOS-Views, Memory-View, Peripheral-Viewer</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="1-2-安装-python-环境"><a href="#1-2-安装-python-环境" class="headerlink" title="1.2 安装 python 环境"></a>1.2 安装 python 环境</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.python.png"></p><center><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></center><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install python scripts: cmd &gt; pip install scons==3.1.2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install python scripts: cmd &gt; pip install pywin32</span><br></pre></td></tr></table></figure><figure class="highlight py"><figcaption><span>使用文本编辑器打开 scons 文件（该文件在你 python 安装路径下的 Scripts 目录中）</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.dont_write_bytecode = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 在 `import sys` 的下一行添加 `sys.dont_write_bytecode = True` 语句（避免生成 __pycache__ 目录）</span></span><br></pre></td></tr></table></figure><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><h3 id="2-1-安装-arm-none-eabi-交叉编译工具链"><a href="#2-1-安装-arm-none-eabi-交叉编译工具链" class="headerlink" title="2.1 安装 arm-none-eabi 交叉编译工具链"></a>2.1 安装 arm-none-eabi 交叉编译工具链</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.armtoolchain.png"></p><center><a href="https://developer.arm.com/downloads/-/gnu-rm">gcc-arm-none-eabi-10.3-2021.10-win32.zip</a></center><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将压缩文件解压至任意位置</span><br></pre></td></tr></table></figure><h3 id="2-2-新建-build-任务"><a href="#2-2-新建-build-任务" class="headerlink" title="2.2 新建 build 任务"></a>2.2 新建 build 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若任务存在则该步骤可跳过</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>task.json</span><a href="https://code.visualstudio.com/docs/editor/tasks">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scons -j16&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scons -c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-测试-build-任务"><a href="#2-3-测试-build-任务" class="headerlink" title="2.3 测试 build 任务"></a>2.3 测试 build 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 vscode 打开测试工程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;build（首次执行时会报错并自动生成 rtconfig.ini 文件）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 rtconfig.ini 填入 arm-none-eabi 安装路径（i.e. d:\arm-none-eabi-10.3-2021.10\bin）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;clean</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;build</span><br></pre></td></tr></table></figure><h2 id="3-烧录"><a href="#3-烧录" class="headerlink" title="3. 烧录"></a>3. 烧录</h2><h3 id="3-1-安装-JLink-工具"><a href="#3-1-安装-JLink-工具" class="headerlink" title="3.1 安装 JLink 工具"></a>3.1 安装 JLink 工具</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.jlink.png"></p><center><a href="https://www.segger.com/downloads/jlink/">JLink 7.22b</a></center><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装 JLink 后要记得修改 JLinkDevices.xml 并拷贝相应的 device 文件</span><br></pre></td></tr></table></figure><h3 id="3-2-编写-write-脚本"><a href="#3-2-编写-write-脚本" class="headerlink" title="3.2 编写 write 脚本"></a>3.2 编写 write 脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若脚本存在则该步骤可跳过</span><br></pre></td></tr></table></figure><figure class="highlight bat"><figcaption><span>download.bat (build/gcc/bin/download.bat)</span></figcaption><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> config=download.ini</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span> <span class="variable">%config%</span> (</span><br><span class="line">    <span class="built_in">echo</span> error: <span class="variable">%config%</span> does <span class="keyword">not</span> <span class="keyword">exist</span>. but it should have been generated automatically, you need to fill <span class="keyword">in</span> some informations. ^(greetings from liujitong^)</span><br><span class="line">    <span class="built_in">echo</span> <span class="built_in">replace</span> this line with your jlink.exe <span class="built_in">path</span>. ^(i.e. D:\JLink\JLink.exe^) ^(<span class="keyword">do</span> <span class="keyword">not</span> commit this file to svn^) &gt; <span class="variable">%config%</span></span><br><span class="line">    <span class="keyword">goto</span> end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (<span class="variable">%config%</span>) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">set</span> <span class="built_in">path</span>=&quot;<span class="variable">%%i</span>&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable">%path%</span> -Device %<span class="number">1</span> -<span class="keyword">If</span> SWD -Speed <span class="number">12000</span> -AutoConnect <span class="number">1</span> -NoGui <span class="number">1</span> -CommandFile %~dp0\download.txt</span><br><span class="line"></span><br><span class="line">:end</span><br></pre></td></tr></table></figure><figure class="highlight txt"><figcaption><span>download.txt (build/gcc/bin/download.txt)</span></figcaption><table><tr><td class="code"><pre><span class="line">r</span><br><span class="line">h</span><br><span class="line">erase 0x00000000 0x00080000</span><br><span class="line">loadfile .\rtthread.bin 0x00000000</span><br><span class="line">r</span><br><span class="line">g</span><br><span class="line">q</span><br></pre></td></tr></table></figure><h3 id="3-3-新建-write-任务"><a href="#3-3-新建-write-任务" class="headerlink" title="3.3 新建 write 任务"></a>3.3 新建 write 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若任务存在则该步骤可跳过</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>task.json</span><a href="https://code.visualstudio.com/docs/editor/tasks">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;write&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd ./build/gcc/bin/; ./download.bat STM32F103&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;batch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scons -j16; cd ./build/gcc/bin/; ./download.bat STM32F103&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-测试-write-任务"><a href="#3-4-测试-write-任务" class="headerlink" title="3.4 测试 write 任务"></a>3.4 测试 write 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 vscode 打开测试工程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;build</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;write（首次执行时会报错并自动生成 build/gcc/bin/download.ini 文件）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 download.ini 填入 JLink.exe 所在路径（i.e. d:\JLink_V722b\JLink.exe）（注意 JLink.exe 不能省略）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;write</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;batch (batch == build + write)</span><br></pre></td></tr></table></figure><h2 id="4-调试"><a href="#4-调试" class="headerlink" title="4. 调试"></a>4. 调试</h2><h3 id="4-1-安装-vscode-插件"><a href="#4-1-安装-vscode-插件" class="headerlink" title="4.1 安装 vscode 插件"></a>4.1 安装 vscode 插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cortex-Debug</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RTOS-Views</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Memory-View</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peripheral-Viewer</span><br></pre></td></tr></table></figure><h3 id="4-2-配置-vscode-插件"><a href="#4-2-配置-vscode-插件" class="headerlink" title="4.2 配置 vscode 插件"></a>4.2 配置 vscode 插件</h3><figure class="highlight json"><figcaption><span>Cortex-Debug</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cortex-debug.ArmToolchainPath&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;i.e. d:\\arm-none-eabi-10.3-2021.10\\bin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;cortex-debug.JLinkGDBServerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i.e. d:\\JLink_V722b\\JLinkGDBServerCL.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="4-3-新建-launch-配置"><a href="#4-3-新建-launch-配置" class="headerlink" title="4.3 新建 launch 配置"></a>4.3 新建 launch 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若配置存在则该步骤可跳过</span><br></pre></td></tr></table></figure><figure class="highlight json"><figcaption><span>launch.json</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug@JLinkGDBServerCL.exe/stm32f103&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cortex-debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;servertype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jlink&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;serverArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;interface&quot;</span><span class="punctuation">:</span> <span class="string">&quot;swd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./build/gcc/bin/rtthread.elf&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STM32F103&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;svdFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./underlayer/cpu/st/arm/stm32f1xx_libraries/device/stm32f103.svd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;liveWatch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;samplesPerSecond&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-测试-launch-配置"><a href="#4-3-测试-launch-配置" class="headerlink" title="4.3 测试 launch 配置"></a>4.3 测试 launch 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 vscode 打开测试工程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 RunAndDebug 图标（左侧边栏）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择 launch 配置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 StartDebugging 按钮启动调试</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧 VARIABLES 窗口查看本地变量数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧 WATCH 窗口查看变量数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧 XPERIPHERALS 窗口查看寄存器数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 MEMORY 窗口查看内存数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 DEBUG CONSOLE 窗口键入 x/nfu addr 查看内存数据</span><br><span class="line">https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html</span><br></pre></td></tr></table></figure><h2 id="5-跳转"><a href="#5-跳转" class="headerlink" title="5. 跳转"></a>5. 跳转</h2><h3 id="5-1-安装-mingw-环境"><a href="#5-1-安装-mingw-环境" class="headerlink" title="5.1 安装 mingw 环境"></a>5.1 安装 mingw 环境</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.mingw.png"></p><center><a href="https://www.mingw-w64.org/downloads/">MingW-W64: x86_64-x.x.x-release-win32-seh-ucrt-xxx.7z</a></center><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将压缩文件解压至任意位置</span><br></pre></td></tr></table></figure><h3 id="5-2-配置-C-x2F-C-插件"><a href="#5-2-配置-C-x2F-C-插件" class="headerlink" title="5.2 配置 C&#x2F;C++ 插件"></a>5.2 配置 C&#x2F;C++ 插件</h3><figure class="highlight json"><figcaption><span>C/C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;C_Cpp.default.compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i.e. d:\\mingw-w64-builds\\x86_64-win32-seh-ucrt\\mingw64\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="5-3-配置-c-cpp-properties-json-文件"><a href="#5-3-配置-c-cpp-properties-json-文件" class="headerlink" title="5.3 配置 c_cpp_properties.json 文件"></a>5.3 配置 c_cpp_properties.json 文件</h3><figure class="highlight json"><figcaption><span>c_cpp_properties.json</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/application&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/board&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/rt-thread&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/underlayer&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__CC_ARM&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c99&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-测试-c-cpp-properties-json-文件"><a href="#5-4-测试-c-cpp-properties-json-文件" class="headerlink" title="5.4 测试 c_cpp_properties.json 文件"></a>5.4 测试 c_cpp_properties.json 文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重启 vscode 打开测试工程后不弹出警告即可</span><br></pre></td></tr></table></figure><h2 id="6-交互（shell）"><a href="#6-交互（shell）" class="headerlink" title="6. 交互（shell）"></a>6. 交互（shell）</h2><h3 id="6-1-安装-shell-工具"><a href="#6-1-安装-shell-工具" class="headerlink" title="6.1 安装 shell 工具"></a>6.1 安装 shell 工具</h3><ul><li><a href="https://github.com/kingToolbox/WindTerm/releases/download/2.6.0/WindTerm_2.6.0_Windows_Portable_x86_32.zip">WindTerm_2.6.0_Windows_Portable_x86_32.zip</a></li><li><a href="https://github.com/kingToolbox/WindTerm/releases/download/2.6.0/WindTerm_2.6.0_Windows_Portable_x86_64.zip">WindTerm_2.6.0_Windows_Portable_x86_64.zip</a></li></ul><h3 id="6-2-新建-shell-会话"><a href="#6-2-新建-shell-会话" class="headerlink" title="6.2 新建 shell 会话"></a>6.2 新建 shell 会话</h3><figure class="highlight txt"><figcaption><span>serial</span></figcaption><table><tr><td class="code"><pre><span class="line">- 会话</span><br><span class="line">  - 串口：COM3</span><br><span class="line">  - 数据：text</span><br><span class="line">- 串口</span><br><span class="line">  - 协议</span><br><span class="line">    - 波特率：115200</span><br><span class="line">    - 数据位：8</span><br><span class="line">    - 校验位：N</span><br><span class="line">    - 停止位：1</span><br><span class="line">    - 流控制：N</span><br></pre></td></tr></table></figure><h3 id="6-3-测试-shell-交互"><a href="#6-3-测试-shell-交互" class="headerlink" title="6.3 测试 shell 交互"></a>6.3 测试 shell 交互</h3><figure class="highlight txt"><figcaption><span>serial COM3</span></figcaption><table><tr><td class="code"><pre><span class="line">msh &gt;</span><br><span class="line">msh &gt;</span><br><span class="line">msh &gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;vscode + scons + arm-none-eabi-gcc + cortex-debug + jlink&lt;/p&gt;
&lt;h2 id=&quot;1-准备&quot;&gt;&lt;a href=&quot;#1-准备&quot; class=&quot;headerlink&quot; title=&quot;1. 准备&quot;&gt;&lt;/a&gt;1. 准备&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装-vscode-软件&quot;&gt;&lt;a href=&quot;#1-1-安装-vscode-软件&quot; class=&quot;headerlink&quot; title=&quot;1.1 安装 vscode 软件&quot;&gt;&lt;/a&gt;1.1 安装 vscode 软件&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.vscode.png&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;https://code.visualstudio.com/download&quot;&gt;https://code.visualstudio.com/download&lt;/a&gt;&lt;/center&gt;&lt;br&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;install vscode extentions: C/C++ &amp;amp; C/C++ Extension Pack&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;install vscode extentions: Cortex-Debug&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;install vscode extentions: RTOS-Views, Memory-View, Peripheral-Viewer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>freertos or rtthread ?</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cm03lc8n5007fdgrqhk1m06ee.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cm03lc8n5007fdgrqhk1m06ee.html</id>
    <published>2023-11-30T06:53:09.000Z</published>
    <updated>2023-11-30T06:53:09.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">对比条目</th><th align="center">FreeRTOS</th><th align="center">RT-Thread</th></tr></thead><tbody><tr><td align="center">许可协议</td><td align="center">MIT</td><td align="center">Apache License 2.0</td></tr><tr><td align="center">内核开销</td><td align="center">ROM: 5KB<br>RAM: 2KB</td><td align="center">ROM: 3KB<br>RAM: 1KB</td></tr><tr><td align="center">实测开销</td><td align="center"></td><td align="center">ROM: 11KB<br>RAM: 1KB</td></tr><tr><td align="center">抢占调度</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">轮转调度</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">多任务</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">优先级</td><td align="center">32</td><td align="center">8&#x2F;32&#x2F;256</td></tr><tr><td align="center">信号量</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">互斥量</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">事件集</td><td align="center">×</td><td align="center">支持</td></tr><tr><td align="center">邮箱</td><td align="center">×</td><td align="center">支持</td></tr><tr><td align="center">信号</td><td align="center">×</td><td align="center">支持</td></tr><tr><td align="center">消息队列</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">内存管理</td><td align="center">heap1 - heap5</td><td align="center">内存堆管理 | 内存池管理</td></tr><tr><td align="center"><br></td><td align="center"><br></td><td align="center"><br></td></tr><tr><td align="center">系统兼容</td><td align="center">×</td><td align="center">提供 FreeRTOS_Wrapper 兼容层</td></tr><tr><td align="center">posix</td><td align="center">×</td><td align="center">支持</td></tr><tr><td align="center">shell</td><td align="center">×</td><td align="center">MSH, FINSH</td></tr><tr><td align="center">网络系统</td><td align="center">×</td><td align="center">SAL + AT &#x2F; LwIP</td></tr><tr><td align="center">文件系统</td><td align="center">FATFS</td><td align="center">DFS + FATFS &#x2F; RomFS &#x2F; Yaffs2 &#x2F; Uffs2 &#x2F; DevFS</td></tr><tr><td align="center">spiflash</td><td align="center">×</td><td align="center">FlashDB + FAL + SFUD</td></tr><tr><td align="center">设备框架</td><td align="center">×</td><td align="center">支持</td></tr><tr><td align="center">电源管理</td><td align="center">×</td><td align="center">支持</td></tr><tr><td align="center">图形界面</td><td align="center">×</td><td align="center">支持</td></tr></tbody></table><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 656         58          0         28       1024       8091   heap_4.o</span><br><span class="line"> 124          0          0          0          0       6561   list.o</span><br><span class="line"> 894         78          0         12          0      11256   port.o</span><br><span class="line">2212        270          0         64        240      31123   tasks.o</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 168         16          0          8          0       2064   clock.o</span><br><span class="line"> 186         30         16          0          0       5388   components.o</span><br><span class="line"> 252         28          0          0          0        780   context_rvds.o</span><br><span class="line"> 640        342          0         16          0       3954   cpuport.o</span><br><span class="line">  24          0          0          0          0        609   cstdlib.o</span><br><span class="line"> 270          0          0          0          0       2774   device.o</span><br><span class="line"> 300         34          0          8        416       6238   idle.o</span><br><span class="line">1680         24          0          0          0      16384   ipc.o</span><br><span class="line"> 132         26          0          9          0       2282   irq.o</span><br><span class="line">2316        240        154        140        172      14344   kservice.o</span><br><span class="line"> 676         68          0          0          0       4430   mem.o</span><br><span class="line"> 486         26          0        196          0      10134   object.o</span><br><span class="line">  56         12          0          0         68       1341   pin.o</span><br><span class="line"> 976        178          0         24        256       9528   scheduler_up.o</span><br><span class="line">  12          0          0          0          0        540   syscalls.o</span><br><span class="line">1170         28          0         12          0      14517   thread.o</span><br><span class="line"> 948         44          0         20          0       9237   timer.o</span><br><span class="line"> 346         28          4          4          0       6717   workqueue.o</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;对比条目&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;FreeRTOS&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;RT-Thread&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;许可协议&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MIT&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Apache License 2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;内核开销&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;ROM: 5KB&lt;br&gt;RAM: 2KB&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;ROM: 3KB&lt;br&gt;RAM: 1KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;实测开销&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;ROM: 11KB&lt;br&gt;RAM: 1KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;抢占调度&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;轮转调度&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;多任务&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;优先级&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;32&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&amp;#x2F;32&amp;#x2F;256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;信号量&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;互斥量&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;事件集&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;邮箱&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;信号&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;消息队列&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;内存管理&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;heap1 - heap5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;内存堆管理 | 内存池管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;br&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;br&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;br&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;系统兼容&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;提供 FreeRTOS_Wrapper 兼容层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;posix&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;shell&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MSH, FINSH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;网络系统&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;SAL + AT &amp;#x2F; LwIP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;文件系统&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;FATFS&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;DFS + FATFS &amp;#x2F; RomFS &amp;#x2F; Yaffs2 &amp;#x2F; Uffs2 &amp;#x2F; DevFS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;spiflash&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;FlashDB + FAL + SFUD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;设备框架&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;电源管理&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;图形界面&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;×&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>中断向量表偏移寄存器配置方式</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clpga8j0y00i3dcrq5x5t1gkd.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clpga8j0y00i3dcrq5x5t1gkd.html</id>
    <published>2023-11-27T02:19:53.000Z</published>
    <updated>2023-11-27T02:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于「引导程序＋应用程序」之类的方案，我们通常是在系统初始化函数（SystemInit()）中配置中断向量表偏移寄存器来实现中断向量表的重定向。但是这种直接修改官方库的方式往往会给后期的版本管理带来诸多不便。基于此，本文给出一个替代方案，供诸位参考。</p><figure class="highlight c"><figcaption><span>vtor.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xxx32xxxx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECTOR_TABLE_OFFSET             ((uint32_t)0x00018000) <span class="comment">/* % 0x200 == 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROM_BASE                        ((uint32_t)0x08000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_BASE                        ((uint32_t)0x20000000)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemVTOR</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> EXECUTE_IN_RAM</span></span><br><span class="line">    SCB-&gt;VTOR = RAM_BASE | VECTOR_TABLE_OFFSET;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    SCB-&gt;VTOR = ROM_BASE | VECTOR_TABLE_OFFSET;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>startup_xxx32xxxx.s</span></figcaption><table><tr><td class="code"><pre><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler   [WEAK]</span><br><span class="line">                IMPORT  SystemVTOR</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                IMPORT  __main</span><br><span class="line"></span><br><span class="line">                LDR     R0, =SystemVTOR</span><br><span class="line">                BLX     R0</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0</span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="开发指北" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97/"/>
    
    
  </entry>
  
  <entry>
    <title>开发指南：华大 HC32F460 &amp; HC32F4A0 比较</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cm04je64700adckrq3udz79n5.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cm04je64700adckrq3udz79n5.html</id>
    <published>2023-11-21T02:35:29.000Z</published>
    <updated>2023-11-21T02:35:29.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">对比条目</th><th align="center">HC32F460</th><th align="center">HC32F4A0</th></tr></thead><tbody><tr><td align="center">工作频率</td><td align="center">200MHz</td><td align="center">240MHz</td></tr><tr><td align="center">内核架构</td><td align="center">Cortex-M4 + FPU + DSP + MPU</td><td align="center">Cortex-M4 + FPU + DSP + MPU</td></tr><tr><td align="center">芯片封装</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ROM</td><td align="center">512KB | 256KB</td><td align="center">1024KB | 2048KB</td></tr><tr><td align="center">RAM</td><td align="center">192KB</td><td align="center">516KB</td></tr><tr><td align="center">PGA</td><td align="center">×1</td><td align="center">×4</td></tr><tr><td align="center">CMP</td><td align="center">×3</td><td align="center">×4</td></tr><tr><td align="center">ADC</td><td align="center">×2</td><td align="center">×3</td></tr><tr><td align="center">DAC</td><td align="center">×2</td><td align="center">×4</td></tr><tr><td align="center">TMR</td><td align="center">Timer6 ×3 (16bit 高级 PWM Timer)<br>Timer4 ×3 (16bit 电机 PWM Timer)<br>TimerA ×6 (16bit 通用 PWM Timer)<br><br>Timer0 ×2 (16bit 通用 ___ Timer)</td><td align="center">Timer6  ×8 (16bit 高级 PWM Timer)<br>Timer4  ×3 (16bit 电机 PWM Timer)<br>TimerA ×C (16bit 通用 PWM Timer)<br>Timer2  ×4 (16bit 通用 ___ Timer)<br>Timer0  ×2 (16bit 通用 ___ Timer)</td></tr><tr><td align="center">RTC</td><td align="center">×1</td><td align="center">×1</td></tr><tr><td align="center">WDT</td><td align="center">WDT &amp; SWDT</td><td align="center">WDT &amp; SWDT</td></tr><tr><td align="center">URT</td><td align="center">×4</td><td align="center">×10</td></tr><tr><td align="center">SPI</td><td align="center">×4</td><td align="center">×6</td></tr><tr><td align="center">QSPI</td><td align="center">×1</td><td align="center">×1</td></tr><tr><td align="center">I2C</td><td align="center">×3</td><td align="center">×6</td></tr><tr><td align="center">I2S</td><td align="center">×4</td><td align="center">×4</td></tr><tr><td align="center">CAN</td><td align="center">×1</td><td align="center">×2</td></tr><tr><td align="center">USB</td><td align="center">×1</td><td align="center">×1</td></tr><tr><td align="center">ETH</td><td align="center">-</td><td align="center">×1</td></tr><tr><td align="center">SDIO</td><td align="center">×2</td><td align="center">×2</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="开发指南" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="华大半导体" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%8D%8E%E5%A4%A7%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
    <category term="HC32F4A0" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F4A0/"/>
    
  </entry>
  
  <entry>
    <title>问题记录：华大 HC32F460 内存边界禁止非对齐访问</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1.html</id>
    <published>2023-11-09T01:14:29.000Z</published>
    <updated>2023-11-09T01:14:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章更新（2023-11-14）"><a href="#文章更新（2023-11-14）" class="headerlink" title="文章更新（2023-11-14）"></a>文章更新（2023-11-14）</h2><p>经过排查，本文所述异常现象并非由「非对齐访问」所致，而是因为 SRAM3 开启 ECC 校验时仅支持以字为单位进行访问。</p><h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><ul><li>程序无法正常启动</li><li>有时会进入 hard fault 中断</li><li>有时候会出现以下异常：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Call Stack + Locals                                                                    ✘</span><br><span class="line">    Name                                Location/Value                          Type</span><br><span class="line">    __scatterload_zeroinit              0x00074C56                              function</span><br><span class="line">    __scatterload                       0x00018DFE                              function</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><h3 id="芯片资源"><a href="#芯片资源" class="headerlink" title="芯片资源"></a>芯片资源</h3><ul><li>RAM 192KB&#x2F;0x30000</li><li>ROM 512KB&#x2F;0x80000（其中通过分散加载给应用程序分配的空间为 416KB&#x2F;0x68000）</li></ul><h3 id="链接数据"><a href="#链接数据" class="headerlink" title="链接数据"></a>链接数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">    Total RO  Size (Code + RO Data)               419844 ( 410.00kB)</span><br><span class="line">    Total RW  Size (RW Data + ZI Data)            163952 ( 160.11kB)</span><br><span class="line">    Total ROM Size (Code + RO Data + RW Data)     421056 ( 411.19kB)</span><br><span class="line"></span><br><span class="line">==============================================================================</span><br></pre></td></tr></table></figure><h3 id="分散加载"><a href="#分散加载" class="headerlink" title="分散加载"></a>分散加载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line"></span><br><span class="line">; 中断向量</span><br><span class="line">ER_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序信息</span><br><span class="line">ER_IROM2 + 0 &#123;</span><br><span class="line">*.o (SECTION_INFO_APP, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序代码</span><br><span class="line">ER_IROM3 + 0 &#123;</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 内存空间</span><br><span class="line">RW_IRAM1 0x1FFF8000 0x00030000 &#123;</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>由于代码量比较临界，起初我以为是 flash 的问题。但是 map 文件中显示 ROM 只占用了 411.19kB 的空间，并没有超过 416KB 的总量。那 RAM 呢？RAM 只用了 160.11KB 也没有超过 192KB 的总量，邪了门儿了真是！哎，等等！这款芯片的 RAM 我记得好像是分成了两块，怎么说的来着，瞅一眼《参考手册》：</p><p><img src="/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1/HC32F460-manual.png"></p><p>果然，两块 RAM 间不支持非对齐访问，再一看 SRAMH 的大小：32KB！<del>破案了！现在 RAM 的用量不正好到达 160KB（192KB - 32KB &#x3D; 160KB）这个临界点了么！</del></p><blockquote><p>超过 160KB 确实会出现异常，但不是因达到 SRAMH 所致（SRAMH 地址最小，始终会用到）而是因达到 SRAM3 且使能 ECC 校验所致。注意看红线上面的那句话：「在允许 RAM ECC 校验错误产生 NMI 中断和复位的情况下，必须对所用 RAM 空间以字（16bit）为单位进行访问」。</p></blockquote><p>按照现有分散加载文件的写法，两块内存会被认为是一个整体，那么就必然存在「在内存边界处进行非对齐访问」的可能。</p><h2 id="规避方法"><a href="#规避方法" class="headerlink" title="规避方法"></a>规避方法</h2><p>非对齐访问的风险可以在分散加载文件中将两块内存断开：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line"></span><br><span class="line">; 中断向量</span><br><span class="line">ER_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序信息</span><br><span class="line">ER_IROM2 + 0 &#123;</span><br><span class="line">*.o (SECTION_INFO_APP, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序代码</span><br><span class="line">ER_IROM3 + 0 &#123;</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 内存空间</span><br><span class="line">RW_IRAM1 0x1FFF8000 0x00007FF0 &#123; ; 空出若干字节不用，以避免非对齐访问。</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 内存空间</span><br><span class="line">RW_IRAM2 0x20000000 0x00028000 &#123;</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SRAM3 开启 ECC 后仅支持以字为单位进行访问的问题可以通过禁用 ECC 功能来解决。当然如果你一定要用 ECC 的话，那这块空间肯定不能用来让编译器自动分配内存，而是要自己来手动管理。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;文章更新（2023-11-14）&quot;&gt;&lt;a href=&quot;#文章更新（2023-11-14）&quot; class=&quot;headerlink&quot; title=&quot;文章更新（2023-11-14）&quot;&gt;&lt;/a&gt;文章更新（2023-11-14）&lt;/h2&gt;&lt;p&gt;经过排查，本文所述异常现象并非由「非对齐访问」所致，而是因为 SRAM3 开启 ECC 校验时仅支持以字为单位进行访问。&lt;/p&gt;
&lt;h2 id=&quot;现象描述&quot;&gt;&lt;a href=&quot;#现象描述&quot; class=&quot;headerlink&quot; title=&quot;现象描述&quot;&gt;&lt;/a&gt;现象描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序无法正常启动&lt;/li&gt;
&lt;li&gt;有时会进入 hard fault 中断&lt;/li&gt;
&lt;li&gt;有时候会出现以下异常：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Call Stack + Locals                                                                    ✘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Name                                Location/Value                          Type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __scatterload_zeroinit              0x00074C56                              function&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __scatterload                       0x00018DFE                              function&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="华大半导体" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%8D%8E%E5%A4%A7%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>我的一套生产工具</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html</id>
    <published>2023-10-15T02:54:20.000Z</published>
    <updated>2023-10-15T02:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一些提高工作效率的工具</p><span id="more"></span><h2 id="机械键盘"><a href="#机械键盘" class="headerlink" title="机械键盘"></a>机械键盘</h2><ul><li>使用 tmk, qmk 等工具烧录自定义固件</li></ul><h2 id="键位布局"><a href="#键位布局" class="headerlink" title="键位布局"></a>键位布局</h2><ul><li><a href="/sulfurandcu.io/clnor6mvz0015ocrq2jks39ew.html">dƷvorak</a></li></ul><h2 id="输入法儿"><a href="#输入法儿" class="headerlink" title="输入法儿"></a>输入法儿</h2><ul><li>昨夏双拼</li><li>小鹤双拼</li><li>朙月拼音</li><li>宫保拼音</li></ul><h2 id="输入引擎"><a href="#输入引擎" class="headerlink" title="输入引擎"></a>输入引擎</h2><ul><li>中州韵输入法引擎（rime, weasel, squirrel）</li></ul><h2 id="显示字体"><a href="#显示字体" class="headerlink" title="显示字体"></a>显示字体</h2><ul><li>思源宋体</li><li>思源黑体</li><li>更纱黑体</li><li>等宽字体（iosevka）</li><li>可变字体（Amstelvar）</li></ul><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><ul><li>powertoys</li></ul><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><ul><li>clash.for.windows (<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a>)</li><li>xtls.space (<a href="https://xtlspace.20181024.xyz/#/register?code=bUox1yaB">https://xtlspace.20181024.xyz/#/register?code=bUox1yaB</a>)</li><li>tor.browser (<a href="https://www.torproject.org/download/">https://www.torproject.org/download/</a>)</li><li>tor.zlibrary (<a href="http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/">http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/</a>)</li></ul><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><ul><li>Aria2</li><li>ndm</li><li>qbittorrent</li></ul><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul><li>localsend</li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li>qdir</li><li>everything</li></ul><h2 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h2><ul><li>winmerge</li></ul><h2 id="远程终端"><a href="#远程终端" class="headerlink" title="远程终端"></a>远程终端</h2><ul><li>windterm</li></ul><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><ul><li>windows.terminal</li><li>windows.sandboxs</li><li>wsl</li><li>docker</li><li>cygwin (posix.api&#x2F;cygwin1.dll, bin&#x3D;windows.pe)</li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>mingw&#x2F;msys1 (shell) (posix.api&#x2F;msys-1.0.dll) (msys1~cmd.exe, mingw&#x2F;msys1~cygwin)</li><li>mingw&#x2F;msys2 (shell) (posix.api&#x2F;msys-2.0.dll) (msys2~cmd.exe, mingw&#x2F;msys2~cygwin)</li><li>scons</li><li>cmake.for.windows</li><li>ninja.for.windows</li><li>mingw.for.windows   (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>mingw32 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>mingw64 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li></ul><h2 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h2><ul><li>vscode</li><li>vs</li><li>eclipse</li><li>android.studio</li></ul><h2 id="软件开发（嵌入式）"><a href="#软件开发（嵌入式）" class="headerlink" title="软件开发（嵌入式）"></a>软件开发（嵌入式）</h2><ul><li>arm-none-eabi</li><li>jlink</li><li>openocd</li></ul><h2 id="硬件开发"><a href="#硬件开发" class="headerlink" title="硬件开发"></a>硬件开发</h2><ul><li>KiCAD</li></ul><h2 id="机械工业"><a href="#机械工业" class="headerlink" title="机械工业"></a>机械工业</h2><ul><li>AutoCAD</li><li>FreeCAD</li><li>Revit</li><li>Rhino</li><li>3dsMax</li><li>SketchUp</li><li>Render.Vray</li><li>Render.D5</li><li>Render.Enscape</li></ul><h2 id="图片文档"><a href="#图片文档" class="headerlink" title="图片文档"></a>图片文档</h2><ul><li>截屏工具<ul><li>fscapture</li><li>sharex</li></ul></li><li>图片查看<ul><li>honeyview</li></ul></li><li>图片编辑<ul><li>GIMP</li><li>inkscape</li><li>shift.n</li><li>ascii.generator</li></ul></li><li>文档查看<ul><li>PDF.24</li></ul></li><li>文档编辑<ul><li>draw.io</li><li>wave.drom.editor</li></ul></li></ul><h2 id="视频音频"><a href="#视频音频" class="headerlink" title="视频音频"></a>视频音频</h2><ul><li>录屏工具<ul><li>obs.studio</li><li>lonelyscreen (ios screen display)</li></ul></li><li>视频播放<ul><li>MPC-HC</li><li>VLC</li><li>PotPlayer</li></ul></li><li>视频剪辑<ul><li>shotcut</li><li>losslesscut</li></ul></li><li>视频转码<ul><li>handbrake</li></ul></li><li>音频播放<ul><li>foobar2000</li></ul></li><li>音频剪辑<ul><li>audacity</li><li>wavosaur</li></ul></li><li>音频转码<ul><li>略.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;分享一些提高工作效率的工具&lt;/p&gt;</summary>
    
    
    
    <category term="效率提升" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
    
    <category term="生产工具" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#08）引导程序 bootloader 升级</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html</id>
    <published>2023-09-30T16:00:08.000Z</published>
    <updated>2023-09-30T16:00:08.000Z</updated>
    
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#07）压缩解压 tinyuz 移植</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html</id>
    <published>2023-09-30T16:00:07.000Z</published>
    <updated>2023-09-30T16:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>与上文类似，对 tinyuz 也进行二次封装以便上层调用：</p><figure class="highlight c"><figcaption><span>tinyuz_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __tinyuz_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __tinyuz_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUZ_DECOMPRESS_SPACE_SIZE       512*1024            <span class="comment">// 外部存储中〈差分文件区〉的空间大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TTinyuzResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TINYUZ_SUCCESS=<span class="number">0</span>,</span><br><span class="line">    TINYUZ_OPTIONS_ERROR,</span><br><span class="line">    TINYUZ_OPENREAD_ERROR,</span><br><span class="line">    TINYUZ_OPENWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILEREAD_ERROR,</span><br><span class="line">    TINYUZ_FILEWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILECLOSE_ERROR,</span><br><span class="line">    TINYUZ_MEM_ERROR,</span><br><span class="line">    TINYUZ_COMPRESS_ERROR,</span><br><span class="line">    TINYUZ_DECOMPRESS_ERROR,</span><br><span class="line">&#125; TTinyuzResult;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __tinyuz_port_h__ */</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight c"><figcaption><span>tinyuz_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tinyuz_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuz_dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TTuzListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> hpatch_TStreamInput*  input_file_stream_handle;</span><br><span class="line">    hpatch_StreamPos_t          readPos;</span><br><span class="line">    tuz_TInputStream_read       _do_read_encompress_file;</span><br><span class="line">&#125;TTuzListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部flash中以数据流的形式读取压缩数据</span></span><br><span class="line">hpatch_BOOL _do_read_encompress_file(<span class="type">const</span> hpatch_TStreamInput* stream, hpatch_StreamPos_t readFromPos, <span class="type">unsigned</span> <span class="type">char</span>* out_data, <span class="type">unsigned</span> <span class="type">char</span>* out_data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> readLen = (<span class="type">size_t</span>)(out_data_end - out_data);</span><br><span class="line">    <span class="keyword">if</span> (readLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> compressed_stream_size = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((readLen &gt; compressed_stream_size) || (readFromPos &gt; compressed_stream_size - readLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, readFromPos, out_data, readLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将解压数据以数据流的形式写入外部flash中</span></span><br><span class="line">hpatch_BOOL _do_write_decompress_file(<span class="type">const</span> hpatch_TStreamOutput* stream, hpatch_StreamPos_t writeToPos, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> writeLen = (<span class="type">size_t</span>)(data_end - data);</span><br><span class="line">    <span class="keyword">if</span> (writeLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> write_max_space = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((writeLen &gt; write_max_space)||(writeToPos &gt; write_max_space - writeLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, offset+writeToPos, data, writeLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> tuz_BOOL <span class="title function_">input_file_stream_read_function</span><span class="params">(<span class="type">void</span> *listener, tuz_byte *decompressed_file_stream, <span class="type">tuz_size_t</span> *code_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    TTuzListener *self = (TTuzListener*)listener;</span><br><span class="line">    <span class="type">tuz_size_t</span> r_len = *code_size;</span><br><span class="line">    hpatch_StreamPos_t curReadPos = self-&gt;readPos;</span><br><span class="line">    hpatch_StreamPos_t s_size = self-&gt;input_file_stream_handle-&gt;streamSize - curReadPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_len &gt; s_size)&#123;</span><br><span class="line">        r_len = (<span class="type">tuz_size_t</span>)s_size;</span><br><span class="line">        *code_size = r_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;readPos += r_len;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;input_file_stream_handle-&gt;read(self-&gt;input_file_stream_handle, curReadPos, decompressed_file_stream, decompressed_file_stream + r_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    hpatch_TStreamOutput decompressed_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;decompressed_file_stream_handle,</span><br><span class="line">        .streamSize = TUZ_DECOMPRESS_SPACE_SIZE, <span class="comment">// 外部存储中〈差分文件区〉的空间大小</span></span><br><span class="line">        .write = _do_write_decompress_file, <span class="comment">// stream write</span></span><br><span class="line">        .read_writed = <span class="literal">NULL</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hpatch_TStreamInput input_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;input_file_stream_handle,</span><br><span class="line">        .streamSize = compressed_file_size, <span class="comment">// 压缩文件的实际大小</span></span><br><span class="line">        .read = _do_read_encompress_file, <span class="comment">// stream read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TTuzListener listener = &#123;&amp;input_file_stream_handle, <span class="number">0</span>, input_file_stream_read_function&#125;;</span><br><span class="line">    tuz_TStream tuz;</span><br><span class="line">    tuz_TResult result = tuz_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩的时候会以指定的字典大小进行压缩｜因此解压的时候要从压缩包头中读取字典大小</span></span><br><span class="line">    <span class="type">tuz_size_t</span> dictSize = tuz_TStream_read_dict_size(&amp;listener, listener._do_read_encompress_file);</span><br><span class="line"></span><br><span class="line">    tuz_byte* decompress_buf = <span class="number">0</span>;</span><br><span class="line">    cache_size &gt;&gt;= <span class="number">1</span>; <span class="comment">// 除二操作</span></span><br><span class="line">    decompress_buf = (tuz_byte*)tuz_malloc(dictSize + cache_size*<span class="number">2</span>); <span class="comment">// 解压过程中要用到的临时空间大小 = 字典大小 + 解压缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decompress_buf == <span class="number">0</span>) <span class="keyword">return</span> TINYUZ_MEM_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tuz_TStream_open 仅仅是用来初始化 tuz 这个勾柄的（tuz后面的参数都是给tuz赋值用的）</span></span><br><span class="line">    result = tuz_TStream_open(&amp;tuz, &amp;listener, listener._do_read_encompress_file, decompress_buf + cache_size, (<span class="type">tuz_size_t</span>)dictSize, (<span class="type">tuz_size_t</span>)cache_size);</span><br><span class="line"></span><br><span class="line">    hpatch_StreamPos_t stream_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (result == tuz_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">tuz_size_t</span> decompress_len = (<span class="type">tuz_size_t</span>)cache_size; <span class="comment">// 给decompress_len赋一个初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解压一包数据到 decompress_buf 中｜并得到该包长度 decompress_len</span></span><br><span class="line">        result = tuz_TStream_decompress_partial(&amp;tuz, decompress_buf, &amp;decompress_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt;= tuz_STREAM_END)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前解压的 decompress_buf 中的数据写到 decompressed_file_stream_handle 数据流中</span></span><br><span class="line">            <span class="keyword">if</span> (decompressed_file_stream_handle.write(&amp;decompressed_file_stream_handle, stream_index, decompress_buf, decompress_buf + decompress_len))</span><br><span class="line">            &#123;</span><br><span class="line">                stream_index += decompress_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tuz_free(decompress_buf);</span><br><span class="line">                <span class="keyword">return</span> TINYUZ_OPENWRITE_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tuz_free(decompress_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;与上文类似，对 tinyuz 也进行二次封装以便上层调用：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;tinyuz_port.h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifndef&lt;/span&gt; __tinyuz_port_h__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; __tinyuz_port_h__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stddef.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;malloc.h&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; TUZ_DECOMPRESS_SPACE_SIZE       512*1024            &lt;span class=&quot;comment&quot;&gt;// 外部存储中〈差分文件区〉的空间大小&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; tuz_malloc(x)                   mymalloc(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; tuz_free(x)                     myfree(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TTinyuzResult&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_SUCCESS=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPTIONS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPENREAD_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPENWRITE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILEREAD_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILEWRITE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILECLOSE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_MEM_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_COMPRESS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_DECOMPRESS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; TTinyuzResult;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;tuz_decompress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; compressed_file_size, &lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; cache_size)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* __tinyuz_port_h__ */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
    <category term="压缩解压算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#06）差分还原 hpatchlite 移植</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html</id>
    <published>2023-09-30T16:00:06.000Z</published>
    <updated>2023-09-30T16:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现了一个优秀的差分还原算法：hdiff &amp; hpatch，它通过数据流的思想把 O(n) 的空间复杂度转嫁给了硬盘，使得内存的开销极低，非常适合应用于嵌入式领域。</p><p><img src="/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff.tools.compare.png"></p><span id="more"></span><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="hpatchlite"><a href="#hpatchlite" class="headerlink" title="hpatchlite"></a>hpatchlite</h3><p>时间复杂度：O(oldSize+newSize)<br>空间复杂度：O(1)<br>　　还原代码开销｜ROM &#x3D; 876 字节 (compiled by armcc v5.06 update4 build 422)<br>　　还原内存开销｜RAM &#x3D; 还原缓冲大小 + 解压内存开销</p><p>注：还原缓冲大小在还原时指定，至少3个字节，还原缓冲越小还原得越慢。</p><h3 id="tinyuz"><a href="#tinyuz" class="headerlink" title="tinyuz"></a>tinyuz</h3><p>时间复杂度：O(oldSize+newSize)<br>空间复杂度：O(1)<br>　　解压代码开销｜流模式｜ROM &#x3D; 1142 字节 (compiled by armcc v5.06 update4 build 422)<br>　　解压内存开销｜流模式｜RAM &#x3D; 压缩字典大小 + 解压缓冲大小</p><p>注：压缩字典大小在压缩时指定，至少1个字节，压缩字典越小压缩率越低。<br>注：解压缓冲大小在解压时指定，至少2个字节，解压缓冲越小解压缩越慢。</p><h3 id="appendix"><a href="#appendix" class="headerlink" title="appendix"></a>appendix</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 876          0          0          0          0      10783   hpatch_lite.o</span><br><span class="line">1142          0          0          0          0      13541   tuz_dec.o</span><br><span class="line"></span><br><span class="line"> 626         80          0         12          0      12256   hpatch_user.o</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">244           0          0          0          0       2146   bspatch.o</span><br><span class="line">586           6         64          0          0       6749   quicklz.o</span><br><span class="line"></span><br><span class="line">102           4          8          0          0       2821   bspatch_user.o</span><br><span class="line"> 52           0          0          0          0       2096   quicklz_user.o</span><br></pre></td></tr></table></figure><h2 id="移植说明"><a href="#移植说明" class="headerlink" title="移植说明"></a>移植说明</h2><p>将 hdiffpatch.hpatchlite &amp; tinyuz 移植至单片机 bare metal 裸机系统（based on hdiffpatch v4）</p><h3 id="拿来"><a href="#拿来" class="headerlink" title="拿来"></a>拿来</h3><p>将 tinyuz&#x2F;decompress 目录拷贝至目标工程中。</p><p>将 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatch 目录拷贝至目标工程中。</p><p>将 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatchLite 目录拷贝至目标工程中。</p><p>将 HPatchLite&#x2F;decompresser_demo.h 文件拷贝至目标工程中。</p><h3 id="画瓢"><a href="#画瓢" class="headerlink" title="画瓢"></a>画瓢</h3><p>依 HPatchLite&#x2F;hpatchi.c&#x2F;hpatchi() 函数画瓢：移植还原功能</p><p>依 tinyuz&#x2F;tinyuz_demo.cpp&#x2F;_tuz_decompress_stream() 函数画瓢：移植解压功能</p><p>done!</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿来依葫芦画瓢，说得简单，做起来着实还是费了点功夫，这几年搞嵌入式搞得有些局限了，面对句(gōu)柄这种用法竟感觉无从下手。😅</p><p>作者提供了以下两个接口函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpatch_lite_open()</span><br><span class="line"></span><br><span class="line">hpatch_lite_patch()</span><br></pre></td></tr></table></figure><p>看着挺简单的吧，然而他实际上是这样的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hpatch_lite by stream: hpatch_lite_open()+hpatch_lite_patch() compiled by Mbed Studio is 662 bytes</span></span><br><span class="line"><span class="comment">//   hdiffpatch v4.2.3, other patcher compiled by Mbed Studio:</span></span><br><span class="line"><span class="comment">//      patch_single_stream() 2356 bytes (hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"><span class="comment">//      patch_decompress_with_cache() 2846 bytes (_IS_NEED_CACHE_OLD_BY_COVERS=0,hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//diff_data must created by create_lite_diff()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span>&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    <span class="comment">//must read data_size data to out_data, from read_from_pos of stream; if read error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    <span class="comment">//must write data_size data to sequence stream; if write error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hpatch_lite open</span></span><br><span class="line"><span class="comment">// read lite headinfo from diff_data</span></span><br><span class="line"><span class="comment">// if diff_data uncompress(*out_compress_type==hpi_compressType_no), *out_uncompressSize==0;</span></span><br><span class="line"><span class="comment">// if (*out_compress_type!=hpi_compressType_no), you need open compressed data by decompresser</span></span><br><span class="line"><span class="comment">//      (see https://github.com/sisong/HPatchLite/decompresser_demo.h &amp; https://github.com/sisong/HPatchLite/hpatchi.c)</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,</span></span><br><span class="line"><span class="params">                          hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br><span class="line"><span class="comment">//hpatch_lite patch</span></span><br><span class="line"><span class="comment">//used temp_cache_size memory + &#123;decompress buffer*1&#125;</span></span><br><span class="line"><span class="comment">//  note: temp_cache_size&gt;=hpi_kMinCacheSize</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,</span></span><br><span class="line"><span class="params">                           hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure><p>试着分析一下：</p><p><strong>差分包头信息读取接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分包头信息读取接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStreamHandle        diff_data           注意此处入参：差分数据流句柄（个人理解：如果不需要该句柄的话可以将其定义为空指针）</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStream_read         read_diff           注意此处入参：差分数据流读取函数（用户实现：以数据流的方式读取外部存储中差分数据分区的数据）</span></span><br><span class="line"><span class="comment"> * @param hpi_compressType             *out_compress_type   差分包头信息：差分包压缩类型</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_newSize         差分包头信息：还原数据的长度</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_uncompressSize  差分包头信息：解压之后的长度（如果差分包未被压缩则*out_uncompressSize输出0）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br></pre></td></tr></table></figure><p><strong>差分包头定义</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_kHeadSize (2+1+1) <span class="comment">//&quot;hI&quot; + hpi_compressType + (versionCode + newSize_Bytes + uncompressSize_Bytes) &#123; + newSize + uncompressSize&#125; &#123; + dictSize&#125;</span></span></span><br><span class="line">差分包头[<span class="number">0</span>] : 魔术数字 <span class="number">68</span> <span class="string">&#x27;h&#x27;</span></span><br><span class="line">差分包头[<span class="number">1</span>] : 魔术数字 <span class="number">49</span> <span class="string">&#x27;I&#x27;</span></span><br><span class="line">差分包头[<span class="number">2</span>] : 压缩类型</span><br><span class="line">差分包头[<span class="number">3</span>] : 版本代码[<span class="number">7</span>:<span class="number">6</span>]+解压数据长度所占的字节数u[<span class="number">5</span>:<span class="number">3</span>]+还原数据长度所占的字节数n[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">差分包头[<span class="number">4</span> ~ <span class="number">4</span>+n] : 还原数据长度</span><br><span class="line">差分包头[? ~ ?+u] : 解压数据长度</span><br><span class="line"></span><br><span class="line">压缩包头[? ~ ?+<span class="number">4</span>] : 压缩字典大小</span><br></pre></td></tr></table></figure><p><strong>差分还原接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分还原接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpatchi_listener_t            listener            详见 hpatchi_listener_t 分析</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                     newSize             还原数据的长度</span></span><br><span class="line"><span class="comment"> * @param hpi_byte                     *temp_cache          还原缓冲的地址</span></span><br><span class="line"><span class="comment"> * @param hpi_size_t                    temp_cache_size     还原缓冲的大小（&gt;=2）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t 实例（差分包未经压缩）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 差分数据流句柄,</span><br><span class="line">    .read_diff = 差分数据流读取函数,    由用户去实现（从外部存储的差分数据分区读取）（函数一）</span><br><span class="line"></span><br><span class="line">    .read_old  = 旧版数据流读取函数,    由用户去实现（从内部存储的旧版程序分区读取）（函数二）</span><br><span class="line">    .write_new = 还原数据流写入函数,    由用户去实现（写入到外部存储的还原程序分区）（函数三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t 实例（差分包经过压缩）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tuz_TStream _tuz_stream = <span class="comment">/* 压缩数据流句柄 */</span></span><br><span class="line">&#123;</span><br><span class="line">    .in_Stream = 差分数据流句柄,</span><br><span class="line">    .read_code = 差分数据流读取函数,    由用户去实现（从外部存储的差分数据分区读取）（函数一）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 压缩数据流句柄,        _tuz_stream</span><br><span class="line">    .read_diff = 压缩数据流解压函数,    _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line"></span><br><span class="line">    .read_old  = 旧版数据流读取函数,    由用户去实现（从内部存储的旧版程序分区读取）（函数二）</span><br><span class="line">    .write_new = 还原数据流写入函数,    由用户去实现（写入到外部存储的还原程序分区）（函数三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后需要特别注意的一点是：差分包必须由 create_lite_diff() 函数创建。宏观上来说就是差分包必须要通过 hdiffi.exe 程序生成，不能使用 hdiffz.exe 生成。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpi_BOOL 差分数据流读取函数()</span><br><span class="line">&#123;</span><br><span class="line">    由用户实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 旧版数据流读取函数()</span><br><span class="line">&#123;</span><br><span class="line">    由用户实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 还原数据流写入函数()</span><br><span class="line">&#123;</span><br><span class="line">    由用户实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 hpatch_lite_open() + hpatch_lite_patch() 编写的还原程序</span></span><br><span class="line"><span class="type">hpi_patch_result_t</span> <span class="title function_">hpi_patch</span><span class="params">(接收到的差分包大小, “还原缓冲大小”, “解压缓冲大小”)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 差分数据流句柄：如果不需要该句柄的话可以将其定义为空指针</span></span><br><span class="line">    hpatch_lite_open(“差分数据流句柄”, “差分数据流读取函数”, 输出“差分包信息”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    解压缓冲地址 = <span class="built_in">malloc</span>();</span><br><span class="line">    解压字典大小 = _tuz_TStream_getReservedMemSize(“差分数据流句柄”, “差分数据流读取函数”);</span><br><span class="line">    tuz_TStream_open(_tuz_stream, “差分数据流句柄”, “差分数据流读取函数”, “解压缓冲地址”, “解压字典大小”, “解压缓冲大小”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    patch_listener</span><br><span class="line">        .diff_data = _tuz_stream</span><br><span class="line">        .read_diff = _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line">        .read_old  = 旧版数据流读取函数()</span><br><span class="line">        .write_new = 还原数据流写入函数()</span><br><span class="line"></span><br><span class="line">    还原缓冲地址 = <span class="built_in">malloc</span>();</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(“patch_listener”, “还原数据期望长度”, “还原缓冲地址”, “还原缓冲大小”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><figcaption><span>hpatch_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __hpatch_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __hpatch_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span>; <span class="comment">// (差分文件的大小, 差分缓冲大小, 解压缓冲大小)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __hpatch_port_h__ */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>hpatch_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_lite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decompresser_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部flash中以数据流的形式读取差分数据（由用户记录数据流的位置：读到哪儿了）（数据流结束时需要将 *data_size 置为当前所读数据的实际长度）（*data_size == decompress_cache_size）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_diff(hpi_TInputStreamHandle input_stream, hpi_byte *data, <span class="type">hpi_size_t</span> *data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="keyword">if</span> ((patch_file_rxd_pos + *data_size) &gt; patch_file_len)</span><br><span class="line">    &#123;</span><br><span class="line">        *data_size = patch_file_len - patch_file_rxd_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, offset+patch_file_rxd_pos, data, *data_size);</span><br><span class="line">    patch_file_rxd_pos += *data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内部flash中以数据流的形式读取旧版程序</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_old(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">hpi_pos_t</span> read_pos, hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_older&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, read_pos, data, data_size);</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将还原数据以数据流的形式写入外部flash中（由用户记录数据流的位置：写到哪儿了）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_write_new(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">const</span> hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, newer_file_txd_pos, data, data_size);</span><br><span class="line">    newer_file_txd_pos += data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* pmem = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* patch_cache;</span><br><span class="line"></span><br><span class="line">    patch_file_len = diff_file_size;</span><br><span class="line">    patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line">    newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hpi_TInputStreamHandle  void_stream_handle = <span class="literal">NULL</span>;</span><br><span class="line">    hpi_TInputStream_read   diff_stream_read = _do_read_diff;</span><br><span class="line">    hpi_compressType        compress_type;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               new_size;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               uncompress_size;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_open(void_stream_handle, diff_stream_read, &amp;compress_type, &amp;new_size, &amp;uncompress_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">hpatchi_listener_t</span> listener;</span><br><span class="line">    listener.read_old  = _do_read_old;</span><br><span class="line">    listener.write_new = _do_write_new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (compress_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_no:  <span class="comment">// memory size: patch_cache_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(patch_cache_size);</span><br><span class="line">            patch_cache = pmem;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = void_stream_handle;</span><br><span class="line">            listener.read_diff = diff_stream_read;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _CompressPlugin_tuz</span></span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_tuz:  <span class="comment">// requirements memory size: patch_cache_size + decompress_cache_size + decompress_dict_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            tuz_TStream tuz_stream_handle;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> decompress_dict_size  = _tuz_TStream_getReservedMemSize(void_stream_handle, diff_stream_read);</span><br><span class="line"></span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(decompress_dict_size + decompress_cache_size + patch_cache_size);</span><br><span class="line"></span><br><span class="line">            tuz_TStream_open(&amp;tuz_stream_handle, void_stream_handle, diff_stream_read, pmem, (<span class="type">tuz_size_t</span>)decompress_dict_size, (<span class="type">tuz_size_t</span>)decompress_cache_size);</span><br><span class="line"></span><br><span class="line">            patch_cache = pmem + decompress_dict_size + decompress_cache_size;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = &amp;tuz_stream_handle;</span><br><span class="line">            listener.read_diff = _tuz_TStream_decompress;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> clear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(&amp;listener, new_size, patch_cache, (<span class="type">hpi_size_t</span>)patch_cache_size);</span><br><span class="line"></span><br><span class="line">clear:</span><br><span class="line">    <span class="keyword">if</span> (pmem) &#123; hpi_free(pmem); pmem=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>为了使代码看起来更加简洁，因此例程中没有进行任何异常处理。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近发现了一个优秀的差分还原算法：hdiff &amp;amp; hpatch，它通过数据流的思想把 O(n) 的空间复杂度转嫁给了硬盘，使得内存的开销极低，非常适合应用于嵌入式领域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff.tools.compare.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
    <category term="差分还原算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B7%AE%E5%88%86%E8%BF%98%E5%8E%9F%E7%AE%97%E6%B3%95/"/>
    
    <category term="增量升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%A2%9E%E9%87%8F%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#05）增量升级</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html</id>
    <published>2023-09-30T16:00:05.000Z</published>
    <updated>2023-09-30T16:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>全量升级由于要传输新版程序的完整镜像，因此升级时间通常较长，升级失败的概率也更大。那么能不能只传送差异数据呢？答案是可以。这种技术被称作增量升级&#x2F;差量升级&#x2F;差分升级。</p><p>常见的方案有：</p><ul><li>bsdiff&#x2F;bspatch + quicklz</li><li>hdifflite&#x2F;hpatchlite + tinyuz</li></ul><div class="note info no-icon"><p>不过 bsdiff + quicklz 方案的内存开销太大，因此不建议使用。</p></div><h2 id="全量升级-amp-增量升级"><a href="#全量升级-amp-增量升级" class="headerlink" title="全量升级 &amp; 增量升级"></a>全量升级 &amp; 增量升级</h2><p>增量升级确实降低了传输过程中的数据量，但也带来了版本管理复杂的问题，所以说不能因为有了增量升级，全量升级就不用了。</p><p>以往我们做全量升级的时候没有引入压缩技术，在移植 hdiff&#x2F;hpatchlite 的时候我发现，hdiff 生成的差异文件不比原文件小多少，但是其可压缩性非常高，这样就得把解压算法也移植进来。既然解压算法都已经有了，不把增量升级也压缩一下，那岂不是很浪费？</p><table><tbody><tr>    <td align="center" rowspan="2">全量升级</td>    <td align="center">未经压缩的新版程序</td>    <td align="center">（✘）</td></tr><tr>    <td align="center">经过压缩的新版程序</td>    <td align="center">（✔）</td></tr><tr>    <td align="center" rowspan="2">增量升级</td>    <td align="center">未经压缩的差异文件</td>    <td align="center">（✘）</td></tr><tr>    <td align="center">经过压缩的差异文件</td>    <td align="center">（✔）</td></tr></tbody></table><span id="more"></span><h2 id="升级包头"><a href="#升级包头" class="headerlink" title="升级包头"></a>升级包头</h2><p>在线升级无非就是把新程序或者更新补丁发送给设备，设备收到后进行升级的过程。</p><p>为了保证升级能够顺利进行，除了新程序或者更新补丁外，我们还要向设备发送一些附加信息，这些附加信息通常被添加至升级文件的头部。</p><table><tbody><tr>    <td align="center">魔术数字</td>    <td align="center">04B</td>    <td align="center">全量升级 ('Q','L','S','J')<br>增量升级 ('Z','L','S','J')</td></tr><tr>    <td align="center">包头长度</td>    <td align="center">04B</td>    <td align="center">支持变长包头 *</td></tr><tr>    <td align="center">文件摘要</td>    <td align="center">04B</td>    <td align="center">从「文件长度」之后开始计算</td></tr><tr>    <td align="center">文件长度</td>    <td align="center">04B</td>    <td align="center">从「文件长度」之后开始计算</td></tr><tr>    <td align="center">　</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">产品型号</td>    <td align="center">08B</td>    <td align="center">产品一型 ('P','N','-','A','0','0','0','1')<br>产品二型 ('P','N','-','A','0','0','0','2')</td></tr><tr>    <td align="center">设备地址</td>    <td align="center">08B</td>    <td align="center">通配地址 (0xFFFFFFFFFFFFFFFF)<br>单点地址 (0x1111111111111111)</td></tr><tr>    <td align="center">　</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">新程序 LEN 值</td>    <td align="center">04B</td>    <td align="center" rowspan="6">对旧程序进行摘要值校验<br>或者<br>对旧程序进行差分还原时<br><br>某些可变字段必须以默认值进行处理</td></tr><tr>    <td align="center">旧程序 LEN 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">新程序 CRC 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">旧程序 CRC 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">新程序 MD5 值</td>    <td align="center">16B</td></tr><tr>    <td align="center">旧程序 MD5 值</td>    <td align="center">16B</td></tr><tr>    <td align="center">......</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">可以按需增加</td>    <td align="center"></td>    <td align="center"></td></tr></tbody></table><p><strong>变长包头的优势</strong></p><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.head.scalable.png"></p><div class="note info no-icon"><p>升级包头我建议做成变长的，万一哪天包头长度不够用了，扩展后也能兼容现场的老设备。</p></div><h2 id="升级文件"><a href="#升级文件" class="headerlink" title="升级文件"></a>升级文件</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.1.raw.full.png" alt="未经压缩的全量升级文件结构"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.2.zip.full.png" alt="经过压缩的全量升级文件结构"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.4.zip.diff.png" alt="经过压缩的增量升级文件结构"></div></div></div><h2 id="升级方案"><a href="#升级方案" class="headerlink" title="升级方案"></a>升级方案</h2><h3 id="未经压缩的全量升级-经过压缩的增量升级"><a href="#未经压缩的全量升级-经过压缩的增量升级" class="headerlink" title="未经压缩的全量升级 + 经过压缩的增量升级"></a>未经压缩的全量升级 + 经过压缩的增量升级</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.1.raw.full+zip.diff.png"></p><h3 id="经过压缩的全量升级-经过压缩的增量升级"><a href="#经过压缩的全量升级-经过压缩的增量升级" class="headerlink" title="经过压缩的全量升级 + 经过压缩的增量升级"></a>经过压缩的全量升级 + 经过压缩的增量升级</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.2.zip.full+zip.diff.png"></p><h2 id="升级流程"><a href="#升级流程" class="headerlink" title="升级流程"></a>升级流程</h2><h3 id="接收升级数据"><a href="#接收升级数据" class="headerlink" title="接收升级数据"></a>接收升级数据</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%Start(接收升级数据&lt;br&gt;开始)--&gt;DoRecv[接收数据]--&gt;IsHeadRecvDone{文件头接收完毕}IsHeadRecvDone--否&#x2F;继续接收--&gt;DoRecvIsHeadRecvDone--是--&gt;IsHeadParsed{文件头已被处理}IsHeadParsed--是----&gt;DoWrite[将接收到的数据写入外存&lt;br&gt;如果为「压缩增量升级」则将数据写入〈升级数据存储区〉&lt;br&gt;如果为「压缩全量升级」则将数据写入〈升级数据存储区〉&lt;br&gt;如果为「原版全量升级」则将数据写入〈新版程序存储区〉&lt;br&gt;（如果小程序为旧版本则写入时偏移75字节）]--&gt;IsFileRecvOver{文件传输完毕}IsFileRecvOver--否&#x2F;继续接收--&gt;DoRecv2[继续接收数据]IsFileRecvOver--是--&gt;DoCheck[校验接收到的升级文件&lt;br&gt;如果为「压缩增量升级」则从〈升级数据存储区〉中读出数据并计算CRC值&lt;br&gt;如果为「压缩全量升级」则从〈升级数据存储区〉中读出数据并计算CRC值&lt;br&gt;如果为「原版全量升级」则从〈新版程序存储区〉中读出数据并计算CRC值&lt;br&gt;（如果小程序为旧版本则读取时偏移75字节）]--&gt;IsCheckOK{校验是否通过}IsCheckOK--否--&gt;Over3(结束)IsCheckOK--是--&gt;DoWriteHead[将文件头中的某些数据写入外存的第一个扇区&lt;br&gt;（如果小程序为旧版本则将“新程序大小”加75字节）]--&gt;DoWriteHeadFlag[将该扇区中的升级标识从0xFFFFFFFF改成0xAABBFFFF]--&gt;IsA{增量升级}IsA--是--&gt;DoSetA[发起增量升级任务]--&gt;Over4(结束)IsA--否--&gt;IsB{有压缩的&lt;br&gt;全量升级}IsB--是--&gt;DoSetB[发起全量升级任务]--&gt;Over4(结束)IsB--否--&gt;IsC{无压缩的&lt;br&gt;全量升级}IsC--是--&gt;DoSetC[发起全量升级任务]--&gt;Over4(结束)IsC--否--&gt;Over5(结束)IsHeadParsed--否--&gt;IsHeadOK{文件头格式正确}IsHeadOK--否--&gt;Over1(结束)IsHeadOK--是--&gt;IsDiffUpdate{是否为增量升级}IsDiffUpdate--否&#x2F;继续接收--&gt;DoRecvIsDiffUpdate--是--&gt;IsCRCOK{文件头中的旧程序CRC与&lt;br&gt;当前程序的CRC是否一致}IsCRCOK--（当前程序中的可变字段以默认值进行处理）&lt;br&gt;&lt;br&gt;不一致--&gt;Over2(结束)IsCRCOK--是&#x2F;继续接收--&gt;DoRecv</pre><h3 id="执行升级任务"><a href="#执行升级任务" class="headerlink" title="执行升级任务"></a>执行升级任务</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%Start(执行升级任务&lt;br&gt;开始)--&gt;IsUpdateFlag{升级文件接收完毕}IsUpdateFlag--否--&gt;IsUpdateFlagIsUpdateFlag--是--&gt;DoReadHead[从外存的第一个扇区中读取升级信息]--&gt;IsReadSucc{读取成功}IsReadSucc--否--&gt;Over1(结束)IsReadSucc--是--&gt;IsUpdateFlagIsDownload{升级标识&#x3D;&#x3D;0xAABBFFFF}IsUpdateFlagIsDownload--否--&gt;Over2(结束)IsUpdateFlagIsDownload--是--&gt;IsUpdateTypeIsZipDiff{是否为压缩增量升级}IsUpdateTypeIsZipDiff--是--&gt;DoUnDiff[执行差分还原操作]--如果小程序为旧版本&lt;br&gt;则写入时偏移75字节&lt;br&gt;当前程序中的可变字段以默认值进行处理---&gt;DoCheckNewAppCRCIsUpdateTypeIsZipDiff--否--&gt;IsUpdateTypeIsZipFull{是否为压缩全量升级}IsUpdateTypeIsZipFull--是--&gt;DoUnZip[执行文件解压操作]--如果小程序为旧版本&lt;br&gt;则写入时偏移75字节---&gt;DoCheckNewAppCRCIsUpdateTypeIsZipFull--否--&gt;IsUpdateTypeIsRawFull{是否为原版全量升级}IsUpdateTypeIsRawFull--是--&gt;DoNothing[无需执行任何操作]---&gt;DoCheckNewAppCRC[校验新程序&lt;br&gt;对比文件头中的新程序CRC与&lt;br&gt;新程序存储区中的数据的CRC]IsUpdateTypeIsRawFull--否--&gt;Over3(结束)DoCheckNewAppCRC--如果小程序为旧版本&lt;br&gt;则读取时偏移75字节---&gt;IsCRCCheckOK{CRC是否一致}IsCRCCheckOK--否--&gt;Over4(结束)IsCRCCheckOK--是--&gt;DoChangeUpdateFlag[将外存中的升级标识从0xAABBFFFF改为0xAABBCCDD]--&gt;IsChangeSucc{修改是否成功}IsChangeSucc--否--&gt;Over5(结束)IsChangeSucc--是--&gt;DoChangeInternalFlashUpdateFlag[将内部flash中的0xAABBCCDD改成0x0000CCDD]--&gt;DoReset[一秒后重启进入引导程序]--&gt;OverX(结束)</pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全量升级由于要传输新版程序的完整镜像，因此升级时间通常较长，升级失败的概率也更大。那么能不能只传送差异数据呢？答案是可以。这种技术被称作增量升级&amp;#x2F;差量升级&amp;#x2F;差分升级。&lt;/p&gt;
&lt;p&gt;常见的方案有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bsdiff&amp;#x2F;bspatch + quicklz&lt;/li&gt;
&lt;li&gt;hdifflite&amp;#x2F;hpatchlite + tinyuz&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;不过 bsdiff + quicklz 方案的内存开销太大，因此不建议使用。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;全量升级-amp-增量升级&quot;&gt;&lt;a href=&quot;#全量升级-amp-增量升级&quot; class=&quot;headerlink&quot; title=&quot;全量升级 &amp;amp; 增量升级&quot;&gt;&lt;/a&gt;全量升级 &amp;amp; 增量升级&lt;/h2&gt;&lt;p&gt;增量升级确实降低了传输过程中的数据量，但也带来了版本管理复杂的问题，所以说不能因为有了增量升级，全量升级就不用了。&lt;/p&gt;
&lt;p&gt;以往我们做全量升级的时候没有引入压缩技术，在移植 hdiff&amp;#x2F;hpatchlite 的时候我发现，hdiff 生成的差异文件不比原文件小多少，但是其可压缩性非常高，这样就得把解压算法也移植进来。既然解压算法都已经有了，不把增量升级也压缩一下，那岂不是很浪费？&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot; rowspan=&quot;2&quot;&gt;全量升级&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;未经压缩的新版程序&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot;&gt;经过压缩的新版程序&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✔）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot; rowspan=&quot;2&quot;&gt;增量升级&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;未经压缩的差异文件&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot;&gt;经过压缩的差异文件&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✔）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#04）技术细节</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html</id>
    <published>2023-09-30T16:00:04.000Z</published>
    <updated>2023-09-30T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>分散加载、中断向量表重定向</p><h2 id="调整大小程序时要修改哪些配置？"><a href="#调整大小程序时要修改哪些配置？" class="headerlink" title="调整大小程序时要修改哪些配置？"></a>调整大小程序时要修改哪些配置？</h2><p>➀ 修改 main.sct 分散加载文件。</p><p>➁ 修改 ConfigMCU 中大小程序的起始地址及空间大小。</p><p>➂ 修改 iap: system_mcumodel.c 中 VECT_TAB_OFFSET 的值（等于小程序的起始地址）。</p><p>➃ 修改 app: system_mcumodel.c 中 VECT_TAB_OFFSET 的值（等于大程序的起始地址）。</p><h2 id="分散加载"><a href="#分散加载" class="headerlink" title="分散加载"></a>分散加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- module_select_pattern</span><br><span class="line">  - *</span><br><span class="line">  - *.o</span><br><span class="line">  - .ANY</span><br><span class="line"></span><br><span class="line">- module_select_pattern (input_section_selector)</span><br><span class="line">- module_select_pattern (input_section_selector, input_section_selector, ...)</span><br><span class="line">  - +input_section_attr</span><br><span class="line">    - * (+RO-CODE)</span><br><span class="line">    - * (+RO-DATA)</span><br><span class="line">    - * (+RO)</span><br><span class="line">    - * (+RW-DATA)</span><br><span class="line">    - * (+RW-CODE)</span><br><span class="line">    - * (+RW)</span><br><span class="line">    - * (+XO)</span><br><span class="line">    - * (+ZI)</span><br><span class="line">    - * (+ENTRY)</span><br><span class="line">    -</span><br><span class="line">    - * (+CODE)</span><br><span class="line">    - * (+CONST)</span><br><span class="line">    - * (+TEXT)</span><br><span class="line">    - * (+DATA)</span><br><span class="line">    - * (+BSS)</span><br><span class="line">    -</span><br><span class="line">    - * (+FIRST)</span><br><span class="line">    - * (+LAST)</span><br><span class="line">  - input_section_pattern</span><br><span class="line">    - * (*app_info)</span><br><span class="line">  - input_symbol_pattern</span><br><span class="line">  - section_properties</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#03）流程设计</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html</id>
    <published>2023-09-30T16:00:03.000Z</published>
    <updated>2023-09-30T16:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A1(引导程序之流程)--&gt;B1(......)--&gt;C1(跳转至应用程序)A2(应用程序之流程)--&gt;B2(......)--&gt;C2(跳转至引导程序)</pre><span id="more"></span><h2 id="引导程序流程"><a href="#引导程序流程" class="headerlink" title="引导程序流程"></a>引导程序流程</h2><p>引导程序的设计方案我知道有两种：</p><ul><li>立即跳转方案</li><li>延时跳转方案</li></ul><p>立即跳转方案在判断出应用程序有效之后会立即执行跳转操作，该方案适用于对启动时间要求比较高的产品。延时跳转方案则是先在引导程序中等待一段时间，在这段时间内如果没有任何请求则时间到了之后会自动跳转至应用程序，否则将停留在引导程序中。</p><h3 id="立即跳转方案"><a href="#立即跳转方案" class="headerlink" title="立即跳转方案"></a>立即跳转方案</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%PowerReset(设备上电复位)--&gt;IapStart(引导程序开始)--&gt;IapCheckApp[检查应用程序有效标识]--&gt;IapIsAppValid{是否有效}IapIsAppValid--是--&gt;IapJumpToApp[跳转进入应用程序]--&gt;IapOver(引导程序结束)IapIsAppValid--否--&gt;IapRemap[重定向中断向量表]--&gt;IapInit[配置相关外设]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升级数据}IapIsHaveUpdateData--否--&gt;IapBeforeJumpIapIsHaveUpdateData--是--&gt;IapDoUpdate[执行升级操作]---&gt;IapEraseUpdateData[擦除升级数据]--&gt;IapIsUpdateSucc{升级成功}IapIsUpdateSucc--是---&gt;IapSetAppValid[修改应用程序有效标识：有效]--&gt;IapBeforeJump[关闭外设和中断]--&gt;IapJumpToAppIapIsUpdateSucc--否--&gt;IapIsAppErased{应用程序已损毁}IapIsAppErased--否--&gt;IapBeforeJumpIapIsAppErased--是&lt;br&gt;留在引导程序中--&gt;IapComm[执行通信任务]--&gt;IapIsRecvDone{收到升级数据}IapIsRecvDone--否--&gt;IapCommIapIsRecvDone--是--&gt;IapDoUpdate</pre><h3 id="延时跳转方案"><a href="#延时跳转方案" class="headerlink" title="延时跳转方案"></a>延时跳转方案</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%PowerReset(设备上电复位)--&gt;IapStart(引导程序开始)--&gt;IapCheckApp[检查应用程序有效标识]--&gt;IapIsAppValid{是否有效}IapIsAppValid--是--&gt;IapWait{计数超时&lt;br&gt;（延时跳转）}IapWait--否--&gt;IapWaitIapWait--是----------&gt;IapJumpToApp[跳转进入应用程序]--&gt;IapOver(引导程序结束)IapIsAppValid--否--&gt;IapRemap[重定向中断向量表]--&gt;IapInit[配置相关外设]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升级数据}IapIsHaveUpdateData--否--&gt;IapBeforeJumpIapIsHaveUpdateData--是--&gt;IapDoUpdate[执行升级操作]---&gt;IapEraseUpdateData[擦除升级数据]--&gt;IapIsUpdateSucc{升级成功}IapIsUpdateSucc--是---&gt;IapSetAppValid[修改应用程序有效标识：有效]--&gt;IapBeforeJump[关闭外设和中断]--&gt;IapJumpToAppIapIsUpdateSucc--否--&gt;IapIsAppErased{应用程序已损毁}IapIsAppErased--否--&gt;IapBeforeJumpIapIsAppErased--是&lt;br&gt;留在引导程序中--&gt;IapComm[执行通信任务]--&gt;IapIsRecvDone{收到升级数据}IapIsRecvDone--否--&gt;IapCommIapIsRecvDone--是--&gt;IapDoUpdate</pre><h2 id="应用程序流程"><a href="#应用程序流程" class="headerlink" title="应用程序流程"></a>应用程序流程</h2><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%AppStart(应用程序开始)--&gt;AppRemap[重定向中断向量表]--&gt;AppInit[配置相关外设]--&gt;AppTask[执行应用功能]--&gt;AppComm[执行通信任务]--&gt;AppIsRecvDone{收到升级数据}AppIsRecvDone--否--&gt;AppTaskAppIsRecvDone--是--&gt;AppSetAppInvalid[修改应用程序有效标识：无效]--&gt;AppBeforeJump[关闭外设和中断]--&gt;AppJumpToIap[重启进入引导程序｜跳转进入引导程序]--&gt;AppOver(应用程序结束)</pre>]]></content>
    
    
    <summary type="html">&lt;pre class=&quot;mermaid&quot;&gt;
flowchart TB
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A1(引导程序之流程)--&amp;gt;B1(......)--&amp;gt;C1(跳转至应用程序)
A2(应用程序之流程)--&amp;gt;B2(......)--&amp;gt;C2(跳转至引导程序)
&lt;/pre&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#02）升级方案</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html</id>
    <published>2023-09-30T16:00:02.000Z</published>
    <updated>2023-09-30T16:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<center>which one is better?</center><br><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(在引导程序中集成通信协议栈与解压还原算法)~~~B(在应用程序中集成通信协议栈与解压还原算法)</pre><span id="more"></span><h2 id="思路（-1）：引导程序主导"><a href="#思路（-1）：引导程序主导" class="headerlink" title="思路（#1）：引导程序主导"></a>思路（#1）：引导程序主导</h2><table><thead><tr><th align="center">具体分工</th><th align="center">引导程序</th><th align="center">应用程序</th></tr></thead><tbody><tr><td align="center">编程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信协议</td><td align="center">完备的通信协议栈</td><td align="center">　　　　　　　　</td></tr><tr><td align="center">文件解压</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">差分还原</td><td align="center">✔</td><td align="center"></td></tr></tbody></table><div class="note success no-icon"><p><strong>优点</strong>：设备中没有应用程序或应用程序异常时也可以进行 IAP 升级。</p></div><div class="note danger no-icon"><p><strong>缺点</strong>：在引导程序中集成通信协议栈、文件解压、差分还原等功能，会导致其代码量较大。</p></div><h2 id="思路（-2）：应用程序主导"><a href="#思路（-2）：应用程序主导" class="headerlink" title="思路（#2）：应用程序主导"></a>思路（#2）：应用程序主导</h2><table><thead><tr><th align="center">具体分工</th><th align="center">引导程序</th><th align="center">应用程序</th></tr></thead><tbody><tr><td align="center">编程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信协议</td><td align="center">　　　　　　　　</td><td align="center">完备的通信协议栈</td></tr><tr><td align="center">文件解压</td><td align="center"></td><td align="center">✔</td></tr><tr><td align="center">差分还原</td><td align="center"></td><td align="center">✔</td></tr></tbody></table><div class="note success no-icon"><p><strong>优点</strong>：引导程序比较简单，占用空间小，方便维护。</p></div><div class="note danger no-icon"><p><strong>缺点</strong>：设备中没有应用程序或应用程序异常时无法进行 IAP 升级。</p></div><h2 id="思路（-3）：两者各取所长"><a href="#思路（-3）：两者各取所长" class="headerlink" title="思路（#3）：两者各取所长"></a>思路（#3）：两者各取所长</h2><table><thead><tr><th align="center">具体分工</th><th align="center">引导程序</th><th align="center">应用程序</th></tr></thead><tbody><tr><td align="center">编程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信协议</td><td align="center">基础的通信协议栈</td><td align="center">完备的通信协议栈</td></tr><tr><td align="center">文件解压</td><td align="center"></td><td align="center">✔</td></tr><tr><td align="center">差分还原</td><td align="center"></td><td align="center">✔</td></tr></tbody></table><div class="note success no-icon"><p><strong>特点</strong>：在引导程序中集成基础的通信协议栈，代码量能接受，应用程序异常时也能在线升级。</p></div><div class="note success no-icon"><p><strong>特点</strong>：在应用程序中集成完整的通信协议栈、文件解压、差分还原等功能，功能完备。</p></div><h2 id="方案（-0）"><a href="#方案（-0）" class="headerlink" title="方案（#0）"></a>方案（#0）</h2><table><thead><tr><th align="center">内部flash存储空间划分</th><th align="center">内部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>    <td align="center">中断向量表</td></tr><tr>    <td align="center">引导程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center">参数数据存储区</td>    <td align="center">掉电不丢失的系统参数</td></tr></tbody></table><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除应用程序存储区，然后等待接收新版应用程序（直接写入到升级文件存储区），等接收完毕且校验无误后跳转至应用程序，至此升级完成。</p><h2 id="方案（-1）"><a href="#方案（-1）" class="headerlink" title="方案（#1）"></a>方案（#1）</h2><table><thead><tr><th align="center">内部flash存储空间划分</th><th align="center">内部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>    <td align="center">中断向量表</td></tr><tr>    <td align="center">引导程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center" rowspan="2">升级数据存储区</td>    <td align="center">解压后的新版程序</td></tr><tr>    <td align="center">接收到的压缩文件</td></tr><tr>    <td align="center">参数数据存储区</td>    <td align="center">掉电不丢失的系统参数</td></tr></tbody></table><p>或</p><table><thead><tr><th align="center">内部flash存储空间划分</th><th align="center">内部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>    <td align="center">中断向量表</td></tr><tr>    <td align="center">引导程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center">参数数据存储区</td>    <td align="center">掉电不丢失的系统参数</td></tr></tbody><thead><tr><th align="center">外部flash存储空间划分</th><th align="center">外部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">升级数据存储区</td>    <td align="center">解压后的新版程序</td></tr><tr>    <td align="center">接收到的压缩文件</td></tr></tbody></table><h3 id="思路（-1）"><a href="#思路（-1）" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除旧版应用程序，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至应用程序存储区，最后跳转至应用程序，至此升级完成。</p><h3 id="思路（-2）"><a href="#思路（-2）" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至新版程序存储区，重启进入或跳转进入引导程序。进入引导程序后对新版程序进行二次校验，校验通过后擦除旧版应用程序，然后将新版程序存储区中的新版应用程序拷贝至应用程序存储区，最后跳转至应用程序，至此升级完成。</p><h3 id="思路（-3）"><a href="#思路（-3）" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至新版程序存储区，重启进入或跳转进入引导程序。进入引导程序后对新版程序进行二次校验，校验通过后擦除旧版应用程序，然后将新版程序存储区中的新版应用程序拷贝至应用程序存储区，最后跳转至应用程序，至此升级完成。</p><p>抹除应用程序有效标识后，重启进入或跳转进入引导程序。进入引导程序后等待通信，若收到升级指令，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除旧版应用程序，然后将升级文件存储区中的新版应用程序拷贝（不支持解压和差分还原）至应用程序存储区，最后跳转至应用程序，至此升级完成。</p><h2 id="方案（-2）"><a href="#方案（-2）" class="headerlink" title="方案（#2）"></a>方案（#2）</h2><table><thead><tr><th align="center">内部flash存储空间划分</th><th align="center">内部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>    <td align="center">中断向量表</td></tr><tr>    <td align="center">引导程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区<br>（1）</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区<br>（2）</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center">参数数据存储区</td>    <td align="center">掉电不丢失的系统参数</td></tr></tbody></table><h3 id="思路（-1）-1"><a href="#思路（-1）-1" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p><h3 id="思路（-2）-1"><a href="#思路（-2）-1" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>设备收到升级指令后，首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p><h3 id="思路（-3）-1"><a href="#思路（-3）-1" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>设备收到升级指令后，首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p><p>抹除应用程序有效标识后，重启进入或跳转进入引导程序。进入引导程序后等待通信，若收到升级指令，首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p><h2 id="方案（-3）"><a href="#方案（-3）" class="headerlink" title="方案（#3）"></a>方案（#3）</h2><table><thead><tr><th align="center">内部flash存储空间划分</th><th align="center">内部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>    <td align="center">中断向量表</td></tr><tr>    <td align="center">引导程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区<br>（1）</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区<br>（2）</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center" rowspan="2">升级数据存储区</td>    <td align="center">解压后的新版程序</td></tr><tr>    <td align="center">接收到的压缩文件</td></tr><tr>    <td align="center">参数数据存储区</td>    <td align="center">掉电不丢失的系统参数</td></tr></tbody></table><p>或</p><table><thead><tr><th align="center">内部flash存储空间划分</th><th align="center">内部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>    <td align="center">中断向量表</td></tr><tr>    <td align="center">引导程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区<br>（1）</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center" rowspan="2">应用程序存储区<br>（2）</td>    <td align="center">重定向的中断向量表</td></tr><tr>    <td align="center">应用程序</td></tr><tr>    <td align="center">参数数据存储区</td>    <td align="center">掉电不丢失的系统参数</td></tr></tbody><thead><tr><th align="center">外部flash存储空间划分</th><th align="center">外部flash存储空间细分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">升级数据存储区</td>    <td align="center">解压后的新版程序</td></tr><tr>    <td align="center">接收到的压缩文件</td></tr></tbody></table><h3 id="思路（-1）-2"><a href="#思路（-1）-2" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至备份应用存储区，最后翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p><h3 id="思路（-2）-2"><a href="#思路（-2）-2" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至备份应用存储区，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p><h3 id="思路（-3）-2"><a href="#思路（-3）-2" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至备份应用存储区，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p><p>抹除应用程序有效标识后，重启进入或跳转进入引导程序。进入引导程序后等待通信，若收到升级指令，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝（不支持解压和差分还原）至备份应用存储区，最后翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p>]]></content>
    
    
    <summary type="html">&lt;center&gt;which one is better?&lt;/center&gt;
&lt;br&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(在引导程序中集成通信协议栈与解压还原算法)~~~B(在应用程序中集成通信协议栈与解压还原算法)
&lt;/pre&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#01）基础概念</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html</id>
    <published>2023-09-30T16:00:01.000Z</published>
    <updated>2023-09-30T16:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<center>传统编程方式</center><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(先取下芯片)---&gt;B(再烧录程序)---&gt;C(后装回板卡)</pre><center>现代编程方式</center><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(&quot;在电路编程&lt;br&gt;(ＩＣＰ)&quot;)---&gt;B(&quot;在系统编程&lt;br&gt;(ＩＳＰ)&quot;)---&gt;C(&quot;在应用编程&lt;br&gt;(ＩＡＰ)&quot;)</pre><span id="more"></span><h2 id="传统编程方式"><a href="#传统编程方式" class="headerlink" title="传统编程方式"></a>传统编程方式</h2><p>传统编程方式是先将程序烧录至主控芯片中再焊接到电路板上。</p><p><strong>开发阶段</strong></p><ul><li>➀ 从电路板上取下芯片</li><li>➁ 使用烧录器烧写程序</li><li>➂ 将芯片装回至电路板</li></ul><p><strong>量产阶段</strong></p><ul><li>➀ 从 tray 盘取出芯片</li><li>➁ 使用烧录器烧写程序</li><li>➂ 将芯片放回 tray 盘</li></ul><p><strong>维护阶段</strong></p><ul><li>➀ 从电路板上拆下芯片</li><li>➁ 使用烧录器烧写程序</li><li>➂ 将芯片焊回至电路板</li></ul><h2 id="现代编程方式"><a href="#现代编程方式" class="headerlink" title="现代编程方式"></a>现代编程方式</h2><p>现代编程方式可以直接进行板上烧录，不用再取下芯片放到专用的烧录器上烧录，极大地提高了开发、生产以及维护效率。</p><p>现代编程方式又可分为：</p><ul><li>在电路编程 ICP (Circuit)</li><li>在系统编程 ISP (System)</li><li>在应用编程 IAP (Application)</li></ul><table><thead><tr><th align="center">编程方式</th><th align="center">在电路编程</th><th align="center">在系统编程</th><th align="center">在应用编程</th></tr></thead><tbody><tr><td align="center">核心思想</td><td align="center">借助外部烧录器<br>通过JTAG&#x2F;SWD接口<br>实现在电路编程</td><td align="center">借助芯片内部<br>固化的引导程序和BOOT引脚<br>以及片上接口<br>实现在系统编程</td><td align="center">借助用户自己<br>编写的引导程序、应用程序<br>以及片上接口、板上接口<br>实现在应用编程</td></tr><tr><td align="center">引导程序</td><td align="center">不需要</td><td align="center">需要芯片厂家编写<br>并固化到某一地址空间</td><td align="center">需要用户自己编写<br>并烧录至内部flash存储器</td></tr><tr><td align="center">进入方式</td><td align="center">随时待命</td><td align="center">需要更改BOOT引脚的电平<br>然后硬件复位<br>进入内部固化的引导程序</td><td align="center">随时待命</td></tr><tr><td align="center">配套软件</td><td align="center">烧录软件</td><td align="center">芯片厂家提供的<br>上位机ISP编程软件</td><td align="center">用户自己开发的数据传输软件</td></tr><tr><td align="center">通信接口</td><td align="center">JTAG&#x2F;SWD</td><td align="center">取决于芯片中固化的引导程序<br>URT&#x2F;SPI&#x2F;IIC&#x2F;CAN&#x2F;USB</td><td align="center">理论上可以支持任意接口<br>URT&#x2F;SPI&#x2F;IIC<br>485&#x2F;CAN&#x2F;USB<br>WiFi&#x2F;BLE&#x2F;IrDA<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td></tr><tr><td align="center">程序升级<br>是否需要<br>拆装芯片</td><td align="center">不需要<br>拆装芯片</td><td align="center">不需要<br>拆装芯片</td><td align="center">不需要<br>拆装芯片</td></tr><tr><td align="center">程序升级<br>是否需要<br>拆装外壳</td><td align="center">需要<br>拆开设备外壳</td><td align="center">通信接口完备的情况下<br>不需要<br>拆开设备外壳<br>485&#x2F;CAN&#x2F;USB</td><td align="center">通信接口完备的情况下<br>不需要<br>拆开设备外壳<br>485&#x2F;CAN&#x2F;USB&#x2F;WiFi&#x2F;BLE&#x2F;IrDA</td></tr><tr><td align="center">程序升级<br>是否需要<br>前往现场</td><td align="center">需要<br>前往设备安装现场</td><td align="center">需要<br>前往设备安装现场</td><td align="center">远程通信功能完备的情况下<br>不需要<br>前往设备安装现场<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td></tr></tbody></table><div class="note info no-icon"><p>ICP 主要是在开发阶段使用，其烧录速度是 ISP 和 IAP 所无法比拟的。</p></div><div class="note info no-icon"><p>IAP 与 ISP 类似，都有 bootloader 引导程序，因此无需使用烧录器。二者的区别在于，ISP 的引导程序由芯片厂家编写，比较简单，无法实现用户的定制化需求；而 IAP 的引导程序是由用户自己实现，可以根据需求自行修改。另外 ISP 进入 boot 程序的方式是通过更改 BOOT 引脚的电平；而 IAP 则是从用户程序中通过软件复位或者跳转的方式直接进入 bootloader 程序，因此相较于 ISP 来说会更加灵活。</p></div><div class="note info no-icon"><p>通过 WiFi&#x2F;BLE&#x2F;4G&#x2F;5G&#x2F;NBIoT 等无线通信技术实现 IAP 功能的方案也被称作 OTA 空中下载技术。</p></div><table><thead><tr><th align="center">BOOT1</th><th align="center">BOOT0</th><th align="center">BOOT MODE</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">0</td><td align="center">boot from 0x08000000 : main memory</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">boot from 0x1FFF0000 : boot memory</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">boot from 0x20000000 : sram memory</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;center&gt;传统编程方式&lt;/center&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(先取下芯片)---&amp;gt;B(再烧录程序)---&amp;gt;C(后装回板卡)
&lt;/pre&gt;

&lt;center&gt;现代编程方式&lt;/center&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(&amp;quot;在电路编程&amp;lt;br&amp;gt;(ＩＣＰ)&amp;quot;)---&amp;gt;B(&amp;quot;在系统编程&amp;lt;br&amp;gt;(ＩＳＰ)&amp;quot;)---&amp;gt;C(&amp;quot;在应用编程&amp;lt;br&amp;gt;(ＩＡＰ)&amp;quot;)
&lt;/pre&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="在线升级" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升级功能（#00）目录索引</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2023-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html">嵌入式 IAP 升级功能（#01）基础概念</a><br><a href="/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html">嵌入式 IAP 升级功能（#02）升级方案</a><br><a href="/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html">嵌入式 IAP 升级功能（#03）流程设计</a><br><a href="/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html">嵌入式 IAP 升级功能（#04）技术细节</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升级功能（#05）增量升级</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升级功能（#06）差分还原 hpatchlite 移植</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升级功能（#07）压缩解压 tinyuztool 移植</a><br><a href="/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html">嵌入式 IAP 升级功能（#08）引导程序 bootloader 升级</a></p><hr><span id="more"></span><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://itexp.blog.csdn.net/article/details/83793309">https://itexp.blog.csdn.net/article/details/83793309</a></p><p><a href="https://blog.csdn.net/qq_24130227/article/details/123752964">https://blog.csdn.net/qq_24130227/article/details/123752964</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108379324">https://blog.csdn.net/qq_24130227/article/details/108379324</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/113003329">https://blog.csdn.net/qq_24130227/article/details/113003329</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/120061873">https://blog.csdn.net/qq_24130227/article/details/120061873</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108427842">https://blog.csdn.net/qq_24130227/article/details/108427842</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html&quot;&gt;嵌入式 IAP 升级功能（#01）基础概念&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html&quot;&gt;嵌入式 IAP 升级功能（#02）升级方案&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html&quot;&gt;嵌入式 IAP 升级功能（#03）流程设计&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html&quot;&gt;嵌入式 IAP 升级功能（#04）技术细节&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升级功能（#05）增量升级&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升级功能（#06）差分还原 hpatchlite 移植&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升级功能（#07）压缩解压 tinyuztool 移植&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html&quot;&gt;嵌入式 IAP 升级功能（#08）引导程序 bootloader 升级&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="开发笔记" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式软件开发" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="单片机" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="iap" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/iap/"/>
    
    <category term="bootloader" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>问题记录：华大 HC32F460 滤波电路失效</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss.html</id>
    <published>2023-08-08T16:00:00.000Z</published>
    <updated>2023-08-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用电压比较器时发现硬件滤波电路会出现失效的情况，经分析是其采样频率过高所致。</p><p><img src="/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss/manual.png"></p><p>参考手册中绘制的是理想条件下的波形，真实情况并非如此，INP 在逼近 INM 时会伴随着噪声&#x2F;抖动。我们可以使用硬件滤波电路来消除这种抖动，图中绿色线段表示各采样点，其频率即为采样频率。</p><iframe src="https://www.desmos.com/calculator/7r0bi5urxv?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe><p>采样频率较低时，滤波电路可以正常工作，但是随着采样频率的升高，其可靠性反而会降低。</p><span id="more"></span><iframe src="https://www.desmos.com/calculator/2kz1rewo6h?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe><iframe src="https://www.desmos.com/calculator/2py3qizn5x?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用电压比较器时发现硬件滤波电路会出现失效的情况，经分析是其采样频率过高所致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss/manual.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;参考手册中绘制的是理想条件下的波形，真实情况并非如此，INP 在逼近 INM 时会伴随着噪声&amp;#x2F;抖动。我们可以使用硬件滤波电路来消除这种抖动，图中绿色线段表示各采样点，其频率即为采样频率。&lt;/p&gt;
&lt;iframe src=&quot;https://www.desmos.com/calculator/7r0bi5urxv?embed&quot; width=&quot;800&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc&quot; frameborder=0&gt;&lt;/iframe&gt;

&lt;p&gt;采样频率较低时，滤波电路可以正常工作，但是随着采样频率的升高，其可靠性反而会降低。&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="华大半导体" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%8D%8E%E5%A4%A7%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>问题记录：华大 HC32F460 切换运行模式导致宕机</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4.html</id>
    <published>2023-07-26T16:00:00.000Z</published>
    <updated>2023-07-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><ul><li>从高速&#x2F;超高速模式向超低速模式切换时 mcu 异常死机</li></ul><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><ul><li>当前使用华大 2.2.0 版驱动程序</li><li>当前使用华大 1.2.1 版参考手册</li></ul><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>通过调试发现每次运行至 <code>M4_SYSREG-&gt;PWR_PWRC2</code> 赋值时程序就会跑飞😶</p><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2-Register.png" alt="电源模式控制寄存器 2"></p><figure class="highlight c"><figcaption><span>hc32f460_pwc.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">en_result_t</span> <span class="title function_">PWC_HS2LS</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    M4_SYSREG-&gt;PWR_PWRC2 = <span class="number">0xE1</span>U;</span><br><span class="line">    M4_SYSREG-&gt;PWR_MDSWCR = <span class="number">0x10</span>U;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">en_result_t</span> <span class="title function_">PWC_HP2LS</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    M4_SYSREG-&gt;PWR_PWRC2 = <span class="number">0xD1</span>U;</span><br><span class="line">    M4_SYSREG-&gt;PWR_MDSWCR = <span class="number">0x10</span>U;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞅了一眼《参考手册 Rev1.2.1》好像也没啥问题，又看了《参考手册 Rev1.3》后，我得发…🙄！</p><p>两版手册竟然不一样！</p><span id="more"></span><h3 id="Rev1-2-1"><a href="#Rev1-2-1" class="headerlink" title="Rev1.2.1"></a>Rev1.2.1</h3><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2.png" alt="运行模式的切换流程（Rev1.2）"></p><h3 id="Rev1-3-0"><a href="#Rev1-3-0" class="headerlink" title="Rev1.3.0"></a>Rev1.3.0</h3><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.3.png" alt="运行模式的切换流程（Rev1.3）"></p><p>这妥妥的是华大的锅了…</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象描述&quot;&gt;&lt;a href=&quot;#现象描述&quot; class=&quot;headerlink&quot; title=&quot;现象描述&quot;&gt;&lt;/a&gt;现象描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从高速&amp;#x2F;超高速模式向超低速模式切换时 mcu 异常死机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础信息&quot;&gt;&lt;a href=&quot;#基础信息&quot; class=&quot;headerlink&quot; title=&quot;基础信息&quot;&gt;&lt;/a&gt;基础信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当前使用华大 2.2.0 版驱动程序&lt;/li&gt;
&lt;li&gt;当前使用华大 1.2.1 版参考手册&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h2&gt;&lt;p&gt;通过调试发现每次运行至 &lt;code&gt;M4_SYSREG-&amp;gt;PWR_PWRC2&lt;/code&gt; 赋值时程序就会跑飞😶&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2-Register.png&quot; alt=&quot;电源模式控制寄存器 2&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;hc32f460_pwc.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;en_result_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;PWC_HS2LS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_PWRC2 = &lt;span class=&quot;number&quot;&gt;0xE1&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_MDSWCR = &lt;span class=&quot;number&quot;&gt;0x10&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;en_result_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;PWC_HP2LS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_PWRC2 = &lt;span class=&quot;number&quot;&gt;0xD1&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_MDSWCR = &lt;span class=&quot;number&quot;&gt;0x10&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;瞅了一眼《参考手册 Rev1.2.1》好像也没啥问题，又看了《参考手册 Rev1.3》后，我得发…🙄！&lt;/p&gt;
&lt;p&gt;两版手册竟然不一样！&lt;/p&gt;</summary>
    
    
    
    <category term="问题记录" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="华大半导体" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%8D%8E%E5%A4%A7%E5%8D%8A%E5%AF%BC%E4%BD%93/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
</feed>
