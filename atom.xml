<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ㄅㄆㄇㄈ</title>
  <icon>https://sulfurandcu.github.io/sulfurandcu.io/icon.png</icon>
  <subtitle>bopomofo</subtitle>
  <link href="https://sulfurandcu.github.io/sulfurandcu.io/atom.xml" rel="self"/>
  
  <link href="https://sulfurandcu.github.io/sulfurandcu.io/"/>
  <updated>2023-11-09T01:14:29.000Z</updated>
  <id>https://sulfurandcu.github.io/sulfurandcu.io/</id>
  
  <author>
    <name>刘汲桐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>問題記錄：華大 HC32F460 內存邊界禁止非對齊訪問</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1.html</id>
    <published>2023-11-09T01:14:29.000Z</published>
    <updated>2023-11-09T01:14:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="現象描述"><a href="#現象描述" class="headerlink" title="現象描述"></a>現象描述</h2><ul><li>程序無法正常啓動</li><li>有時會進入 hard fault 中斷</li><li>有時候會出現以下異常：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Call Stack + Locals                                                                    ✘</span><br><span class="line">    Name                                Location/Value                          Type</span><br><span class="line">    __scatterload_zeroinit              0x00074C56                              function</span><br><span class="line">    __scatterload                       0x00018DFE                              function</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基礎信息"><a href="#基礎信息" class="headerlink" title="基礎信息"></a>基礎信息</h2><h3 id="芯片資源"><a href="#芯片資源" class="headerlink" title="芯片資源"></a>芯片資源</h3><ul><li>RAM 192KB&#x2F;0x30000</li><li>ROM 512KB&#x2F;0x80000（其中通過分散加載給應用程序分配的空間爲 416KB&#x2F;0x68000）</li></ul><h3 id="鏈接數據"><a href="#鏈接數據" class="headerlink" title="鏈接數據"></a>鏈接數據</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">    Total RO  Size (Code + RO Data)               419844 ( 410.00kB)</span><br><span class="line">    Total RW  Size (RW Data + ZI Data)            163952 ( 160.11kB)</span><br><span class="line">    Total ROM Size (Code + RO Data + RW Data)     421056 ( 411.19kB)</span><br><span class="line"></span><br><span class="line">==============================================================================</span><br></pre></td></tr></table></figure><h3 id="分散加載"><a href="#分散加載" class="headerlink" title="分散加載"></a>分散加載</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line"></span><br><span class="line">; 中斷向量</span><br><span class="line">ER_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序信息</span><br><span class="line">ER_IROM2 + 0 &#123;</span><br><span class="line">*.o (SECTION_INFO_APP, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序代碼</span><br><span class="line">ER_IROM3 + 0 &#123;</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 內存空間</span><br><span class="line">RW_IRAM1 0x1FFF8000 0x00030000 &#123;</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>由於代碼量比較臨界，起初我以爲是 flash 的問題。但是 map 文件中顯示 ROM 只佔用了 411.19kB 的空間，並沒有超過 416KB 的總量。那 RAM 呢？RAM 只用了 160.11KB 也沒有超過 192KB 的總量，邪了門兒了真是！哎，等等！這款芯片的 RAM 我記得好像是分成了兩塊，怎麼說的來着，瞅一眼《參考手冊》：</p><p><img src="/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1/HC32F460_manual.png"></p><p>果然，兩塊 RAM 間不支持非對齊訪問，再一看 SRAMH 的大小：32KB！破案了！現在 RAM 的用量不正好到達 160KB（192KB - 32KB &#x3D; 160KB）這個臨界點了麼！</p><p>按照現有分散加載文件的寫法，兩塊內存會被認爲是一個整體，那麼就必然存在「在內存邊界處進行非對齊訪問」的可能。而且這種非法訪問最早會發生在 scatterload 階段，進而導致程序無法啓動。</p><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>既然是分散加載文件的鍋，那就得拿它開刀了：<strong>將兩塊內存断开</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line"></span><br><span class="line">; 中斷向量</span><br><span class="line">ER_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序信息</span><br><span class="line">ER_IROM2 + 0 &#123;</span><br><span class="line">*.o (SECTION_INFO_APP, +First)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 程序代碼</span><br><span class="line">ER_IROM3 + 0 &#123;</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 內存空間</span><br><span class="line">RW_IRAM1 0x1FFF8000 0x00007FF0 &#123; ; 空出一塊內存不用，以避免在 scatterload 階段發生非對齊訪問。</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; 內存空間</span><br><span class="line">RW_IRAM2 0x20000000 0x00028000 &#123;</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;現象描述&quot;&gt;&lt;a href=&quot;#現象描述&quot; class=&quot;headerlink&quot; title=&quot;現象描述&quot;&gt;&lt;/a&gt;現象描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序無法正常啓動&lt;/li&gt;
&lt;li&gt;有時會進入 hard fault 中斷&lt;/li&gt;
&lt;li&gt;有時候會出現以下異常：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Call Stack + Locals                                                                    ✘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Name                                Location/Value                          Type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __scatterload_zeroinit              0x00074C56                              function&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __scatterload                       0x00018DFE                              function&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="問題記錄" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%95%8F%E9%A1%8C%E8%A8%98%E9%8C%84/"/>
    
    
    <category term="華大半導體" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E8%8F%AF%E5%A4%A7%E5%8D%8A%E5%B0%8E%E9%AB%94/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>我的生產力工具</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html</id>
    <published>2023-10-15T02:54:20.000Z</published>
    <updated>2023-10-15T02:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<center>一些提高工作效率的工具</center><span id="more"></span><h2 id="機械鍵盤"><a href="#機械鍵盤" class="headerlink" title="機械鍵盤"></a>機械鍵盤</h2><ul><li>使用 tmk, qmk 等工具燒錄自定義固件</li></ul><h2 id="鍵位佈局"><a href="#鍵位佈局" class="headerlink" title="鍵位佈局"></a>鍵位佈局</h2><ul><li><a href="/sulfurandcu.io/clnor6mvz0015ocrq2jks39ew.html">dƷvorak</a></li></ul><h2 id="輸入法兒"><a href="#輸入法兒" class="headerlink" title="輸入法兒"></a>輸入法兒</h2><ul><li>昨夏雙拼</li><li>小鶴雙拼</li><li>朙月拼音</li><li>宮保拼音</li></ul><h2 id="輸入引擎"><a href="#輸入引擎" class="headerlink" title="輸入引擎"></a>輸入引擎</h2><ul><li>中州韻輸入法引擎（rime, weasel, squirrel）</li></ul><h2 id="顯示字體"><a href="#顯示字體" class="headerlink" title="顯示字體"></a>顯示字體</h2><ul><li>思源宋體</li><li>思源黑體</li><li>更紗黑體</li><li>等寬字體（iosevka）</li><li>可變字體（Amstelvar）</li></ul><h2 id="日程計劃"><a href="#日程計劃" class="headerlink" title="日程計劃"></a>日程計劃</h2><ul><li>microsoft.todo</li></ul><h2 id="系統優化"><a href="#系統優化" class="headerlink" title="系統優化"></a>系統優化</h2><ul><li>powertoys</li><li>ContextMenuManager</li><li>RightMenuMgr</li><li>WinXEditor</li><li>StartAllBack</li><li>W11ClassicMenu</li><li>Fliqlo</li><li>zadig</li><li>UsbDriverTool</li><li>SmartSystemMenu</li></ul><h2 id="科學上網"><a href="#科學上網" class="headerlink" title="科學上網"></a>科學上網</h2><ul><li>clash.for.windows (<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a>)</li><li>xtls.space (<a href="https://xtlspace.20181024.xyz/#/register?code=bUox1yaB">https://xtlspace.20181024.xyz/#/register?code=bUox1yaB</a>)</li><li>tor.browser (<a href="https://www.torproject.org/download/">https://www.torproject.org/download/</a>)</li><li>tor.zlibrary (<a href="http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/">http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/</a>)</li></ul><h2 id="文件下載"><a href="#文件下載" class="headerlink" title="文件下載"></a>文件下載</h2><ul><li>Aria2</li><li>ndm</li><li>qbittorrent</li></ul><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul><li>localsend</li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li>qdir</li><li>everything</li></ul><h2 id="虛擬環境"><a href="#虛擬環境" class="headerlink" title="虛擬環境"></a>虛擬環境</h2><ul><li>windows.terminal</li><li>wsl</li><li>vmware</li><li>docker</li><li>cygwin (posix.api&#x2F;cygwin1.dll, bin&#x3D;windows.pe)</li></ul><h2 id="遠程終端"><a href="#遠程終端" class="headerlink" title="遠程終端"></a>遠程終端</h2><ul><li>windterm</li></ul><h2 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h2><ul><li>mingw&#x2F;msys1 (shell) (posix.api&#x2F;msys-1.0.dll) (msys1~cmd.exe, mingw&#x2F;msys1~cygwin)</li><li>mingw&#x2F;msys2 (shell) (posix.api&#x2F;msys-2.0.dll) (msys2~cmd.exe, mingw&#x2F;msys2~cygwin)</li><li>cmake.for.windows</li><li>ninja.for.windows</li><li>mingw.for.windows   (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>mingw32 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>mingw64 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>unxutils</li><li>llvm</li><li>python.sdk</li><li>java.sdk</li><li>go.sdk</li><li>node.js</li></ul><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><ul><li>svn</li><li>git</li></ul><h2 id="文件對比"><a href="#文件對比" class="headerlink" title="文件對比"></a>文件對比</h2><ul><li>winmerge</li></ul><h2 id="文本編輯"><a href="#文本編輯" class="headerlink" title="文本編輯"></a>文本編輯</h2><ul><li>wxMEdit</li></ul><h2 id="軟件開發"><a href="#軟件開發" class="headerlink" title="軟件開發"></a>軟件開發</h2><ul><li>vscode</li><li>vs</li><li>eclipse</li><li>android.studio</li><li>x64dbg</li></ul><h2 id="軟件開發（嵌入式）"><a href="#軟件開發（嵌入式）" class="headerlink" title="軟件開發（嵌入式）"></a>軟件開發（嵌入式）</h2><ul><li>gcc-arm-none-eabi</li><li>openocd</li><li>jlink</li><li>jlink debugger</li><li>keil</li><li>embeetle</li><li>rt-thread.studio</li></ul><h2 id="硬件開發"><a href="#硬件開發" class="headerlink" title="硬件開發"></a>硬件開發</h2><ul><li>KiCAD</li><li>AD</li><li>CadenceSPB</li></ul><h2 id="機械工業"><a href="#機械工業" class="headerlink" title="機械工業"></a>機械工業</h2><ul><li>AutoCAD</li><li>FreeCAD</li><li>Revit</li><li>Rhino</li><li>3dsMax</li><li>SketchUp</li><li>Render.Vray</li><li>Render.D5</li><li>Render.Enscape</li></ul><h2 id="圖片文檔"><a href="#圖片文檔" class="headerlink" title="圖片文檔"></a>圖片文檔</h2><ul><li>截屏工具<ul><li>fscapture</li><li>sharex</li></ul></li><li>圖片查看<ul><li>honeyview</li></ul></li><li>圖片編輯<ul><li>GIMP</li><li>inkscape</li><li>shift.n</li><li>ascii.generator</li></ul></li><li>文檔查看<ul><li>PDF.24</li></ul></li><li>文檔編輯<ul><li>PDF.XChange.Editor</li><li>draw.io</li><li>wave.drom.editor</li></ul></li></ul><h2 id="視頻音頻"><a href="#視頻音頻" class="headerlink" title="視頻音頻"></a>視頻音頻</h2><ul><li>錄屏工具<ul><li>obs.studio</li><li>lonelyscreen (ios screen display)</li></ul></li><li>視頻播放<ul><li>MPC-HC</li><li>VLC</li><li>PotPlayer</li></ul></li><li>視頻剪輯<ul><li>shotcut</li><li>losslesscut</li></ul></li><li>視頻轉碼<ul><li>handbrake</li></ul></li><li>音頻播放<ul><li>foobar2000</li></ul></li><li>音頻剪輯<ul><li>audacity</li><li>wavosaur</li></ul></li><li>音頻轉碼<ul><li>略.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;一些提高工作效率的工具&lt;/center&gt;</summary>
    
    
    
    <category term="效率提升" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
    
    <category term="生產工具" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E7%94%9F%E7%94%A2%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html</id>
    <published>2023-09-30T16:00:08.000Z</published>
    <updated>2023-09-30T16:00:08.000Z</updated>
    
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuz 移植</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html</id>
    <published>2023-09-30T16:00:07.000Z</published>
    <updated>2023-09-30T16:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>與上文類似，對 tinyuz 也進行二次封裝以便上層調用：</p><figure class="highlight c"><figcaption><span>tinyuz_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __tinyuz_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __tinyuz_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUZ_DECOMPRESS_SPACE_SIZE       512*1024            <span class="comment">// 外部存儲中〈差分文件區〉的空間大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TTinyuzResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TINYUZ_SUCCESS=<span class="number">0</span>,</span><br><span class="line">    TINYUZ_OPTIONS_ERROR,</span><br><span class="line">    TINYUZ_OPENREAD_ERROR,</span><br><span class="line">    TINYUZ_OPENWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILEREAD_ERROR,</span><br><span class="line">    TINYUZ_FILEWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILECLOSE_ERROR,</span><br><span class="line">    TINYUZ_MEM_ERROR,</span><br><span class="line">    TINYUZ_COMPRESS_ERROR,</span><br><span class="line">    TINYUZ_DECOMPRESS_ERROR,</span><br><span class="line">&#125; TTinyuzResult;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __tinyuz_port_h__ */</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight c"><figcaption><span>tinyuz_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tinyuz_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuz_dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TTuzListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> hpatch_TStreamInput*  input_file_stream_handle;</span><br><span class="line">    hpatch_StreamPos_t          readPos;</span><br><span class="line">    tuz_TInputStream_read       _do_read_encompress_file;</span><br><span class="line">&#125;TTuzListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從外部flash中以數據流的形式讀取壓縮數據</span></span><br><span class="line">hpatch_BOOL _do_read_encompress_file(<span class="type">const</span> hpatch_TStreamInput* stream, hpatch_StreamPos_t readFromPos, <span class="type">unsigned</span> <span class="type">char</span>* out_data, <span class="type">unsigned</span> <span class="type">char</span>* out_data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> readLen = (<span class="type">size_t</span>)(out_data_end - out_data);</span><br><span class="line">    <span class="keyword">if</span> (readLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> compressed_stream_size = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((readLen &gt; compressed_stream_size) || (readFromPos &gt; compressed_stream_size - readLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, readFromPos, out_data, readLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將解壓數據以數據流的形式寫入外部flash中</span></span><br><span class="line">hpatch_BOOL _do_write_decompress_file(<span class="type">const</span> hpatch_TStreamOutput* stream, hpatch_StreamPos_t writeToPos, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> writeLen = (<span class="type">size_t</span>)(data_end - data);</span><br><span class="line">    <span class="keyword">if</span> (writeLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> write_max_space = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((writeLen &gt; write_max_space)||(writeToPos &gt; write_max_space - writeLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, offset+writeToPos, data, writeLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> tuz_BOOL <span class="title function_">input_file_stream_read_function</span><span class="params">(<span class="type">void</span> *listener, tuz_byte *decompressed_file_stream, <span class="type">tuz_size_t</span> *code_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    TTuzListener *self = (TTuzListener*)listener;</span><br><span class="line">    <span class="type">tuz_size_t</span> r_len = *code_size;</span><br><span class="line">    hpatch_StreamPos_t curReadPos = self-&gt;readPos;</span><br><span class="line">    hpatch_StreamPos_t s_size = self-&gt;input_file_stream_handle-&gt;streamSize - curReadPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_len &gt; s_size)&#123;</span><br><span class="line">        r_len = (<span class="type">tuz_size_t</span>)s_size;</span><br><span class="line">        *code_size = r_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;readPos += r_len;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;input_file_stream_handle-&gt;read(self-&gt;input_file_stream_handle, curReadPos, decompressed_file_stream, decompressed_file_stream + r_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    hpatch_TStreamOutput decompressed_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;decompressed_file_stream_handle,</span><br><span class="line">        .streamSize = TUZ_DECOMPRESS_SPACE_SIZE, <span class="comment">// 外部存儲中〈差分文件區〉的空間大小</span></span><br><span class="line">        .write = _do_write_decompress_file, <span class="comment">// stream write</span></span><br><span class="line">        .read_writed = <span class="literal">NULL</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hpatch_TStreamInput input_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;input_file_stream_handle,</span><br><span class="line">        .streamSize = compressed_file_size, <span class="comment">// 壓縮文件的實際大小</span></span><br><span class="line">        .read = _do_read_encompress_file, <span class="comment">// stream read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TTuzListener listener = &#123;&amp;input_file_stream_handle, <span class="number">0</span>, input_file_stream_read_function&#125;;</span><br><span class="line">    tuz_TStream tuz;</span><br><span class="line">    tuz_TResult result = tuz_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 壓縮的時候會以指定的字典大小進行壓縮｜因此解壓的時候要從壓縮包頭中讀取字典大小</span></span><br><span class="line">    <span class="type">tuz_size_t</span> dictSize = tuz_TStream_read_dict_size(&amp;listener, listener._do_read_encompress_file);</span><br><span class="line"></span><br><span class="line">    tuz_byte* decompress_buf = <span class="number">0</span>;</span><br><span class="line">    cache_size &gt;&gt;= <span class="number">1</span>; <span class="comment">// 除二操作</span></span><br><span class="line">    decompress_buf = (tuz_byte*)tuz_malloc(dictSize + cache_size*<span class="number">2</span>); <span class="comment">// 解壓過程中要用到的臨時空間大小 = 字典大小 + 解壓緩衝區大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decompress_buf == <span class="number">0</span>) <span class="keyword">return</span> TINYUZ_MEM_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tuz_TStream_open 僅僅是用來初始化 tuz 這個勾柄的（tuz後面的參數都是給tuz賦值用的）</span></span><br><span class="line">    result = tuz_TStream_open(&amp;tuz, &amp;listener, listener._do_read_encompress_file, decompress_buf + cache_size, (<span class="type">tuz_size_t</span>)dictSize, (<span class="type">tuz_size_t</span>)cache_size);</span><br><span class="line"></span><br><span class="line">    hpatch_StreamPos_t stream_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (result == tuz_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">tuz_size_t</span> decompress_len = (<span class="type">tuz_size_t</span>)cache_size; <span class="comment">// 給decompress_len賦一個初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解壓一包數據到 decompress_buf 中｜並得到該包長度 decompress_len</span></span><br><span class="line">        result = tuz_TStream_decompress_partial(&amp;tuz, decompress_buf, &amp;decompress_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt;= tuz_STREAM_END)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 將當前解壓的 decompress_buf 中的數據寫到 decompressed_file_stream_handle 數據流中</span></span><br><span class="line">            <span class="keyword">if</span> (decompressed_file_stream_handle.write(&amp;decompressed_file_stream_handle, stream_index, decompress_buf, decompress_buf + decompress_len))</span><br><span class="line">            &#123;</span><br><span class="line">                stream_index += decompress_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tuz_free(decompress_buf);</span><br><span class="line">                <span class="keyword">return</span> TINYUZ_OPENWRITE_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tuz_free(decompress_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;與上文類似，對 tinyuz 也進行二次封裝以便上層調用：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;tinyuz_port.h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifndef&lt;/span&gt; __tinyuz_port_h__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; __tinyuz_port_h__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stddef.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;malloc.h&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; TUZ_DECOMPRESS_SPACE_SIZE       512*1024            &lt;span class=&quot;comment&quot;&gt;// 外部存儲中〈差分文件區〉的空間大小&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; tuz_malloc(x)                   mymalloc(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; tuz_free(x)                     myfree(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TTinyuzResult&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_SUCCESS=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPTIONS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPENREAD_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPENWRITE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILEREAD_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILEWRITE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILECLOSE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_MEM_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_COMPRESS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_DECOMPRESS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; TTinyuzResult;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;tuz_decompress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; compressed_file_size, &lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; cache_size)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* __tinyuz_port_h__ */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="壓縮解壓算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%A3%93%E7%B8%AE%E8%A7%A3%E5%A3%93%E7%AE%97%E6%B3%95/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html</id>
    <published>2023-09-30T16:00:06.000Z</published>
    <updated>2023-09-30T16:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近發現了一個優秀的差分還原算法：hdiff &amp; hpatch，它通過數據流的思想把 O(n) 的空間複雜度轉嫁給了硬盤，使得內存的開銷極低，非常適合應用於嵌入式領域。</p><p><img src="/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff-tools-compare.png"></p><span id="more"></span><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="hpatchlite"><a href="#hpatchlite" class="headerlink" title="hpatchlite"></a>hpatchlite</h3><p>時間複雜度：O(oldSize+newSize)<br>空間複雜度：O(1)<br>　　還原代碼開銷｜ROM &#x3D; 876 字節 (compiled by armcc v5.06 update4 build 422)<br>　　還原內存開銷｜RAM &#x3D; 還原緩衝大小 + 解壓內存開銷</p><p>注：還原緩衝大小在還原時指定，至少3個字節，還原緩衝越小還原得越慢。</p><h3 id="tinyuz"><a href="#tinyuz" class="headerlink" title="tinyuz"></a>tinyuz</h3><p>時間複雜度：O(oldSize+newSize)<br>空間複雜度：O(1)<br>　　解壓代碼開銷｜流模式｜ROM &#x3D; 1142 字節 (compiled by armcc v5.06 update4 build 422)<br>　　解壓內存開銷｜流模式｜RAM &#x3D; 壓縮字典大小 + 解壓緩衝大小</p><p>注：壓縮字典大小在壓縮時指定，至少1個字節，壓縮字典越小壓縮率越低。<br>注：解壓緩衝大小在解壓時指定，至少2個字節，解壓緩衝越小解壓縮越慢。</p><h3 id="appendix"><a href="#appendix" class="headerlink" title="appendix"></a>appendix</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 876          0          0          0          0      10783   hpatch_lite.o</span><br><span class="line">1142          0          0          0          0      13541   tuz_dec.o</span><br><span class="line"></span><br><span class="line"> 626         80          0         12          0      12256   hpatch_user.o</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">244           0          0          0          0       2146   bspatch.o</span><br><span class="line">586           6         64          0          0       6749   quicklz.o</span><br><span class="line"></span><br><span class="line">102           4          8          0          0       2821   bspatch_user.o</span><br><span class="line"> 52           0          0          0          0       2096   quicklz_user.o</span><br></pre></td></tr></table></figure><h2 id="移植說明"><a href="#移植說明" class="headerlink" title="移植說明"></a>移植說明</h2><p>將 hdiffpatch.hpatchlite &amp; tinyuz 移植至單片機 bare metal 裸機系統（based on hdiffpatch v4）</p><h3 id="拿來"><a href="#拿來" class="headerlink" title="拿來"></a>拿來</h3><p>將 tinyuz&#x2F;decompress 目錄拷貝至目標工程中。</p><p>將 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatch 目錄拷貝至目標工程中。</p><p>將 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatchLite 目錄拷貝至目標工程中。</p><p>將 HPatchLite&#x2F;decompresser_demo.h 文件拷貝至目標工程中。</p><h3 id="畫瓢"><a href="#畫瓢" class="headerlink" title="畫瓢"></a>畫瓢</h3><p>依 HPatchLite&#x2F;hpatchi.c&#x2F;hpatchi() 函數畫瓢：移植還原功能</p><p>依 tinyuz&#x2F;tinyuz_demo.cpp&#x2F;_tuz_decompress_stream() 函數畫瓢：移植解壓功能</p><p>done!</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿來依葫蘆畫瓢，說得簡單，做起來着實還是費了點功夫，這幾年搞嵌入式搞得有些侷限了，面對句(gōu)柄這種用法竟感覺無從下手。😅</p><p>作者提供了以下兩個接口函數：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpatch_lite_open()</span><br><span class="line"></span><br><span class="line">hpatch_lite_patch()</span><br></pre></td></tr></table></figure><p>看着挺簡單的吧，然而他實際上是這樣的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hpatch_lite by stream: hpatch_lite_open()+hpatch_lite_patch() compiled by Mbed Studio is 662 bytes</span></span><br><span class="line"><span class="comment">//   hdiffpatch v4.2.3, other patcher compiled by Mbed Studio:</span></span><br><span class="line"><span class="comment">//      patch_single_stream() 2356 bytes (hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"><span class="comment">//      patch_decompress_with_cache() 2846 bytes (_IS_NEED_CACHE_OLD_BY_COVERS=0,hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//diff_data must created by create_lite_diff()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span>&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    <span class="comment">//must read data_size data to out_data, from read_from_pos of stream; if read error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    <span class="comment">//must write data_size data to sequence stream; if write error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hpatch_lite open</span></span><br><span class="line"><span class="comment">// read lite headinfo from diff_data</span></span><br><span class="line"><span class="comment">// if diff_data uncompress(*out_compress_type==hpi_compressType_no), *out_uncompressSize==0;</span></span><br><span class="line"><span class="comment">// if (*out_compress_type!=hpi_compressType_no), you need open compressed data by decompresser</span></span><br><span class="line"><span class="comment">//      (see https://github.com/sisong/HPatchLite/decompresser_demo.h &amp; https://github.com/sisong/HPatchLite/hpatchi.c)</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,</span></span><br><span class="line"><span class="params">                          hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br><span class="line"><span class="comment">//hpatch_lite patch</span></span><br><span class="line"><span class="comment">//used temp_cache_size memory + &#123;decompress buffer*1&#125;</span></span><br><span class="line"><span class="comment">//  note: temp_cache_size&gt;=hpi_kMinCacheSize</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,</span></span><br><span class="line"><span class="params">                           hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure><p>試着分析一下：</p><p><strong>差分包頭信息讀取接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分包頭信息讀取接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStreamHandle        diff_data           注意此處入參：差分數據流句柄（個人理解：如果不需要該句柄的話可以將其定義爲空指針）</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStream_read         read_diff           注意此處入參：差分數據流讀取函數（用戶實現：以數據流的方式讀取外部存儲中差分數據分區的數據）</span></span><br><span class="line"><span class="comment"> * @param hpi_compressType             *out_compress_type   差分包頭信息：差分包壓縮類型</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_newSize         差分包頭信息：還原數據的長度</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_uncompressSize  差分包頭信息：解壓之後的長度（如果差分包未被壓縮則*out_uncompressSize輸出0）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br></pre></td></tr></table></figure><p><strong>差分包頭定義</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_kHeadSize (2+1+1) <span class="comment">//&quot;hI&quot; + hpi_compressType + (versionCode + newSize_Bytes + uncompressSize_Bytes) &#123; + newSize + uncompressSize&#125; &#123; + dictSize&#125;</span></span></span><br><span class="line">差分包頭[<span class="number">0</span>] : 魔術數字 <span class="number">68</span> <span class="string">&#x27;h&#x27;</span></span><br><span class="line">差分包頭[<span class="number">1</span>] : 魔術數字 <span class="number">49</span> <span class="string">&#x27;I&#x27;</span></span><br><span class="line">差分包頭[<span class="number">2</span>] : 壓縮類型</span><br><span class="line">差分包頭[<span class="number">3</span>] : 版本代碼[<span class="number">7</span>:<span class="number">6</span>]+解壓數據長度所佔的字節數u[<span class="number">5</span>:<span class="number">3</span>]+還原數據長度所佔的字節數n[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">差分包頭[<span class="number">4</span> ~ <span class="number">4</span>+n] : 還原數據長度</span><br><span class="line">差分包頭[? ~ ?+u] : 解壓數據長度</span><br><span class="line"></span><br><span class="line">壓縮包頭[? ~ ?+<span class="number">4</span>] : 壓縮字典大小</span><br></pre></td></tr></table></figure><p><strong>差分還原接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分還原接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpatchi_listener_t            listener            詳見 hpatchi_listener_t 分析</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                     newSize             還原數據的長度</span></span><br><span class="line"><span class="comment"> * @param hpi_byte                     *temp_cache          還原緩衝的地址</span></span><br><span class="line"><span class="comment"> * @param hpi_size_t                    temp_cache_size     還原緩衝的大小（&gt;=2）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t 實例（差分包未經壓縮）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 差分數據流句柄,</span><br><span class="line">    .read_diff = 差分數據流讀取函數,    由用戶去實現（從外部存儲的差分數據分區讀取）（函數一）</span><br><span class="line"></span><br><span class="line">    .read_old  = 舊版數據流讀取函數,    由用戶去實現（從內部存儲的舊版程序分區讀取）（函數二）</span><br><span class="line">    .write_new = 還原數據流寫入函數,    由用戶去實現（寫入到外部存儲的還原程序分區）（函數三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t 實例（差分包經過壓縮）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tuz_TStream _tuz_stream = <span class="comment">/* 壓縮數據流句柄 */</span></span><br><span class="line">&#123;</span><br><span class="line">    .in_Stream = 差分數據流句柄,</span><br><span class="line">    .read_code = 差分數據流讀取函數,    由用戶去實現（從外部存儲的差分數據分區讀取）（函數一）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 壓縮數據流句柄,        _tuz_stream</span><br><span class="line">    .read_diff = 壓縮數據流解壓函數,    _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line"></span><br><span class="line">    .read_old  = 舊版數據流讀取函數,    由用戶去實現（從內部存儲的舊版程序分區讀取）（函數二）</span><br><span class="line">    .write_new = 還原數據流寫入函數,    由用戶去實現（寫入到外部存儲的還原程序分區）（函數三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最後需要特別注意的一點是：差分包必須由 create_lite_diff() 函數創建。宏觀上來說就是差分包必須要通過 hdiffi.exe 程序生成，不能使用 hdiffz.exe 生成。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpi_BOOL 差分數據流讀取函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 舊版數據流讀取函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 還原數據流寫入函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根據 hpatch_lite_open() + hpatch_lite_patch() 編寫的還原程序</span></span><br><span class="line"><span class="type">hpi_patch_result_t</span> <span class="title function_">hpi_patch</span><span class="params">(接收到的差分包大小, “還原緩衝大小”, “解壓緩衝大小”)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 差分數據流句柄：如果不需要該句柄的話可以將其定義爲空指針</span></span><br><span class="line">    hpatch_lite_open(“差分數據流句柄”, “差分數據流讀取函數”, 輸出“差分包信息”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    解壓緩衝地址 = <span class="built_in">malloc</span>();</span><br><span class="line">    解壓字典大小 = _tuz_TStream_getReservedMemSize(“差分數據流句柄”, “差分數據流讀取函數”);</span><br><span class="line">    tuz_TStream_open(_tuz_stream, “差分數據流句柄”, “差分數據流讀取函數”, “解壓緩衝地址”, “解壓字典大小”, “解壓緩衝大小”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    patch_listener</span><br><span class="line">        .diff_data = _tuz_stream</span><br><span class="line">        .read_diff = _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line">        .read_old  = 舊版數據流讀取函數()</span><br><span class="line">        .write_new = 還原數據流寫入函數()</span><br><span class="line"></span><br><span class="line">    還原緩衝地址 = <span class="built_in">malloc</span>();</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(“patch_listener”, “還原數據期望長度”, “還原緩衝地址”, “還原緩衝大小”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源碼"><a href="#源碼" class="headerlink" title="源碼"></a>源碼</h3><figure class="highlight c"><figcaption><span>hpatch_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __hpatch_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __hpatch_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span>; <span class="comment">// (差分文件的大小, 差分緩衝大小, 解壓緩衝大小)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __hpatch_port_h__ */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>hpatch_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_lite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decompresser_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從外部flash中以數據流的形式讀取差分數據（由用戶記錄數據流的位置：讀到哪兒了）（數據流結束時需要將 *data_size 置爲當前所讀數據的實際長度）（*data_size == decompress_cache_size）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_diff(hpi_TInputStreamHandle input_stream, hpi_byte *data, <span class="type">hpi_size_t</span> *data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="keyword">if</span> ((patch_file_rxd_pos + *data_size) &gt; patch_file_len)</span><br><span class="line">    &#123;</span><br><span class="line">        *data_size = patch_file_len - patch_file_rxd_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, offset+patch_file_rxd_pos, data, *data_size);</span><br><span class="line">    patch_file_rxd_pos += *data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從內部flash中以數據流的形式讀取舊版程序</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_old(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">hpi_pos_t</span> read_pos, hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_older&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, read_pos, data, data_size);</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將還原數據以數據流的形式寫入外部flash中（由用戶記錄數據流的位置：寫到哪兒了）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_write_new(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">const</span> hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, newer_file_txd_pos, data, data_size);</span><br><span class="line">    newer_file_txd_pos += data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* pmem = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* patch_cache;</span><br><span class="line"></span><br><span class="line">    patch_file_len = diff_file_size;</span><br><span class="line">    patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line">    newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hpi_TInputStreamHandle  void_stream_handle = <span class="literal">NULL</span>;</span><br><span class="line">    hpi_TInputStream_read   diff_stream_read = _do_read_diff;</span><br><span class="line">    hpi_compressType        compress_type;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               new_size;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               uncompress_size;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_open(void_stream_handle, diff_stream_read, &amp;compress_type, &amp;new_size, &amp;uncompress_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">hpatchi_listener_t</span> listener;</span><br><span class="line">    listener.read_old  = _do_read_old;</span><br><span class="line">    listener.write_new = _do_write_new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (compress_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_no:  <span class="comment">// memory size: patch_cache_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(patch_cache_size);</span><br><span class="line">            patch_cache = pmem;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = void_stream_handle;</span><br><span class="line">            listener.read_diff = diff_stream_read;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _CompressPlugin_tuz</span></span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_tuz:  <span class="comment">// requirements memory size: patch_cache_size + decompress_cache_size + decompress_dict_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            tuz_TStream tuz_stream_handle;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> decompress_dict_size  = _tuz_TStream_getReservedMemSize(void_stream_handle, diff_stream_read);</span><br><span class="line"></span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(decompress_dict_size + decompress_cache_size + patch_cache_size);</span><br><span class="line"></span><br><span class="line">            tuz_TStream_open(&amp;tuz_stream_handle, void_stream_handle, diff_stream_read, pmem, (<span class="type">tuz_size_t</span>)decompress_dict_size, (<span class="type">tuz_size_t</span>)decompress_cache_size);</span><br><span class="line"></span><br><span class="line">            patch_cache = pmem + decompress_dict_size + decompress_cache_size;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = &amp;tuz_stream_handle;</span><br><span class="line">            listener.read_diff = _tuz_TStream_decompress;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> clear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(&amp;listener, new_size, patch_cache, (<span class="type">hpi_size_t</span>)patch_cache_size);</span><br><span class="line"></span><br><span class="line">clear:</span><br><span class="line">    <span class="keyword">if</span> (pmem) &#123; hpi_free(pmem); pmem=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>爲了使代碼看起來更加簡潔，因此例程中沒有進行任何異常處理。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近發現了一個優秀的差分還原算法：hdiff &amp;amp; hpatch，它通過數據流的思想把 O(n) 的空間複雜度轉嫁給了硬盤，使得內存的開銷極低，非常適合應用於嵌入式領域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff-tools-compare.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
    <category term="差分還原算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B7%AE%E5%88%86%E9%82%84%E5%8E%9F%E7%AE%97%E6%B3%95/"/>
    
    <category term="增量升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%A2%9E%E9%87%8F%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#05）增量升級</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html</id>
    <published>2023-09-30T16:00:05.000Z</published>
    <updated>2023-09-30T16:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>全量升級由於要傳輸新版程序的完整鏡像，因此升級時間通常較長，升級失敗的概率也更大。那麼能不能只傳送差異數據呢？答案是可以。這種技術被稱作增量升級&#x2F;差量升級&#x2F;差分升級。</p><p>常見的方案有：</p><ul><li>bsdiff&#x2F;bspatch + quicklz</li><li>hdifflite&#x2F;hpatchlite + tinyuz</li></ul><div class="note info no-icon"><p>不過 bsdiff + quicklz 方案的內存開銷太大，因此不建議使用。</p></div><h2 id="全量升級-amp-增量升級"><a href="#全量升級-amp-增量升級" class="headerlink" title="全量升級 &amp; 增量升級"></a>全量升級 &amp; 增量升級</h2><p>增量升級確實降低了傳輸過程中的數據量，但也帶來了版本管理複雜的問題，所以說不能因爲有了增量升級，全量升級就不用了。</p><p>以往我們做全量升級的時候沒有引入壓縮技術，在移植 hdiff&#x2F;hpatchlite 的時候我發現，hdiff 生成的差異文件不比原文件小多少，但是其可壓縮性非常高，這樣就得把解壓算法也移植進來。既然解壓算法都已經有了，不把增量升級也壓縮一下，那豈不是很浪費？</p><table><tbody><tr>    <td align="center" rowspan="2">全量升級</td>    <td align="center">未經壓縮的新版程序</td>    <td align="center">（✘）</td></tr><tr>    <td align="center">經過壓縮的新版程序</td>    <td align="center">（✔）</td></tr><tr>    <td align="center" rowspan="2">增量升級</td>    <td align="center">未經壓縮的差異文件</td>    <td align="center">（✘）</td></tr><tr>    <td align="center">經過壓縮的差異文件</td>    <td align="center">（✔）</td></tr></tbody></table><span id="more"></span><h2 id="升級包頭"><a href="#升級包頭" class="headerlink" title="升級包頭"></a>升級包頭</h2><p>在線升級無非就是把新程序或者更新補丁發送給設備，設備收到後進行升級的過程。</p><p>爲了保證升級能夠順利進行，除了新程序或者更新補丁外，我們還要向設備發送一些附加信息，這些附加信息通常被添加至升級文件的頭部。</p><table><tbody><tr>    <td align="center">魔術數字</td>    <td align="center">04B</td>    <td align="center">全量升級 ('Q','L','S','J')<br>增量升級 ('Z','L','S','J')</td></tr><tr>    <td align="center">包頭長度</td>    <td align="center">04B</td>    <td align="center">支持變長包頭 *</td></tr><tr>    <td align="center">文件摘要</td>    <td align="center">04B</td>    <td align="center">從「文件長度」之後開始計算</td></tr><tr>    <td align="center">文件長度</td>    <td align="center">04B</td>    <td align="center">從「文件長度」之後開始計算</td></tr><tr>    <td align="center">　</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">產品型號</td>    <td align="center">08B</td>    <td align="center">產品一型 ('P','N','-','A','0','0','0','1')<br>產品二型 ('P','N','-','A','0','0','0','2')</td></tr><tr>    <td align="center">設備地址</td>    <td align="center">08B</td>    <td align="center">通配地址 (0xFFFFFFFFFFFFFFFF)<br>單點地址 (0x1111111111111111)</td></tr><tr>    <td align="center">　</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">新程序 LEN 值</td>    <td align="center">04B</td>    <td align="center" rowspan="6">對舊程序進行摘要值校驗<br>或者<br>對舊程序進行差分還原時<br><br>某些可變字段必須以默認值進行處理</td></tr><tr>    <td align="center">舊程序 LEN 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">新程序 CRC 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">舊程序 CRC 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">新程序 MD5 值</td>    <td align="center">16B</td></tr><tr>    <td align="center">舊程序 MD5 值</td>    <td align="center">16B</td></tr><tr>    <td align="center">......</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">可以按需增加</td>    <td align="center"></td>    <td align="center"></td></tr></tbody></table><p><strong>變長包頭的優勢</strong></p><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.head.scalable.png"></p><div class="note info no-icon"><p>升級包頭我建議做成變長的，萬一哪天包頭長度不夠用了，擴展後也能兼容現場的老設備。</p></div><h2 id="升級文件"><a href="#升級文件" class="headerlink" title="升級文件"></a>升級文件</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.1.raw.full.png" alt="未經壓縮的全量升級文件結構"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.2.zip.full.png" alt="經過壓縮的全量升級文件結構"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.4.zip.diff.png" alt="經過壓縮的增量升級文件結構"></div></div></div><h2 id="升級方案"><a href="#升級方案" class="headerlink" title="升級方案"></a>升級方案</h2><h3 id="未經壓縮的全量升級-經過壓縮的增量升級"><a href="#未經壓縮的全量升級-經過壓縮的增量升級" class="headerlink" title="未經壓縮的全量升級 + 經過壓縮的增量升級"></a>未經壓縮的全量升級 + 經過壓縮的增量升級</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.1.raw.full+zip.diff.png"></p><h3 id="經過壓縮的全量升級-經過壓縮的增量升級"><a href="#經過壓縮的全量升級-經過壓縮的增量升級" class="headerlink" title="經過壓縮的全量升級 + 經過壓縮的增量升級"></a>經過壓縮的全量升級 + 經過壓縮的增量升級</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.2.zip.full+zip.diff.png"></p><h2 id="升級流程"><a href="#升級流程" class="headerlink" title="升級流程"></a>升級流程</h2><h3 id="接收升級數據"><a href="#接收升級數據" class="headerlink" title="接收升級數據"></a>接收升級數據</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%Start(接收升級數據&lt;br&gt;開始)--&gt;DoRecv[接收數據]--&gt;IsHeadRecvDone{文件頭接收完畢}IsHeadRecvDone--否&#x2F;繼續接收--&gt;DoRecvIsHeadRecvDone--是--&gt;IsHeadParsed{文件頭已被處理}IsHeadParsed--是----&gt;DoWrite[將接收到的數據寫入外存&lt;br&gt;如果爲「壓縮增量升級」則將數據寫入〈升級數據存儲區〉&lt;br&gt;如果爲「壓縮全量升級」則將數據寫入〈升級數據存儲區〉&lt;br&gt;如果爲「原版全量升級」則將數據寫入〈新版程序存儲區〉&lt;br&gt;（如果小程序爲舊版本則寫入時偏移75字節）]--&gt;IsFileRecvOver{文件傳輸完畢}IsFileRecvOver--否&#x2F;繼續接收--&gt;DoRecv2[繼續接收數據]IsFileRecvOver--是--&gt;DoCheck[校驗接收到的升級文件&lt;br&gt;如果爲「壓縮增量升級」則從〈升級數據存儲區〉中讀出數據並計算CRC值&lt;br&gt;如果爲「壓縮全量升級」則從〈升級數據存儲區〉中讀出數據並計算CRC值&lt;br&gt;如果爲「原版全量升級」則從〈新版程序存儲區〉中讀出數據並計算CRC值&lt;br&gt;（如果小程序爲舊版本則讀取時偏移75字節）]--&gt;IsCheckOK{校驗是否通過}IsCheckOK--否--&gt;Over3(結束)IsCheckOK--是--&gt;DoWriteHead[將文件頭中的某些數據寫入外存的第一個扇區&lt;br&gt;（如果小程序爲舊版本則將“新程序大小”加75字節）]--&gt;DoWriteHeadFlag[將該扇區中的升級標識從0xFFFFFFFF改成0xAABBFFFF]--&gt;IsA{增量升級}IsA--是--&gt;DoSetA[發起增量升級任務]--&gt;Over4(結束)IsA--否--&gt;IsB{有壓縮的&lt;br&gt;全量升級}IsB--是--&gt;DoSetB[發起全量升級任務]--&gt;Over4(結束)IsB--否--&gt;IsC{無壓縮的&lt;br&gt;全量升級}IsC--是--&gt;DoSetC[發起全量升級任務]--&gt;Over4(結束)IsC--否--&gt;Over5(結束)IsHeadParsed--否--&gt;IsHeadOK{文件頭格式正確}IsHeadOK--否--&gt;Over1(結束)IsHeadOK--是--&gt;IsDiffUpdate{是否爲增量升級}IsDiffUpdate--否&#x2F;繼續接收--&gt;DoRecvIsDiffUpdate--是--&gt;IsCRCOK{文件頭中的舊程序CRC與&lt;br&gt;當前程序的CRC是否一致}IsCRCOK--（當前程序中的可變字段以默認值進行處理）&lt;br&gt;&lt;br&gt;不一致--&gt;Over2(結束)IsCRCOK--是&#x2F;繼續接收--&gt;DoRecv</pre><h3 id="執行升級任務"><a href="#執行升級任務" class="headerlink" title="執行升級任務"></a>執行升級任務</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%Start(執行升級任務&lt;br&gt;開始)--&gt;IsUpdateFlag{升級文件接收完畢}IsUpdateFlag--否--&gt;IsUpdateFlagIsUpdateFlag--是--&gt;DoReadHead[從外存的第一個扇區中讀取升級信息]--&gt;IsReadSucc{讀取成功}IsReadSucc--否--&gt;Over1(結束)IsReadSucc--是--&gt;IsUpdateFlagIsDownload{升級標識&#x3D;&#x3D;0xAABBFFFF}IsUpdateFlagIsDownload--否--&gt;Over2(結束)IsUpdateFlagIsDownload--是--&gt;IsUpdateTypeIsZipDiff{是否爲壓縮增量升級}IsUpdateTypeIsZipDiff--是--&gt;DoUnDiff[執行差分還原操作]--如果小程序爲舊版本&lt;br&gt;則寫入時偏移75字節&lt;br&gt;當前程序中的可變字段以默認值進行處理---&gt;DoCheckNewAppCRCIsUpdateTypeIsZipDiff--否--&gt;IsUpdateTypeIsZipFull{是否爲壓縮全量升級}IsUpdateTypeIsZipFull--是--&gt;DoUnZip[執行文件解壓操作]--如果小程序爲舊版本&lt;br&gt;則寫入時偏移75字節---&gt;DoCheckNewAppCRCIsUpdateTypeIsZipFull--否--&gt;IsUpdateTypeIsRawFull{是否爲原版全量升級}IsUpdateTypeIsRawFull--是--&gt;DoNothing[無需執行任何操作]---&gt;DoCheckNewAppCRC[校驗新程序&lt;br&gt;對比文件頭中的新程序CRC與&lt;br&gt;新程序存儲區中的數據的CRC]IsUpdateTypeIsRawFull--否--&gt;Over3(結束)DoCheckNewAppCRC--如果小程序爲舊版本&lt;br&gt;則讀取時偏移75字節---&gt;IsCRCCheckOK{CRC是否一致}IsCRCCheckOK--否--&gt;Over4(結束)IsCRCCheckOK--是--&gt;DoChangeUpdateFlag[將外存中的升級標識從0xAABBFFFF改爲0xAABBCCDD]--&gt;IsChangeSucc{修改是否成功}IsChangeSucc--否--&gt;Over5(結束)IsChangeSucc--是--&gt;DoChangeInternalFlashUpdateFlag[將內部flash中的0xAABBCCDD改成0x0000CCDD]--&gt;DoReset[一秒後重啓進入引導程序]--&gt;OverX(結束)</pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全量升級由於要傳輸新版程序的完整鏡像，因此升級時間通常較長，升級失敗的概率也更大。那麼能不能只傳送差異數據呢？答案是可以。這種技術被稱作增量升級&amp;#x2F;差量升級&amp;#x2F;差分升級。&lt;/p&gt;
&lt;p&gt;常見的方案有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bsdiff&amp;#x2F;bspatch + quicklz&lt;/li&gt;
&lt;li&gt;hdifflite&amp;#x2F;hpatchlite + tinyuz&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;不過 bsdiff + quicklz 方案的內存開銷太大，因此不建議使用。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;全量升級-amp-增量升級&quot;&gt;&lt;a href=&quot;#全量升級-amp-增量升級&quot; class=&quot;headerlink&quot; title=&quot;全量升級 &amp;amp; 增量升級&quot;&gt;&lt;/a&gt;全量升級 &amp;amp; 增量升級&lt;/h2&gt;&lt;p&gt;增量升級確實降低了傳輸過程中的數據量，但也帶來了版本管理複雜的問題，所以說不能因爲有了增量升級，全量升級就不用了。&lt;/p&gt;
&lt;p&gt;以往我們做全量升級的時候沒有引入壓縮技術，在移植 hdiff&amp;#x2F;hpatchlite 的時候我發現，hdiff 生成的差異文件不比原文件小多少，但是其可壓縮性非常高，這樣就得把解壓算法也移植進來。既然解壓算法都已經有了，不把增量升級也壓縮一下，那豈不是很浪費？&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot; rowspan=&quot;2&quot;&gt;全量升級&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;未經壓縮的新版程序&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot;&gt;經過壓縮的新版程序&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✔）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot; rowspan=&quot;2&quot;&gt;增量升級&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;未經壓縮的差異文件&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot;&gt;經過壓縮的差異文件&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✔）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#04）技術細節</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html</id>
    <published>2023-09-30T16:00:04.000Z</published>
    <updated>2023-09-30T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>分散加載、中斷向量表重定向</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#03）流程設計</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html</id>
    <published>2023-09-30T16:00:03.000Z</published>
    <updated>2023-09-30T16:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A1(引導程序之流程)--&gt;B1(......)--&gt;C1(跳轉至應用程序)A2(應用程序之流程)--&gt;B2(......)--&gt;C2(跳轉至引導程序)</pre><span id="more"></span><h2 id="引導程序流程"><a href="#引導程序流程" class="headerlink" title="引導程序流程"></a>引導程序流程</h2><p>引導程序的設計方案我知道有兩種：</p><ul><li>立即跳轉方案</li><li>延時跳轉方案</li></ul><p>立即跳轉方案在判斷出應用程序有效之後會立即執行跳轉操作，該方案適用於對啓動時間要求比較高的產品。延時跳轉方案則是先在引導程序中等待一段時間，在這段時間內如果沒有任何請求則時間到了之後會自動跳轉至應用程序，否則將停留在引導程序中。</p><h3 id="立即跳轉方案"><a href="#立即跳轉方案" class="headerlink" title="立即跳轉方案"></a>立即跳轉方案</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%PowerReset(設備上電覆位)--&gt;IapStart(引導程序開始)--&gt;IapCheckApp[檢查應用程序有效標識]--&gt;IapIsAppValid{是否有效}IapIsAppValid--是--&gt;IapJumpToApp[跳轉進入應用程序]--&gt;IapOver(引導程序結束)IapIsAppValid--否--&gt;IapRemap[重定向中斷向量表]--&gt;IapInit[配置相關外設]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升級數據}IapIsHaveUpdateData--否--&gt;IapBeforeJumpIapIsHaveUpdateData--是--&gt;IapDoUpdate[執行升級操作]---&gt;IapEraseUpdateData[擦除升級數據]--&gt;IapIsUpdateSucc{升級成功}IapIsUpdateSucc--是---&gt;IapSetAppValid[修改應用程序有效標識：有效]--&gt;IapBeforeJump[關閉外設和中斷]--&gt;IapJumpToAppIapIsUpdateSucc--否--&gt;IapIsAppErased{應用程序已損毀}IapIsAppErased--否--&gt;IapBeforeJumpIapIsAppErased--是&lt;br&gt;留在引導程序中--&gt;IapComm[執行通信任務]--&gt;IapIsRecvDone{收到升級數據}IapIsRecvDone--否--&gt;IapCommIapIsRecvDone--是--&gt;IapDoUpdate</pre><h3 id="延時跳轉方案"><a href="#延時跳轉方案" class="headerlink" title="延時跳轉方案"></a>延時跳轉方案</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%PowerReset(設備上電覆位)--&gt;IapStart(引導程序開始)--&gt;IapCheckApp[檢查應用程序有效標識]--&gt;IapIsAppValid{是否有效}IapIsAppValid--是--&gt;IapWait{計數超時&lt;br&gt;（延時跳轉）}IapWait--否--&gt;IapWaitIapWait--是----------&gt;IapJumpToApp[跳轉進入應用程序]--&gt;IapOver(引導程序結束)IapIsAppValid--否--&gt;IapRemap[重定向中斷向量表]--&gt;IapInit[配置相關外設]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升級數據}IapIsHaveUpdateData--否--&gt;IapBeforeJumpIapIsHaveUpdateData--是--&gt;IapDoUpdate[執行升級操作]---&gt;IapEraseUpdateData[擦除升級數據]--&gt;IapIsUpdateSucc{升級成功}IapIsUpdateSucc--是---&gt;IapSetAppValid[修改應用程序有效標識：有效]--&gt;IapBeforeJump[關閉外設和中斷]--&gt;IapJumpToAppIapIsUpdateSucc--否--&gt;IapIsAppErased{應用程序已損毀}IapIsAppErased--否--&gt;IapBeforeJumpIapIsAppErased--是&lt;br&gt;留在引導程序中--&gt;IapComm[執行通信任務]--&gt;IapIsRecvDone{收到升級數據}IapIsRecvDone--否--&gt;IapCommIapIsRecvDone--是--&gt;IapDoUpdate</pre><h2 id="應用程序流程"><a href="#應用程序流程" class="headerlink" title="應用程序流程"></a>應用程序流程</h2><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%AppStart(應用程序開始)--&gt;AppRemap[重定向中斷向量表]--&gt;AppInit[配置相關外設]--&gt;AppTask[執行應用功能]--&gt;AppComm[執行通信任務]--&gt;AppIsRecvDone{收到升級數據}AppIsRecvDone--否--&gt;AppTaskAppIsRecvDone--是--&gt;AppSetAppInvalid[修改應用程序有效標識：無效]--&gt;AppBeforeJump[關閉外設和中斷]--&gt;AppJumpToIap[重啓進入引導程序｜跳轉進入引導程序]--&gt;AppOver(應用程序結束)</pre>]]></content>
    
    
    <summary type="html">&lt;pre class=&quot;mermaid&quot;&gt;
flowchart TB
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A1(引導程序之流程)--&amp;gt;B1(......)--&amp;gt;C1(跳轉至應用程序)
A2(應用程序之流程)--&amp;gt;B2(......)--&amp;gt;C2(跳轉至引導程序)
&lt;/pre&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#02）升級方案</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html</id>
    <published>2023-09-30T16:00:02.000Z</published>
    <updated>2023-09-30T16:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<center>which one is better?</center><br><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(在引導程序中集成通信協議棧與解壓還原算法)~~~B(在應用程序中集成通信協議棧與解壓還原算法)</pre><span id="more"></span><h2 id="思路（-1）：引導程序主導"><a href="#思路（-1）：引導程序主導" class="headerlink" title="思路（#1）：引導程序主導"></a>思路（#1）：引導程序主導</h2><table><thead><tr><th align="center">具體分工</th><th align="center">引導程序</th><th align="center">應用程序</th></tr></thead><tbody><tr><td align="center">編程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信協議</td><td align="center">完備的通信協議棧</td><td align="center">　　　　　　　　</td></tr><tr><td align="center">文件解壓</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">差分還原</td><td align="center">✔</td><td align="center"></td></tr></tbody></table><div class="note success no-icon"><p><strong>優點</strong>：設備中沒有應用程序或應用程序異常時也可以進行 IAP 升級。</p></div><div class="note danger no-icon"><p><strong>缺點</strong>：在引導程序中集成通信協議棧、文件解壓、差分還原等功能，會導致其代碼量較大。</p></div><h2 id="思路（-2）：應用程序主導"><a href="#思路（-2）：應用程序主導" class="headerlink" title="思路（#2）：應用程序主導"></a>思路（#2）：應用程序主導</h2><table><thead><tr><th align="center">具體分工</th><th align="center">引導程序</th><th align="center">應用程序</th></tr></thead><tbody><tr><td align="center">編程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信協議</td><td align="center">　　　　　　　　</td><td align="center">完備的通信協議棧</td></tr><tr><td align="center">文件解壓</td><td align="center"></td><td align="center">✔</td></tr><tr><td align="center">差分還原</td><td align="center"></td><td align="center">✔</td></tr></tbody></table><div class="note success no-icon"><p><strong>優點</strong>：引導程序比較簡單，佔用空間小，方便維護。</p></div><div class="note danger no-icon"><p><strong>缺點</strong>：設備中沒有應用程序或應用程序異常時無法進行 IAP 升級。</p></div><h2 id="思路（-3）：兩者各取所長"><a href="#思路（-3）：兩者各取所長" class="headerlink" title="思路（#3）：兩者各取所長"></a>思路（#3）：兩者各取所長</h2><table><thead><tr><th align="center">具體分工</th><th align="center">引導程序</th><th align="center">應用程序</th></tr></thead><tbody><tr><td align="center">編程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信協議</td><td align="center">基礎的通信協議棧</td><td align="center">完備的通信協議棧</td></tr><tr><td align="center">文件解壓</td><td align="center"></td><td align="center">✔</td></tr><tr><td align="center">差分還原</td><td align="center"></td><td align="center">✔</td></tr></tbody></table><div class="note success no-icon"><p><strong>特點</strong>：在引導程序中集成基礎的通信協議棧，代碼量能接受，應用程序異常時也能在線升級。</p></div><div class="note success no-icon"><p><strong>特點</strong>：在應用程序中集成完整的通信協議棧、文件解壓、差分還原等功能，功能完備。</p></div><h2 id="方案（-0）"><a href="#方案（-0）" class="headerlink" title="方案（#0）"></a>方案（#0）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除應用程序存儲區，然後等待接收新版應用程序（直接寫入到升級文件存儲區），等接收完畢且校驗無誤後跳轉至應用程序，至此升級完成。</p><h2 id="方案（-1）"><a href="#方案（-1）" class="headerlink" title="方案（#1）"></a>方案（#1）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><p>或</p><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody><thead><tr><th align="center">外部flash存儲空間劃分</th><th align="center">外部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr></tbody></table><h3 id="思路（-1）"><a href="#思路（-1）" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除舊版應用程序，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><h3 id="思路（-2）"><a href="#思路（-2）" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至新版程序存儲區，重啓進入或跳轉進入引導程序。進入引導程序後對新版程序進行二次校驗，校驗通過後擦除舊版應用程序，然後將新版程序存儲區中的新版應用程序拷貝至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><h3 id="思路（-3）"><a href="#思路（-3）" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至新版程序存儲區，重啓進入或跳轉進入引導程序。進入引導程序後對新版程序進行二次校驗，校驗通過後擦除舊版應用程序，然後將新版程序存儲區中的新版應用程序拷貝至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除舊版應用程序，然後將升級文件存儲區中的新版應用程序拷貝（不支持解壓和差分還原）至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><h2 id="方案（-2）"><a href="#方案（-2）" class="headerlink" title="方案（#2）"></a>方案（#2）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><h3 id="思路（-1）-1"><a href="#思路（-1）-1" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-2）-1"><a href="#思路（-2）-1" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-3）-1"><a href="#思路（-3）-1" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p><h2 id="方案（-3）"><a href="#方案（-3）" class="headerlink" title="方案（#3）"></a>方案（#3）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><p>或</p><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody><thead><tr><th align="center">外部flash存儲空間劃分</th><th align="center">外部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr></tbody></table><h3 id="思路（-1）-2"><a href="#思路（-1）-2" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，最後翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-2）-2"><a href="#思路（-2）-2" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-3）-2"><a href="#思路（-3）-2" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝（不支持解壓和差分還原）至備份應用存儲區，最後翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p>]]></content>
    
    
    <summary type="html">&lt;center&gt;which one is better?&lt;/center&gt;
&lt;br&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(在引導程序中集成通信協議棧與解壓還原算法)~~~B(在應用程序中集成通信協議棧與解壓還原算法)
&lt;/pre&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#01）基礎概念</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html</id>
    <published>2023-09-30T16:00:01.000Z</published>
    <updated>2023-09-30T16:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<center>傳統編程方式</center><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(先取下芯片)---&gt;B(再燒錄程序)---&gt;C(後裝回板卡)</pre><center>現代編程方式</center><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(&quot;在電路編程&lt;br&gt;(ＩＣＰ)&quot;)---&gt;B(&quot;在系統編程&lt;br&gt;(ＩＳＰ)&quot;)---&gt;C(&quot;在應用編程&lt;br&gt;(ＩＡＰ)&quot;)</pre><span id="more"></span><h2 id="傳統編程方式"><a href="#傳統編程方式" class="headerlink" title="傳統編程方式"></a>傳統編程方式</h2><p>傳統編程方式是先將程序燒錄至主控芯片中再焊接到電路板上。</p><p><strong>開發階段</strong></p><ul><li>➀ 從電路板上取下芯片</li><li>➁ 使用燒錄器燒寫程序</li><li>➂ 將芯片裝回至電路板</li></ul><p><strong>量產階段</strong></p><ul><li>➀ 從 tray 盤取出芯片</li><li>➁ 使用燒錄器燒寫程序</li><li>➂ 將芯片放回 tray 盤</li></ul><p><strong>維護階段</strong></p><ul><li>➀ 從電路板上拆下芯片</li><li>➁ 使用燒錄器燒寫程序</li><li>➂ 將芯片焊回至電路板</li></ul><h2 id="現代編程方式"><a href="#現代編程方式" class="headerlink" title="現代編程方式"></a>現代編程方式</h2><p>現代編程方式可以直接進行板上燒錄，不用再取下芯片放到專用的燒錄器上燒錄，極大地提高了開發、生產以及維護效率。</p><p>現代編程方式又可分爲：</p><ul><li>在電路編程 ICP (Circuit)</li><li>在系統編程 ISP (System)</li><li>在應用編程 IAP (Application)</li></ul><table><thead><tr><th align="center">編程方式</th><th align="center">在電路編程</th><th align="center">在系統編程</th><th align="center">在應用編程</th></tr></thead><tbody><tr><td align="center">核心思想</td><td align="center">藉助外部燒錄器<br>通過JTAG&#x2F;SWD接口<br>實現在電路編程</td><td align="center">藉助芯片內部<br>固化的引導程序和BOOT引腳<br>以及片上接口<br>實現在系統編程</td><td align="center">藉助用戶自己<br>編寫的引導程序、應用程序<br>以及片上接口、板上接口<br>實現在應用編程</td></tr><tr><td align="center">引導程序</td><td align="center">不需要</td><td align="center">需要芯片廠家編寫<br>並固化到某一地址空間</td><td align="center">需要用戶自己編寫<br>並燒錄至內部flash存儲器</td></tr><tr><td align="center">進入方式</td><td align="center">隨時待命</td><td align="center">需要更改BOOT引腳的電平<br>然後硬件復位<br>進入內部固化的引導程序</td><td align="center">隨時待命</td></tr><tr><td align="center">配套軟件</td><td align="center">燒錄軟件</td><td align="center">芯片廠家提供的<br>上位機ISP編程軟件</td><td align="center">用戶自己開發的數據傳輸軟件</td></tr><tr><td align="center">通信接口</td><td align="center">JTAG&#x2F;SWD</td><td align="center">取決於芯片中固化的引導程序<br>URT&#x2F;SPI&#x2F;IIC&#x2F;CAN&#x2F;USB</td><td align="center">理論上可以支持任意接口<br>URT&#x2F;SPI&#x2F;IIC<br>485&#x2F;CAN&#x2F;USB<br>WiFi&#x2F;BLE&#x2F;IrDA<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td></tr><tr><td align="center">程序升級<br>是否需要<br>拆裝芯片</td><td align="center">不需要<br>拆裝芯片</td><td align="center">不需要<br>拆裝芯片</td><td align="center">不需要<br>拆裝芯片</td></tr><tr><td align="center">程序升級<br>是否需要<br>拆裝外殼</td><td align="center">需要<br>拆開設備外殼</td><td align="center">通信接口完備的情況下<br>不需要<br>拆開設備外殼<br>485&#x2F;CAN&#x2F;USB</td><td align="center">通信接口完備的情況下<br>不需要<br>拆開設備外殼<br>485&#x2F;CAN&#x2F;USB&#x2F;WiFi&#x2F;BLE&#x2F;IrDA</td></tr><tr><td align="center">程序升級<br>是否需要<br>前往現場</td><td align="center">需要<br>前往設備安裝現場</td><td align="center">需要<br>前往設備安裝現場</td><td align="center">遠程通信功能完備的情況下<br>不需要<br>前往設備安裝現場<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td></tr></tbody></table><div class="note info no-icon"><p>ICP 主要是在開發階段使用，其燒錄速度是 ISP 和 IAP 所無法比擬的。</p></div><div class="note info no-icon"><p>IAP 與 ISP 類似，都有 bootloader 引導程序，因此無需使用燒錄器。二者的區別在於，ISP 的引導程序由芯片廠家編寫，比較簡單，無法實現用戶的定製化需求；而 IAP 的引導程序是由用戶自己實現，可以根據需求自行修改。另外 ISP 進入 boot 程序的方式是通過更改 BOOT 引腳的電平；而 IAP 則是從用戶程序中通過軟件復位或者跳轉的方式直接進入 bootloader 程序，因此相較於 ISP 來說會更加靈活。</p></div><div class="note info no-icon"><p>通過 WiFi&#x2F;BLE&#x2F;4G&#x2F;5G&#x2F;NBIoT 等無線通信技術實現 IAP 功能的方案也被稱作 OTA 空中下載技術。</p></div><table><thead><tr><th align="center">BOOT1</th><th align="center">BOOT0</th><th align="center">BOOT MODE</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">0</td><td align="center">boot from 0x08000000 : main memory</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">boot from 0x1FFF0000 : boot memory</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">boot from 0x20000000 : sram memory</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;center&gt;傳統編程方式&lt;/center&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(先取下芯片)---&amp;gt;B(再燒錄程序)---&amp;gt;C(後裝回板卡)
&lt;/pre&gt;

&lt;center&gt;現代編程方式&lt;/center&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(&amp;quot;在電路編程&amp;lt;br&amp;gt;(ＩＣＰ)&amp;quot;)---&amp;gt;B(&amp;quot;在系統編程&amp;lt;br&amp;gt;(ＩＳＰ)&amp;quot;)---&amp;gt;C(&amp;quot;在應用編程&amp;lt;br&amp;gt;(ＩＡＰ)&amp;quot;)
&lt;/pre&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#00）目錄索引</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2023-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html">嵌入式 IAP 升級功能（#01）基礎概念</a><br><a href="/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html">嵌入式 IAP 升級功能（#02）升級方案</a><br><a href="/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html">嵌入式 IAP 升級功能（#03）流程設計</a><br><a href="/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html">嵌入式 IAP 升級功能（#04）技術細節</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#05）增量升級</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuztool 移植</a><br><a href="/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html">嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級</a></p><hr><span id="more"></span><h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://itexp.blog.csdn.net/article/details/83793309">https://itexp.blog.csdn.net/article/details/83793309</a></p><p><a href="https://blog.csdn.net/qq_24130227/article/details/123752964">https://blog.csdn.net/qq_24130227/article/details/123752964</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108379324">https://blog.csdn.net/qq_24130227/article/details/108379324</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/113003329">https://blog.csdn.net/qq_24130227/article/details/113003329</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/120061873">https://blog.csdn.net/qq_24130227/article/details/120061873</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108427842">https://blog.csdn.net/qq_24130227/article/details/108427842</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html&quot;&gt;嵌入式 IAP 升級功能（#01）基礎概念&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html&quot;&gt;嵌入式 IAP 升級功能（#02）升級方案&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html&quot;&gt;嵌入式 IAP 升級功能（#03）流程設計&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html&quot;&gt;嵌入式 IAP 升級功能（#04）技術細節&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升級功能（#05）增量升級&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuztool 移植&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html&quot;&gt;嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="單片機" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%96%AE%E7%89%87%E6%A9%9F/"/>
    
    <category term="iap" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/iap/"/>
    
    <category term="bootloader" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>問題記錄：華大 HC32F460 濾波電路失效</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss.html</id>
    <published>2023-08-08T16:00:00.000Z</published>
    <updated>2023-08-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用電壓比較器時發現硬件濾波電路會出現失效的情況，經分析是其採樣頻率過高所致。</p><p><img src="/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss/manual.png"></p><p>參考手冊中繪製的是理想條件下的波形，真實情況並非如此，INP 在逼近 INM 時會伴隨着噪聲&#x2F;抖動。我們可以使用硬件濾波電路來消除這種抖動，圖中綠色線段表示各採樣點，其頻率即爲採樣頻率。</p><iframe src="https://www.desmos.com/calculator/7r0bi5urxv?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe><p>採樣頻率較低時，濾波電路可以正常工作，但是隨着採樣頻率的升高，其可靠性反而會降低。</p><span id="more"></span><iframe src="https://www.desmos.com/calculator/2kz1rewo6h?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe><iframe src="https://www.desmos.com/calculator/2py3qizn5x?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在使用電壓比較器時發現硬件濾波電路會出現失效的情況，經分析是其採樣頻率過高所致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss/manual.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;參考手冊中繪製的是理想條件下的波形，真實情況並非如此，INP 在逼近 INM 時會伴隨着噪聲&amp;#x2F;抖動。我們可以使用硬件濾波電路來消除這種抖動，圖中綠色線段表示各採樣點，其頻率即爲採樣頻率。&lt;/p&gt;
&lt;iframe src=&quot;https://www.desmos.com/calculator/7r0bi5urxv?embed&quot; width=&quot;800&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc&quot; frameborder=0&gt;&lt;/iframe&gt;

&lt;p&gt;採樣頻率較低時，濾波電路可以正常工作，但是隨着採樣頻率的升高，其可靠性反而會降低。&lt;/p&gt;</summary>
    
    
    
    <category term="問題記錄" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%95%8F%E9%A1%8C%E8%A8%98%E9%8C%84/"/>
    
    
    <category term="華大半導體" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E8%8F%AF%E5%A4%A7%E5%8D%8A%E5%B0%8E%E9%AB%94/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>問題記錄：華大 HC32F460 切換運行模式導致宕機</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4.html</id>
    <published>2023-07-26T16:00:00.000Z</published>
    <updated>2023-07-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="現象描述"><a href="#現象描述" class="headerlink" title="現象描述"></a>現象描述</h2><ul><li>從高速&#x2F;超高速模式向超低速模式切換時 mcu 異常死機</li></ul><h2 id="基礎信息"><a href="#基礎信息" class="headerlink" title="基礎信息"></a>基礎信息</h2><ul><li>當前使用華大 2.2.0 版驅動程序</li><li>當前使用華大 1.2.1 版參考手冊</li></ul><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>通過調試發現每次運行至 <code>M4_SYSREG-&gt;PWR_PWRC2</code> 賦值時程序就會跑飛😶</p><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2-Register.png" alt="電源模式控制寄存器 2"></p><figure class="highlight c"><figcaption><span>hc32f460_pwc.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">en_result_t</span> <span class="title function_">PWC_HS2LS</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    M4_SYSREG-&gt;PWR_PWRC2 = <span class="number">0xE1</span>U;</span><br><span class="line">    M4_SYSREG-&gt;PWR_MDSWCR = <span class="number">0x10</span>U;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">en_result_t</span> <span class="title function_">PWC_HP2LS</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    M4_SYSREG-&gt;PWR_PWRC2 = <span class="number">0xD1</span>U;</span><br><span class="line">    M4_SYSREG-&gt;PWR_MDSWCR = <span class="number">0x10</span>U;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞅了一眼《參考手冊 Rev1.2.1》好像也沒啥問題，又看了《參考手冊 Rev1.3》後，我得發…🙄！</p><p>兩版手冊竟然不一樣！</p><span id="more"></span><h3 id="Rev1-2-1"><a href="#Rev1-2-1" class="headerlink" title="Rev1.2.1"></a>Rev1.2.1</h3><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2.png" alt="運行模式的切換流程（Rev1.2）"></p><h3 id="Rev1-3-0"><a href="#Rev1-3-0" class="headerlink" title="Rev1.3.0"></a>Rev1.3.0</h3><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.3.png" alt="運行模式的切換流程（Rev1.3）"></p><p>這妥妥的是華大的鍋了…</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;現象描述&quot;&gt;&lt;a href=&quot;#現象描述&quot; class=&quot;headerlink&quot; title=&quot;現象描述&quot;&gt;&lt;/a&gt;現象描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;從高速&amp;#x2F;超高速模式向超低速模式切換時 mcu 異常死機&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基礎信息&quot;&gt;&lt;a href=&quot;#基礎信息&quot; class=&quot;headerlink&quot; title=&quot;基礎信息&quot;&gt;&lt;/a&gt;基礎信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;當前使用華大 2.2.0 版驅動程序&lt;/li&gt;
&lt;li&gt;當前使用華大 1.2.1 版參考手冊&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h2&gt;&lt;p&gt;通過調試發現每次運行至 &lt;code&gt;M4_SYSREG-&amp;gt;PWR_PWRC2&lt;/code&gt; 賦值時程序就會跑飛😶&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2-Register.png&quot; alt=&quot;電源模式控制寄存器 2&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;hc32f460_pwc.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;en_result_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;PWC_HS2LS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_PWRC2 = &lt;span class=&quot;number&quot;&gt;0xE1&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_MDSWCR = &lt;span class=&quot;number&quot;&gt;0x10&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;en_result_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;PWC_HP2LS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_PWRC2 = &lt;span class=&quot;number&quot;&gt;0xD1&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    M4_SYSREG-&amp;gt;PWR_MDSWCR = &lt;span class=&quot;number&quot;&gt;0x10&lt;/span&gt;U;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;瞅了一眼《參考手冊 Rev1.2.1》好像也沒啥問題，又看了《參考手冊 Rev1.3》後，我得發…🙄！&lt;/p&gt;
&lt;p&gt;兩版手冊竟然不一樣！&lt;/p&gt;</summary>
    
    
    
    <category term="問題記錄" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%95%8F%E9%A1%8C%E8%A8%98%E9%8C%84/"/>
    
    
    <category term="華大半導體" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E8%8F%AF%E5%A4%A7%E5%8D%8A%E5%B0%8E%E9%AB%94/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>開發指南：華大 HC32F460 時鐘控制單元</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup.html</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-tree-sketch.png"></p><span id="more"></span><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-tree-manual.png"></p><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-work.png"></p><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-work-manual.png"></p><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-work-note.png"></p><h2 id="pll"><a href="#pll" class="headerlink" title="pll"></a>pll</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/pll.png"></p><h2 id="systick"><a href="#systick" class="headerlink" title="systick"></a>systick</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/systick.png"></p><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/systick-manual.jpg"></p><center>《ARM ® CortexM4 Devices Generic User Guide》</center><br><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/systick-register.png"></p><center>hc32f460's systick control and status register</center><br><div class="note danger no-icon"><p>華大 HC32F460 的 systick 嘀嗒定時器使用內核時鐘（HCLK）</p></div><figure class="highlight c"><figcaption><span>HC32F460.h</span></figcaption><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line">* @file  HC32F460.h</span><br><span class="line">* @brief Headerfile <span class="keyword">for</span> HC32F460 series MCU</span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">Configuration of the Cortex-M4 Processor and Core Peripherals</span><br><span class="line">********************************************************************************</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CM4_REV                 1     <span class="comment">// !&lt; Core revision r0p1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FPU_PRESENT             1     <span class="comment">// !&lt; FPU present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU_PRESENT             1     <span class="comment">// !&lt; HC32F460 provides an MPU</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NVIC_PRIO_BITS          4     <span class="comment">// !&lt; HC32F460 uses 4 Bits for the Priority Levels</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Vendor_SysTickConfig    0     <span class="comment">// !&lt; Set to 1 if different SysTick Config is used</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>core_cm4.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (__Vendor_SysTickConfig) &amp;&amp; (__Vendor_SysTickConfig == 0U)</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><div class="note danger no-icon"><p>華大 HC32F460 的 systick 嘀嗒定時器使用 cmsis(core_cm4.h) 中默認的配置函數</p></div><h2 id="外設時鐘源（URT）"><a href="#外設時鐘源（URT）" class="headerlink" title="外設時鐘源（URT）"></a>外設時鐘源（URT）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-URT.png"></p><center>÷2 表示開啓過採樣功能</center><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-URT-example.png"></p><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-URT-baudrate-manual.jpg"></p><!--公式使用工具 https://latexlive.com/ 生成\begin{align}& Baudrate = \frac{串口頻率}{08\ \times\ (1\ +整數分頻寄存器)} \ \ \ \ (關閉過採樣) \\& Baudrate = \frac{串口頻率}{16\ \times\ (1\ +整數分頻寄存器)} \ \ \ \ (開啓過採樣) \\\end{align}--></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt" displaystyle="true"><mtr><mtd></mtd><mtd><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mo>串口頻率</mo></mrow><mrow><mn>08</mn><mtext>&nbsp;</mtext><mo>×</mo><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mn>1</mn><mtext>&nbsp;</mtext><mo>+</mo><mo>整數分頻寄存器</mo><mo stretchy="false">)</mo></mrow></mfrac><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mo>關閉過採樣</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt" displaystyle="true"><mtr><mtd></mtd><mtd><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mo>串口頻率</mo></mrow><mrow><mn>16</mn><mtext>&nbsp;</mtext><mo>×</mo><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mn>1</mn><mtext>&nbsp;</mtext><mo>+</mo><mo>整數分頻寄存器</mo><mo stretchy="false">)</mo></mrow></mfrac><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mo>開啓過採樣</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></math><br><div class="note info no-icon"><p>公式中整數分頻寄存器的取值範圍爲 0x00 ~ 0xFF（USART_BRR[b15~b08]）</p></div><h2 id="外設時鐘源（SPI）"><a href="#外設時鐘源（SPI）" class="headerlink" title="外設時鐘源（SPI）"></a>外設時鐘源（SPI）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-SPI.png"></p><h2 id="外設時鐘源（I2C）"><a href="#外設時鐘源（I2C）" class="headerlink" title="外設時鐘源（I2C）"></a>外設時鐘源（I2C）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK3-I2C.png"></p><h2 id="外設時鐘源（CMP）"><a href="#外設時鐘源（CMP）" class="headerlink" title="外設時鐘源（CMP）"></a>外設時鐘源（CMP）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK3-CMP.png"></p><div class="note danger no-icon"><p>比較濾波器的採樣頻率越低→濾波效果越好！</p></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;clock&quot;&gt;&lt;a href=&quot;#clock&quot; class=&quot;headerlink&quot; title=&quot;clock&quot;&gt;&lt;/a&gt;clock&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-tree-sketch.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="開發指南" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="華大半導體" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E8%8F%AF%E5%A4%A7%E5%8D%8A%E5%B0%8E%E9%AB%94/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－合集</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo3okqut006mi0rq9ecvb34e.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo3okqut006mi0rq9ecvb34e.html</id>
    <published>2023-07-04T16:00:00.000Z</published>
    <updated>2023-07-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>各個平臺下的開發環境搭建教程</p><ul><li><a href="/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html">ARM.GCC</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.MDK (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.SES (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.ADS (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">RV5.GCC (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">RV5.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">RV5.SES (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">C51.MDK (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">C51.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">MSP.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">AVR.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">PIC.XXX (TODO)</a></li></ul><hr><span id="more"></span><h2 id="搭建方案"><a href="#搭建方案" class="headerlink" title="搭建方案"></a>搭建方案</h2><ul><li><strong>VSC</strong><ul><li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li><li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li><li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li><li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li></ul></li><li><strong>VS</strong><ul><li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li><li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li></ul></li><li><strong>Eclipse</strong></li><li><strong>Eclipse Based</strong><ul><li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a></li><li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a></li><li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a></li></ul></li></ul><h2 id="通用方案"><a href="#通用方案" class="headerlink" title="通用方案"></a>通用方案</h2><ul><li><a href="https://www.keil.arm.com/">KeilStudioCloud</a></li><li><a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Development%20Studio">ADS</a><ul><li>ARM</li></ul></li><li><a href="https://www.keil.com/">MDK</a><ul><li>ARM <a href="https://www.keil.com/pr/article/1302.htm">(ARM 6 Will start shipping towards The End of 2023)</a></li><li>C51</li></ul></li><li><a href="https://www.iar.com/products/architectures/">IAR</a><ul><li>RV5</li><li>ARM</li><li>AVR</li><li>MSP</li><li>STM</li><li>C51</li></ul></li><li><a href="https://www.segger.com/products/development-tools/embedded-studio/">SES</a><ul><li>ARM</li><li>RV5</li></ul></li><li><a href="https://embeetle.com/#">EmbeetleIDE</a></li></ul><h2 id="專用方案"><a href="#專用方案" class="headerlink" title="專用方案"></a>專用方案</h2><ul><li><strong>Eclipse Based</strong><ul><li><a href="https://www.st.com/en/development-tools/sw4stm32.html">ST: SW4STM32 System Workbench for STM32</a></li><li><a href="https://www.st.com/en/development-tools/truestudio.html">ST: TrueStudio by Atollic before 2017</a></li><li><a href="">ST: STM32CubeIDE release in 2019 &#x3D; TrueStudio+STM32CubeMX</a></li><li><a href="https://www.renesas.com/us/en/software-tool/e-studio">Renesas: E2Studio</a></li></ul></li><li><strong>NetBeans Based</strong><ul><li><a href="https://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide">Microchip: MPLAB X IDE</a></li></ul></li></ul><h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://elmagnifico.tech/2022/03/14/Embeded-IDE/">https://elmagnifico.tech/2022/03/14/Embeded-IDE/</a><br><a href="https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/">https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;各個平臺下的開發環境搭建教程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html&quot;&gt;ARM.GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.MDK (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.SES (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.ADS (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;RV5.GCC (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;RV5.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;RV5.SES (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;C51.MDK (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;C51.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;MSP.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;AVR.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;PIC.XXX (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－DBG</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html</id>
    <published>2023-07-04T09:23:25.000Z</published>
    <updated>2023-07-04T09:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p><span id="more"></span><h2 id="專用的調試模塊"><a href="#專用的調試模塊" class="headerlink" title="專用的調試模塊"></a>專用的調試模塊</h2><p>常見的 IDE 內部都集成了一個專用的 GUI 調試器，且不能拎出來單獨使用。</p><ul><li>ADS</li><li>IAR</li><li>MDK</li><li>Visual Studio</li></ul><h2 id="獨立的調試工具"><a href="#獨立的調試工具" class="headerlink" title="獨立的調試工具"></a>獨立的調試工具</h2><p>當然也有一些可以獨立使用的調試器，例如：</p><ul><li>CLI: GDB, LLDB</li><li>GUI: x64dbg, WinDBG, OllyDBG</li></ul><h2 id="通用的調試協議（DebugAdapterProtocol）"><a href="#通用的調試協議（DebugAdapterProtocol）" class="headerlink" title="通用的調試協議（DebugAdapterProtocol）"></a>通用的調試協議（DebugAdapterProtocol）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapterProtocol.png"></p><p>不論是專用的調試模塊還是獨立的調試工具，如果想支持調試多種語言，就必須要爲每一種語言開發一套對應的調試程序，並且每個工具廠商都要獨自去完成這些工作。爲了減少不必要的重複勞動，微軟制定了一套通用的調試協議，藉助該協議各工具廠商只需要開發一套調試程序，向下再借助各種調試適配工具即可具備調試所有語言的能力。</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p><center><a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Adapter Protocol (DAP)</a></center><br><p>目前實現該調試協議的開發工具有（常用的）：</p><ul><li>VSC</li><li>VS</li><li>vim</li><li>emacs</li><li>EclipseIDE</li></ul><p>btw, 微軟還制定了一套通用的語言服務器協議 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/LanguageServerProtocol(LSP).png"></p><center><a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></center><h2 id="調試器適配工具（DebugAdapter）"><a href="#調試器適配工具（DebugAdapter）" class="headerlink" title="調試器適配工具（DebugAdapter）"></a>調試器適配工具（DebugAdapter）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapter.png"></p><p>調試適配器是對各類調試器的封裝，遵循 DAP 協議對上提供統一的接口，以簡化上層開發工具。常用的調試適配器有：</p><ul><li><a href="https://github.com/Microsoft/vscode-cpptools">cpptools (C&#x2F;C++ Debug Adapter)</a></li><li><a href="https://github.com/Marus/cortex-debug">cortex-debug (Embedded C&#x2F;C++ Debug Adapter)</a></li></ul><h2 id="調試器軟件本體（Debugger）"><a href="#調試器軟件本體（Debugger）" class="headerlink" title="調試器軟件本體（Debugger）"></a>調試器軟件本體（Debugger）</h2><ul><li><a href="https://sourceware.org/gdb/">GDB: The GNU Project Debugger</a><ul><li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">↑ GDB&#x2F;MI</a></li><li><a href="https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html">↓ GDB Remote Serial Protocol</a></li></ul></li><li><a href="https://developer.arm.com/downloads/-/gnu-rm">arm-none-eabi-gdb: GNU Arm Embedded GDB</a></li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Debugger.png"></p><h2 id="調試器服務程序（DebugServer）"><a href="#調試器服務程序（DebugServer）" class="headerlink" title="調試器服務程序（DebugServer）"></a>調試器服務程序（DebugServer）</h2><ul><li>OpenOCD</li><li>PyOCD</li><li>JLinkGDBServer</li><li>……</li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugServer.png"></p><h2 id="仿真器驅動程序（DongleDriver）"><a href="#仿真器驅動程序（DongleDriver）" class="headerlink" title="仿真器驅動程序（DongleDriver）"></a>仿真器驅動程序（DongleDriver）</h2><ul><li>SEGGER JLink USB Driver</li><li>SEGGER WinUSB USB Device Driver</li></ul><h2 id="仿真器設備本體（Dongle）"><a href="#仿真器設備本體（Dongle）" class="headerlink" title="仿真器設備本體（Dongle）"></a>仿真器設備本體（Dongle）</h2><ul><li>CMSIS-DAP</li><li>SEGGER JLink</li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Dongle.png"></p><h2 id="仿真器傳輸協議（DongleTransportProtocol）"><a href="#仿真器傳輸協議（DongleTransportProtocol）" class="headerlink" title="仿真器傳輸協議（DongleTransportProtocol）"></a>仿真器傳輸協議（DongleTransportProtocol）</h2><ul><li>JTAG <a href="https://www.corelis.com/education/tutorials/jtag-tutorial/">https://www.corelis.com/education/tutorials/jtag-tutorial/</a></li><li>SWD</li></ul><h2 id="目標板目標芯片（TargetBoard）"><a href="#目標板目標芯片（TargetBoard）" class="headerlink" title="目標板目標芯片（TargetBoard）"></a>目標板目標芯片（TargetBoard）</h2><ul><li>STM32F103CB</li><li>STM32F407VE</li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Target.png"></p><h2 id="本地與遠程調試"><a href="#本地與遠程調試" class="headerlink" title="本地與遠程調試"></a>本地與遠程調試</h2><p>遠程調試方案也有很多，這裏只對以下幾種方式作一簡要介紹：</p><ul><li>OpenOCD</li><li>VSCode + JLinkGDBServer</li><li>JLink + JLinkRemoteServer</li><li>KeilMDK + JLinkRemoteServer</li></ul><h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>略.</p><h3 id="VSCode-JLinkGDBServer"><a href="#VSCode-JLinkGDBServer" class="headerlink" title="VSCode + JLinkGDBServer"></a>VSCode + JLinkGDBServer</h3><p>1. 在服務主機上配置開啓 JLink 調試服務器（該服務器會監聽 2331 端口）</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.0.png"></p><div class="note danger no-icon"><p>不要勾選 Localhost Only 選項！</p></div><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.1.png"></p><p>3. 在本地主機上配置 launch.json 文件並啓動調試</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">    &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">    &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">    &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">    &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Marus/cortex-debug/issues/244">cortex-debug-issues#244 : remote debugging</a><br><a href="https://github.com/Marus/cortex-debug/wiki/External-gdb-server-configuration">cortex-debug-wiki : external gdb server configuration</a></p><div class="note info no-icon"><p>點擊啓動調試後 cortex-debug 便會幫助我們通過本地 xGDB 客戶端連接遠程 GDB 服務器。</p></div><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.2.png"></p><p>5. 遠程調試</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此處省略一張在 vscode 中調試的圖片</span><br></pre></td></tr></table></figure><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.3.png"></p><h3 id="JLink-JLinkRemoteServer"><a href="#JLink-JLinkRemoteServer" class="headerlink" title="JLink + JLinkRemoteServer"></a>JLink + JLinkRemoteServer</h3><h4 id="內網連接"><a href="#內網連接" class="headerlink" title="內網連接"></a>內網連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p><p>3. 在本地主機上配置連接 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.png"></p><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p><p>5. 遠程調試</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.1.png"></p><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p><h4 id="隧道連接"><a href="#隧道連接" class="headerlink" title="隧道連接"></a>隧道連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器（隧道方式）</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.0.png"></p><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.1.png"></p><p>3. 在本地主機上配置連接 JLink 遠程服務器（隧道方式）</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.0.png"></p><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.2.png"></p><p>5. 遠程調試</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.1.png"></p><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.3.png"></p><h3 id="KeilMDK-JLinkRemoteServer"><a href="#KeilMDK-JLinkRemoteServer" class="headerlink" title="KeilMDK + JLinkRemoteServer"></a>KeilMDK + JLinkRemoteServer</h3><h4 id="內網連接-1"><a href="#內網連接-1" class="headerlink" title="內網連接"></a>內網連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p><p>3. 在本地主機上配置連接 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.Keil.MDK.png"></p><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p><p>5. 遠程調試</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此處省略一張在 Keil MDK 中調試的圖片</span><br></pre></td></tr></table></figure><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>問題記錄：華大 HC32F460 超頻過猛導致 MCU 宕機</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloqxdq0v001nmgrq2um386nw.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloqxdq0v001nmgrq2um386nw.html</id>
    <published>2023-06-30T16:00:00.000Z</published>
    <updated>2023-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近又把 MCU 給幹廢了，現象如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load &quot;main.axf&quot;</span><br><span class="line">* JLink Info: Device &quot;CORTEX-M4&quot; selected.</span><br><span class="line">Set JLink Project File to &quot;JLinkSettings.ini&quot;</span><br><span class="line">* JLink Info: Device &quot;CORTEX-M4&quot; selected.</span><br><span class="line"></span><br><span class="line">JLink info:</span><br><span class="line">------------</span><br><span class="line">DLL: V7.22b, compiled Jun 17 2021 17:22:49</span><br><span class="line">Firmware: J-Link V9 compiled May  7 2021 16:26:12</span><br><span class="line">Hardware: V9.60</span><br><span class="line">S/N : 69667602</span><br><span class="line">Feature(s) : RDI, GDB, FlashDL, FlashBP, JFlash</span><br><span class="line"></span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: Scanning AP map to find all available APs</span><br><span class="line">* JLink Info: AP[1]: Stopped AP scan as end of AP map has been reached</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: 0x24770011)</span><br><span class="line">* JLink Info: Iterating through AP map to find AHB-AP to use</span><br><span class="line">* JLink Info: AP[0]: Skipped. Invalid implementer code read from CPUIDVal[31:24] = 0x00</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: Scanning AP map to find all available APs</span><br><span class="line">* JLink Info: AP[1]: Stopped AP scan as end of AP map has been reached</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: 0x24770011)</span><br><span class="line">* JLink Info: Iterating through AP map to find AHB-AP to use</span><br><span class="line">* JLink Info: AP[0]: Skipped. Invalid implementer code read from CPUIDVal[31:24] = 0x00</span><br><span class="line"></span><br><span class="line">***JLink Error: Could not find core in Coresight setup</span><br><span class="line"></span><br><span class="line">Error: Flash Download failed  -  Target DLL has been cancelled</span><br><span class="line">Flash Load finished at 10:35:22</span><br></pre></td></tr></table></figure><p>事情經過是這樣的，某款產品第一版硬件的時鐘源選用的是 6MHz 的外部晶振，內部倍頻至 128MHz 作爲系統主頻，而第二版則改成了 24MHz 的外部晶振，第二版硬件出來後，將第一版程序直接燒錄進第二版硬件後 MCU 無法正常啓動且無法被識別。</p><p>初步推測，應該是外部晶振頻率提高，但是程序沒有進行適當地分頻，導致系統主頻遠遠超過數據手冊中規定的頻率上限（200MHz）。</p><!--公式使用工具 https://latexlive.com/ 生成\begin{align}& 128MHz × (24MHz / 6MHz) = 512MHz \ \ \ > \ \ \ MAX(200MHz) \\\end{align}--></p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd></mtd><mtd><mn>128</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo>×</mo><mo stretchy="false">(</mo><mn>24</mn><mi>M</mi><mi>H</mi><mi>z</mi><mrow><mo>/</mo></mrow><mn>6</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>512</mn><mi>M</mi><mi>H</mi><mi>z</mi><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mo>&gt;</mo><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mi>M</mi><mi>A</mi><mi>X</mi><mo stretchy="false">(</mo><mn>200</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></math><br><p>後面通過調試，證實程序的確是在 <code>M4_SYSREG-&gt;CMU_CKSWR_f.CKSW = enTargetSysSrc;</code> 處出現異常。</p><p>上述操作其實就是「超頻」，只是超得有點猛，導致芯片直接宕機。這種情況藉助華大的離線下載器重新燒錄程序即可恢復正常。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="問題記錄" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%95%8F%E9%A1%8C%E8%A8%98%E9%8C%84/"/>
    
    
    <category term="華大半導體" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E8%8F%AF%E5%A4%A7%E5%8D%8A%E5%B0%8E%E9%AB%94/"/>
    
    <category term="HC32F460" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/HC32F460/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#05）程序調試</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html</id>
    <published>2023-06-14T16:00:05.000Z</published>
    <updated>2023-06-14T16:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>laugch.json</li></ul><hr><span id="more"></span><p>1. 在工程目錄下的 .vscode 目錄中新建 laugch.json 文件並填入以下內容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@JLinkGDBServerCL.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;jlink&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;device&quot;: &quot;STM32F103CB&quot;,</span><br><span class="line">            &quot;interface&quot;: &quot;swd&quot;,</span><br><span class="line">            &quot;serverArgs&quot;: [</span><br><span class="line">                // &quot;-gui&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@OpenOCD.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;openocd&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;showDevDebugOutput&quot;: &quot;none&quot;,</span><br><span class="line">            &quot;configFiles&quot;: [</span><br><span class="line">                &quot;openocd/jlink-swd.cfg&quot;,</span><br><span class="line">                &quot;openocd/stm32f1x.cfg&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin/arm-none-eabi-gdb.exe&quot;,</span><br><span class="line">            &quot;armToolchainPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2. 進入側邊欄中的 RunAndDebug 然後選擇</p><ul><li>Debug@JLinkGDBServerCL.exe</li><li>Debug@OpenOCD.exe</li><li>Debug@RemoteServer(GDBServer&#x2F;JLinkGDBServer)</li></ul><p><img src="/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey/launch.json.png"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;laugch.json&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#04）快捷任務</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html</id>
    <published>2023-06-14T16:00:04.000Z</published>
    <updated>2023-06-14T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>tasks.json</li></ul><hr><span id="more"></span><p>通過 makefile 我們將海量的指令精簡至一條 make+ 指令，但是我比較懶，一條指令都不想敲。😎</p><p>1. 在工程目錄下的 .vscode 目錄中新建 tasks.json 文件並填入以下內容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;編譯（build）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;清除（clean）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make clean&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;燒錄（write）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;燒錄（write.openocd）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write.openocd&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>在 cmd 中使用 “|” 連接兩條指令，在 powershell 中使用 “;” 連接兩條指令。</p></div><p>2. 找到菜單欄依次點擊 Terminal -&gt; RunTask 然後選擇：</p><ul><li>編譯（build）</li><li>清除（clean）</li><li>燒錄（write）</li><li>燒錄（write.openocd）</li></ul><p><img src="/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz/task.json.png"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;tasks.json&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#03）程序燒錄</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html</id>
    <published>2023-06-14T16:00:03.000Z</published>
    <updated>2023-06-14T16:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>編程&#x2F;下載&#x2F;燒錄的方式有多種，本文重點介紹以下兩種燒錄方式：</p><ul><li>JLink</li><li>OpenOCD + JLink 仿真器</li></ul><p>其中 OpenOCD 可以搭配多種仿真器使用，這裏以 JLink 仿真器爲例進行說明。</p><span id="more"></span><h2 id="JLink"><a href="#JLink" class="headerlink" title="JLink"></a>JLink</h2><p>1. 確認是否購買了 JLink 仿真器並且已經安裝了 JLink 程序。</p><p>2. 在 makefile 中添加 write 選項：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.png"></p><p>3. 在工程目錄下新建 JLinkLoad.txt 文件並寫入以下內容：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.code.png"></p><p>4. 執行 mingw32-make write 指令：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.succ.png"></p><div class="note danger no-icon"><p>再次提醒：需要使用 JLink 仿真器以及<strong>默認驅動</strong></p></div><div class="note danger no-icon"><p>如果你的電腦中有不止一個 “JLink” 程序，確保在 makefile 中通過絕對路徑使用 JLink 命令。</p></div><p>下圖是我安裝了 JavaJDK 後系統中存在的 jlink 程序，只不過此 “jlink” 非彼 “JLink”！</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLink.JavaJDK.png"></p><h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>1. 確認是否購買了 JLink 仿真器並且已經安裝了 OpenOCD 程序。</p><p>2. 在 makefile 中添加 write 選項：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.png"></p><p>3. 在工程目錄下新建 openocd.cfg 文件並寫入以下內容：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.code.png"></p><blockquote><p><a href="https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics">https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics</a></p></blockquote><p>4. 將 jlink.cfg 和 stm32f1x.cfg 拷貝至工程目錄下。</p><p>5. 使用 zadig 或 USBDriverTool 將仿真器的驅動從 WinUSB 改爲 libusb 驅動。</p><p>6. 執行 mingw32-make write 指令：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.succ.png"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="問題一：未找到-JLink-仿真器"><a href="#問題一：未找到-JLink-仿真器" class="headerlink" title="問題一：未找到 JLink 仿真器"></a>問題一：未找到 JLink 仿真器</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.1.png"></p><p>OpenOCD 對仿真器的支持是通過底層的訪問控制實現的，不依賴仿真器自身的驅動，但是需要 libusb 驅動，因此我們需要使用 zadig 或 USBDriverTool 等工具將仿真器的默認驅動改爲 libusb 驅動。</p><p>需要注意的是，將驅動改成 libusb 之後，原有的調試軟件例如 JLink&#x2F;Keil 將無法再識別到仿真器。</p><p>如果你還想繼續使用這些調試軟件，則需要卸載掉當前的驅動程序並插拔一下仿真器：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.2.png"></p><h3 id="問題二：SWD-amp-JTAG"><a href="#問題二：SWD-amp-JTAG" class="headerlink" title="問題二：SWD &amp; JTAG"></a>問題二：SWD &amp; JTAG</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.1.png"></p><p>OpenOCD 提供的 jlink.cfg 腳本默認使用 JTAG 模式，而我們實際使用的是 SWD 模式。</p><p>解決方法：在 openocd.cfg 文件中添加一條語句：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;編程&amp;#x2F;下載&amp;#x2F;燒錄的方式有多種，本文重點介紹以下兩種燒錄方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JLink&lt;/li&gt;
&lt;li&gt;OpenOCD + JLink 仿真器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 OpenOCD 可以搭配多種仿真器使用，這裏以 JLink 仿真器爲例進行說明。&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
</feed>
