<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ㄅㄆㄇㄈ</title>
  <icon>https://sulfurandcu.github.io/sulfurandcu.io/icon.png</icon>
  <subtitle>bopomofo</subtitle>
  <link href="https://sulfurandcu.github.io/sulfurandcu.io/atom.xml" rel="self"/>
  
  <link href="https://sulfurandcu.github.io/sulfurandcu.io/"/>
  <updated>2023-10-15T02:54:20.000Z</updated>
  <id>https://sulfurandcu.github.io/sulfurandcu.io/</id>
  
  <author>
    <name>刘汲桐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的生產力工具</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html</id>
    <published>2023-10-15T02:54:20.000Z</published>
    <updated>2023-10-15T02:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<center>一些提高工作效率的工具</center><span id="more"></span><h2 id="機械鍵盤"><a href="#機械鍵盤" class="headerlink" title="機械鍵盤"></a>機械鍵盤</h2><ul><li>使用 tmk, qmk 等工具燒錄自定義固件</li></ul><h2 id="鍵位佈局"><a href="#鍵位佈局" class="headerlink" title="鍵位佈局"></a>鍵位佈局</h2><ul><li><a href="clnor6mvz0015ocrq2jks39ew.html">dƷvorak</a></li></ul><h2 id="輸入法兒"><a href="#輸入法兒" class="headerlink" title="輸入法兒"></a>輸入法兒</h2><ul><li>昨夏雙拼</li><li>小鶴雙拼</li><li>朙月拼音</li><li>宮保拼音</li></ul><h2 id="輸入引擎"><a href="#輸入引擎" class="headerlink" title="輸入引擎"></a>輸入引擎</h2><ul><li>中州韻輸入法引擎（rime, weasel, squirrel）</li></ul><h2 id="顯示字體"><a href="#顯示字體" class="headerlink" title="顯示字體"></a>顯示字體</h2><ul><li>思源宋體</li><li>思源黑體</li><li>更紗黑體</li><li>等寬字體（iosevka）</li><li>可變字體（Amstelvar）</li></ul><h2 id="日程計劃"><a href="#日程計劃" class="headerlink" title="日程計劃"></a>日程計劃</h2><ul><li>microsoft.todo</li></ul><h2 id="系統優化"><a href="#系統優化" class="headerlink" title="系統優化"></a>系統優化</h2><ul><li>powertoys</li><li>ContextMenuManager</li><li>RightMenuMgr</li><li>WinXEditor</li><li>StartAllBack</li><li>W11ClassicMenu</li><li>Fliqlo</li><li>zadig</li><li>UsbDriverTool</li><li>SmartSystemMenu</li></ul><h2 id="科學上網"><a href="#科學上網" class="headerlink" title="科學上網"></a>科學上網</h2><ul><li>clash.for.windows (<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a>)</li><li>xtls.space (<a href="https://xtlspace.20181024.xyz/#/register?code=bUox1yaB">https://xtlspace.20181024.xyz/#/register?code=bUox1yaB</a>)</li><li>tor.browser (<a href="https://www.torproject.org/download/">https://www.torproject.org/download/</a>)</li><li>tor.zlibrary (<a href="http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/">http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/</a>)</li></ul><h2 id="文件下載"><a href="#文件下載" class="headerlink" title="文件下載"></a>文件下載</h2><ul><li>Aria2</li><li>ndm</li><li>qbittorrent</li></ul><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul><li>localsend</li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li>qdir</li><li>everything</li></ul><h2 id="虛擬環境"><a href="#虛擬環境" class="headerlink" title="虛擬環境"></a>虛擬環境</h2><ul><li>windows.terminal</li><li>wsl</li><li>vmware</li><li>docker</li><li>cygwin (posix.api&#x2F;cygwin1.dll, bin&#x3D;windows.pe)</li></ul><h2 id="遠程終端"><a href="#遠程終端" class="headerlink" title="遠程終端"></a>遠程終端</h2><ul><li>windterm</li></ul><h2 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h2><ul><li>mingw&#x2F;msys1 (shell) (posix.api&#x2F;msys-1.0.dll) (msys1~cmd.exe, mingw&#x2F;msys1~cygwin)</li><li>mingw&#x2F;msys2 (shell) (posix.api&#x2F;msys-2.0.dll) (msys2~cmd.exe, mingw&#x2F;msys2~cygwin)</li><li>cmake.for.windows</li><li>ninja.for.windows</li><li>mingw.for.windows   (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>mingw32 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>mingw64 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li><li>unxutils</li><li>llvm</li><li>python.sdk</li><li>java.sdk</li><li>go.sdk</li><li>node.js</li></ul><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><ul><li>svn</li><li>git</li></ul><h2 id="文件對比"><a href="#文件對比" class="headerlink" title="文件對比"></a>文件對比</h2><ul><li>winmerge</li></ul><h2 id="文本編輯"><a href="#文本編輯" class="headerlink" title="文本編輯"></a>文本編輯</h2><ul><li>wxMEdit</li></ul><h2 id="軟件開發"><a href="#軟件開發" class="headerlink" title="軟件開發"></a>軟件開發</h2><ul><li>vscode</li><li>vs</li><li>eclipse</li><li>android.studio</li><li>x64dbg</li></ul><h2 id="軟件開發（嵌入式）"><a href="#軟件開發（嵌入式）" class="headerlink" title="軟件開發（嵌入式）"></a>軟件開發（嵌入式）</h2><ul><li>gcc-arm-none-eabi</li><li>openocd</li><li>jlink</li><li>jlink debugger</li><li>keil</li><li>embeetle</li><li>rt-thread.studio</li></ul><h2 id="硬件開發"><a href="#硬件開發" class="headerlink" title="硬件開發"></a>硬件開發</h2><ul><li>KiCAD</li><li>AD</li><li>CadenceSPB</li></ul><h2 id="機械工業"><a href="#機械工業" class="headerlink" title="機械工業"></a>機械工業</h2><ul><li>AutoCAD</li><li>FreeCAD</li><li>Revit</li><li>Rhino</li><li>3dsMax</li><li>SketchUp</li><li>Render.Vray</li><li>Render.D5</li><li>Render.Enscape</li></ul><h2 id="圖片文檔"><a href="#圖片文檔" class="headerlink" title="圖片文檔"></a>圖片文檔</h2><ul><li>截屏工具<ul><li>fscapture</li><li>sharex</li></ul></li><li>圖片查看<ul><li>honeyview</li></ul></li><li>圖片編輯<ul><li>GIMP</li><li>inkscape</li><li>shift.n</li><li>ascii.generator</li></ul></li><li>文檔查看<ul><li>PDF.24</li></ul></li><li>文檔編輯<ul><li>PDF.XChange.Editor</li><li>draw.io</li><li>wave.drom.editor</li></ul></li></ul><h2 id="視頻音頻"><a href="#視頻音頻" class="headerlink" title="視頻音頻"></a>視頻音頻</h2><ul><li>錄屏工具<ul><li>obs.studio</li><li>lonelyscreen (ios screen display)</li></ul></li><li>視頻播放<ul><li>MPC-HC</li><li>VLC</li><li>PotPlayer</li></ul></li><li>視頻剪輯<ul><li>shotcut</li><li>losslesscut</li></ul></li><li>視頻轉碼<ul><li>handbrake</li></ul></li><li>音頻播放<ul><li>foobar2000</li></ul></li><li>音頻剪輯<ul><li>audacity</li><li>wavosaur</li></ul></li><li>音頻轉碼<ul><li>略.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;一些提高工作效率的工具&lt;/center&gt;</summary>
    
    
    
    <category term="效率提升" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
    
    <category term="生產工具" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E7%94%9F%E7%94%A2%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html</id>
    <published>2023-09-30T16:00:08.000Z</published>
    <updated>2023-09-30T16:00:08.000Z</updated>
    
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuz 移植</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html</id>
    <published>2023-09-30T16:00:07.000Z</published>
    <updated>2023-09-30T16:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>與上文類似，對 tinyuz 也進行二次封裝以便上層調用：</p><figure class="highlight c"><figcaption><span>tinyuz_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __tinyuz_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __tinyuz_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUZ_DECOMPRESS_SPACE_SIZE       512*1024            <span class="comment">// 外部存儲中〈差分文件區〉的空間大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TTinyuzResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TINYUZ_SUCCESS=<span class="number">0</span>,</span><br><span class="line">    TINYUZ_OPTIONS_ERROR,</span><br><span class="line">    TINYUZ_OPENREAD_ERROR,</span><br><span class="line">    TINYUZ_OPENWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILEREAD_ERROR,</span><br><span class="line">    TINYUZ_FILEWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILECLOSE_ERROR,</span><br><span class="line">    TINYUZ_MEM_ERROR,</span><br><span class="line">    TINYUZ_COMPRESS_ERROR,</span><br><span class="line">    TINYUZ_DECOMPRESS_ERROR,</span><br><span class="line">&#125; TTinyuzResult;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __tinyuz_port_h__ */</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight c"><figcaption><span>tinyuz_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tinyuz_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuz_dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TTuzListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> hpatch_TStreamInput*  input_file_stream_handle;</span><br><span class="line">    hpatch_StreamPos_t          readPos;</span><br><span class="line">    tuz_TInputStream_read       _do_read_encompress_file;</span><br><span class="line">&#125;TTuzListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從外部flash中以數據流的形式讀取壓縮數據</span></span><br><span class="line">hpatch_BOOL _do_read_encompress_file(<span class="type">const</span> hpatch_TStreamInput* stream, hpatch_StreamPos_t readFromPos, <span class="type">unsigned</span> <span class="type">char</span>* out_data, <span class="type">unsigned</span> <span class="type">char</span>* out_data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> readLen = (<span class="type">size_t</span>)(out_data_end - out_data);</span><br><span class="line">    <span class="keyword">if</span> (readLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> compressed_stream_size = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((readLen &gt; compressed_stream_size) || (readFromPos &gt; compressed_stream_size - readLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, readFromPos, out_data, readLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將解壓數據以數據流的形式寫入外部flash中</span></span><br><span class="line">hpatch_BOOL _do_write_decompress_file(<span class="type">const</span> hpatch_TStreamOutput* stream, hpatch_StreamPos_t writeToPos, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> writeLen = (<span class="type">size_t</span>)(data_end - data);</span><br><span class="line">    <span class="keyword">if</span> (writeLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> write_max_space = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((writeLen &gt; write_max_space)||(writeToPos &gt; write_max_space - writeLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, offset+writeToPos, data, writeLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> tuz_BOOL <span class="title function_">input_file_stream_read_function</span><span class="params">(<span class="type">void</span> *listener, tuz_byte *decompressed_file_stream, <span class="type">tuz_size_t</span> *code_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    TTuzListener *self = (TTuzListener*)listener;</span><br><span class="line">    <span class="type">tuz_size_t</span> r_len = *code_size;</span><br><span class="line">    hpatch_StreamPos_t curReadPos = self-&gt;readPos;</span><br><span class="line">    hpatch_StreamPos_t s_size = self-&gt;input_file_stream_handle-&gt;streamSize - curReadPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_len &gt; s_size)&#123;</span><br><span class="line">        r_len = (<span class="type">tuz_size_t</span>)s_size;</span><br><span class="line">        *code_size = r_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;readPos += r_len;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;input_file_stream_handle-&gt;read(self-&gt;input_file_stream_handle, curReadPos, decompressed_file_stream, decompressed_file_stream + r_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    hpatch_TStreamOutput decompressed_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;decompressed_file_stream_handle,</span><br><span class="line">        .streamSize = TUZ_DECOMPRESS_SPACE_SIZE, <span class="comment">// 外部存儲中〈差分文件區〉的空間大小</span></span><br><span class="line">        .write = _do_write_decompress_file, <span class="comment">// stream write</span></span><br><span class="line">        .read_writed = <span class="literal">NULL</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hpatch_TStreamInput input_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;input_file_stream_handle,</span><br><span class="line">        .streamSize = compressed_file_size, <span class="comment">// 壓縮文件的實際大小</span></span><br><span class="line">        .read = _do_read_encompress_file, <span class="comment">// stream read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TTuzListener listener = &#123;&amp;input_file_stream_handle, <span class="number">0</span>, input_file_stream_read_function&#125;;</span><br><span class="line">    tuz_TStream tuz;</span><br><span class="line">    tuz_TResult result = tuz_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 壓縮的時候會以指定的字典大小進行壓縮｜因此解壓的時候要從壓縮包頭中讀取字典大小</span></span><br><span class="line">    <span class="type">tuz_size_t</span> dictSize = tuz_TStream_read_dict_size(&amp;listener, listener._do_read_encompress_file);</span><br><span class="line"></span><br><span class="line">    tuz_byte* decompress_buf = <span class="number">0</span>;</span><br><span class="line">    cache_size &gt;&gt;= <span class="number">1</span>; <span class="comment">// 除二操作</span></span><br><span class="line">    decompress_buf = (tuz_byte*)tuz_malloc(dictSize + cache_size*<span class="number">2</span>); <span class="comment">// 解壓過程中要用到的臨時空間大小 = 字典大小 + 解壓緩衝區大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decompress_buf == <span class="number">0</span>) <span class="keyword">return</span> TINYUZ_MEM_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tuz_TStream_open 僅僅是用來初始化 tuz 這個勾柄的（tuz後面的參數都是給tuz賦值用的）</span></span><br><span class="line">    result = tuz_TStream_open(&amp;tuz, &amp;listener, listener._do_read_encompress_file, decompress_buf + cache_size, (<span class="type">tuz_size_t</span>)dictSize, (<span class="type">tuz_size_t</span>)cache_size);</span><br><span class="line"></span><br><span class="line">    hpatch_StreamPos_t stream_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (result == tuz_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">tuz_size_t</span> decompress_len = (<span class="type">tuz_size_t</span>)cache_size; <span class="comment">// 給decompress_len賦一個初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解壓一包數據到 decompress_buf 中｜並得到該包長度 decompress_len</span></span><br><span class="line">        result = tuz_TStream_decompress_partial(&amp;tuz, decompress_buf, &amp;decompress_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt;= tuz_STREAM_END)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 將當前解壓的 decompress_buf 中的數據寫到 decompressed_file_stream_handle 數據流中</span></span><br><span class="line">            <span class="keyword">if</span> (decompressed_file_stream_handle.write(&amp;decompressed_file_stream_handle, stream_index, decompress_buf, decompress_buf + decompress_len))</span><br><span class="line">            &#123;</span><br><span class="line">                stream_index += decompress_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tuz_free(decompress_buf);</span><br><span class="line">                <span class="keyword">return</span> TINYUZ_OPENWRITE_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tuz_free(decompress_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;與上文類似，對 tinyuz 也進行二次封裝以便上層調用：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;tinyuz_port.h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifndef&lt;/span&gt; __tinyuz_port_h__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; __tinyuz_port_h__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stddef.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;malloc.h&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; TUZ_DECOMPRESS_SPACE_SIZE       512*1024            &lt;span class=&quot;comment&quot;&gt;// 外部存儲中〈差分文件區〉的空間大小&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; tuz_malloc(x)                   mymalloc(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; tuz_free(x)                     myfree(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TTinyuzResult&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_SUCCESS=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPTIONS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPENREAD_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_OPENWRITE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILEREAD_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILEWRITE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_FILECLOSE_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_MEM_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_COMPRESS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TINYUZ_DECOMPRESS_ERROR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; TTinyuzResult;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;tuz_decompress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; compressed_file_size, &lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt; cache_size)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* __tinyuz_port_h__ */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="壓縮解壓算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%A3%93%E7%B8%AE%E8%A7%A3%E5%A3%93%E7%AE%97%E6%B3%95/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html</id>
    <published>2023-09-30T16:00:06.000Z</published>
    <updated>2023-09-30T16:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近發現了一個優秀的差分還原算法：hdiff &amp; hpatch，它通過數據流的思想把 O(n) 的空間複雜度轉嫁給了硬盤，使得內存的開銷極低，非常適合應用於嵌入式領域。</p><p><img src="/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff-tools-compare.png"></p><span id="more"></span><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="hpatchlite"><a href="#hpatchlite" class="headerlink" title="hpatchlite"></a>hpatchlite</h3><p>時間複雜度：O(oldSize+newSize)<br>空間複雜度：O(1)<br>　　還原代碼開銷｜ROM &#x3D; 876 字節 (compiled by armcc v5.06 update4 build 422)<br>　　還原內存開銷｜RAM &#x3D; 還原緩衝大小 + 解壓內存開銷</p><p>注：還原緩衝大小在還原時指定，至少3個字節，還原緩衝越小還原得越慢。</p><h3 id="tinyuz"><a href="#tinyuz" class="headerlink" title="tinyuz"></a>tinyuz</h3><p>時間複雜度：O(oldSize+newSize)<br>空間複雜度：O(1)<br>　　解壓代碼開銷｜流模式｜ROM &#x3D; 1142 字節 (compiled by armcc v5.06 update4 build 422)<br>　　解壓內存開銷｜流模式｜RAM &#x3D; 壓縮字典大小 + 解壓緩衝大小</p><p>注：壓縮字典大小在壓縮時指定，至少1個字節，壓縮字典越小壓縮率越低。<br>注：解壓緩衝大小在解壓時指定，至少2個字節，解壓緩衝越小解壓縮越慢。</p><h3 id="appendix"><a href="#appendix" class="headerlink" title="appendix"></a>appendix</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 876          0          0          0          0      10783   hpatch_lite.o</span><br><span class="line">1142          0          0          0          0      13541   tuz_dec.o</span><br><span class="line"></span><br><span class="line"> 626         80          0         12          0      12256   hpatch_user.o</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">244           0          0          0          0       2146   bspatch.o</span><br><span class="line">586           6         64          0          0       6749   quicklz.o</span><br><span class="line"></span><br><span class="line">102           4          8          0          0       2821   bspatch_user.o</span><br><span class="line"> 52           0          0          0          0       2096   quicklz_user.o</span><br></pre></td></tr></table></figure><h2 id="移植說明"><a href="#移植說明" class="headerlink" title="移植說明"></a>移植說明</h2><p>將 hdiffpatch.hpatchlite &amp; tinyuz 移植至單片機 bare metal 裸機系統（based on hdiffpatch v4）</p><h3 id="拿來"><a href="#拿來" class="headerlink" title="拿來"></a>拿來</h3><p>將 tinyuz&#x2F;decompress 目錄拷貝至目標工程中。</p><p>將 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatch 目錄拷貝至目標工程中。</p><p>將 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatchLite 目錄拷貝至目標工程中。</p><p>將 HPatchLite&#x2F;decompresser_demo.h 文件拷貝至目標工程中。</p><h3 id="畫瓢"><a href="#畫瓢" class="headerlink" title="畫瓢"></a>畫瓢</h3><p>依 HPatchLite&#x2F;hpatchi.c&#x2F;hpatchi() 函數畫瓢：移植還原功能</p><p>依 tinyuz&#x2F;tinyuz_demo.cpp&#x2F;_tuz_decompress_stream() 函數畫瓢：移植解壓功能</p><p>done!</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿來依葫蘆畫瓢，說得簡單，做起來着實還是費了點功夫，這幾年搞嵌入式搞得有些侷限了，面對句(gōu)柄這種用法竟感覺無從下手。😅</p><p>作者提供了以下兩個接口函數：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpatch_lite_open()</span><br><span class="line"></span><br><span class="line">hpatch_lite_patch()</span><br></pre></td></tr></table></figure><p>看着挺簡單的吧，然而他實際上是這樣的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hpatch_lite by stream: hpatch_lite_open()+hpatch_lite_patch() compiled by Mbed Studio is 662 bytes</span></span><br><span class="line"><span class="comment">//   hdiffpatch v4.2.3, other patcher compiled by Mbed Studio:</span></span><br><span class="line"><span class="comment">//      patch_single_stream() 2356 bytes (hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"><span class="comment">//      patch_decompress_with_cache() 2846 bytes (_IS_NEED_CACHE_OLD_BY_COVERS=0,hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//diff_data must created by create_lite_diff()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span>&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    <span class="comment">//must read data_size data to out_data, from read_from_pos of stream; if read error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    <span class="comment">//must write data_size data to sequence stream; if write error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hpatch_lite open</span></span><br><span class="line"><span class="comment">// read lite headinfo from diff_data</span></span><br><span class="line"><span class="comment">// if diff_data uncompress(*out_compress_type==hpi_compressType_no), *out_uncompressSize==0;</span></span><br><span class="line"><span class="comment">// if (*out_compress_type!=hpi_compressType_no), you need open compressed data by decompresser</span></span><br><span class="line"><span class="comment">//      (see https://github.com/sisong/HPatchLite/decompresser_demo.h &amp; https://github.com/sisong/HPatchLite/hpatchi.c)</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,</span></span><br><span class="line"><span class="params">                          hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br><span class="line"><span class="comment">//hpatch_lite patch</span></span><br><span class="line"><span class="comment">//used temp_cache_size memory + &#123;decompress buffer*1&#125;</span></span><br><span class="line"><span class="comment">//  note: temp_cache_size&gt;=hpi_kMinCacheSize</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,</span></span><br><span class="line"><span class="params">                           hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure><p>試着分析一下：</p><p><strong>差分包頭信息讀取接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分包頭信息讀取接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStreamHandle        diff_data           注意此處入參：差分數據流句柄（個人理解：如果不需要該句柄的話可以將其定義爲空指針）</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStream_read         read_diff           注意此處入參：差分數據流讀取函數（用戶實現：以數據流的方式讀取外部存儲中差分數據分區的數據）</span></span><br><span class="line"><span class="comment"> * @param hpi_compressType             *out_compress_type   差分包頭信息：差分包壓縮類型</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_newSize         差分包頭信息：還原數據的長度</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_uncompressSize  差分包頭信息：解壓之後的長度（如果差分包未被壓縮則*out_uncompressSize輸出0）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br></pre></td></tr></table></figure><p><strong>差分包頭定義</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_kHeadSize (2+1+1) <span class="comment">//&quot;hI&quot; + hpi_compressType + (versionCode + newSize_Bytes + uncompressSize_Bytes) &#123; + newSize + uncompressSize&#125; &#123; + dictSize&#125;</span></span></span><br><span class="line">差分包頭[<span class="number">0</span>] : 魔術數字 <span class="number">68</span> <span class="string">&#x27;h&#x27;</span></span><br><span class="line">差分包頭[<span class="number">1</span>] : 魔術數字 <span class="number">49</span> <span class="string">&#x27;I&#x27;</span></span><br><span class="line">差分包頭[<span class="number">2</span>] : 壓縮類型</span><br><span class="line">差分包頭[<span class="number">3</span>] : 版本代碼[<span class="number">7</span>:<span class="number">6</span>]+解壓數據長度所佔的字節數u[<span class="number">5</span>:<span class="number">3</span>]+還原數據長度所佔的字節數n[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">差分包頭[<span class="number">4</span> ~ <span class="number">4</span>+n] : 還原數據長度</span><br><span class="line">差分包頭[? ~ ?+u] : 解壓數據長度</span><br><span class="line"></span><br><span class="line">壓縮包頭[? ~ ?+<span class="number">4</span>] : 壓縮字典大小</span><br></pre></td></tr></table></figure><p><strong>差分還原接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分還原接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpatchi_listener_t            listener            詳見 hpatchi_listener_t 分析</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                     newSize             還原數據的長度</span></span><br><span class="line"><span class="comment"> * @param hpi_byte                     *temp_cache          還原緩衝的地址</span></span><br><span class="line"><span class="comment"> * @param hpi_size_t                    temp_cache_size     還原緩衝的大小（&gt;=2）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t 實例（差分包未經壓縮）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 差分數據流句柄,</span><br><span class="line">    .read_diff = 差分數據流讀取函數,    由用戶去實現（從外部存儲的差分數據分區讀取）（函數一）</span><br><span class="line"></span><br><span class="line">    .read_old  = 舊版數據流讀取函數,    由用戶去實現（從內部存儲的舊版程序分區讀取）（函數二）</span><br><span class="line">    .write_new = 還原數據流寫入函數,    由用戶去實現（寫入到外部存儲的還原程序分區）（函數三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>hpatchi_listener_t 實例（差分包經過壓縮）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tuz_TStream _tuz_stream = <span class="comment">/* 壓縮數據流句柄 */</span></span><br><span class="line">&#123;</span><br><span class="line">    .in_Stream = 差分數據流句柄,</span><br><span class="line">    .read_code = 差分數據流讀取函數,    由用戶去實現（從外部存儲的差分數據分區讀取）（函數一）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 壓縮數據流句柄,        _tuz_stream</span><br><span class="line">    .read_diff = 壓縮數據流解壓函數,    _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line"></span><br><span class="line">    .read_old  = 舊版數據流讀取函數,    由用戶去實現（從內部存儲的舊版程序分區讀取）（函數二）</span><br><span class="line">    .write_new = 還原數據流寫入函數,    由用戶去實現（寫入到外部存儲的還原程序分區）（函數三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最後需要特別注意的一點是：差分包必須由 create_lite_diff() 函數創建。宏觀上來說就是差分包必須要通過 hdiffi.exe 程序生成，不能使用 hdiffz.exe 生成。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpi_BOOL 差分數據流讀取函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 舊版數據流讀取函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 還原數據流寫入函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根據 hpatch_lite_open() + hpatch_lite_patch() 編寫的還原程序</span></span><br><span class="line"><span class="type">hpi_patch_result_t</span> <span class="title function_">hpi_patch</span><span class="params">(接收到的差分包大小, “還原緩衝大小”, “解壓緩衝大小”)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 差分數據流句柄：如果不需要該句柄的話可以將其定義爲空指針</span></span><br><span class="line">    hpatch_lite_open(“差分數據流句柄”, “差分數據流讀取函數”, 輸出“差分包信息”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    解壓緩衝地址 = <span class="built_in">malloc</span>();</span><br><span class="line">    解壓字典大小 = _tuz_TStream_getReservedMemSize(“差分數據流句柄”, “差分數據流讀取函數”);</span><br><span class="line">    tuz_TStream_open(_tuz_stream, “差分數據流句柄”, “差分數據流讀取函數”, “解壓緩衝地址”, “解壓字典大小”, “解壓緩衝大小”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    patch_listener</span><br><span class="line">        .diff_data = _tuz_stream</span><br><span class="line">        .read_diff = _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line">        .read_old  = 舊版數據流讀取函數()</span><br><span class="line">        .write_new = 還原數據流寫入函數()</span><br><span class="line"></span><br><span class="line">    還原緩衝地址 = <span class="built_in">malloc</span>();</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(“patch_listener”, “還原數據期望長度”, “還原緩衝地址”, “還原緩衝大小”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源碼"><a href="#源碼" class="headerlink" title="源碼"></a>源碼</h3><figure class="highlight c"><figcaption><span>hpatch_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __hpatch_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __hpatch_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span>; <span class="comment">// (差分文件的大小, 差分緩衝大小, 解壓緩衝大小)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __hpatch_port_h__ */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>hpatch_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_lite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decompresser_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從外部flash中以數據流的形式讀取差分數據（由用戶記錄數據流的位置：讀到哪兒了）（數據流結束時需要將 *data_size 置爲當前所讀數據的實際長度）（*data_size == decompress_cache_size）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_diff(hpi_TInputStreamHandle input_stream, hpi_byte *data, <span class="type">hpi_size_t</span> *data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="keyword">if</span> ((patch_file_rxd_pos + *data_size) &gt; patch_file_len)</span><br><span class="line">    &#123;</span><br><span class="line">        *data_size = patch_file_len - patch_file_rxd_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, offset+patch_file_rxd_pos, data, *data_size);</span><br><span class="line">    patch_file_rxd_pos += *data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從內部flash中以數據流的形式讀取舊版程序</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_old(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">hpi_pos_t</span> read_pos, hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_older&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, read_pos, data, data_size);</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將還原數據以數據流的形式寫入外部flash中（由用戶記錄數據流的位置：寫到哪兒了）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_write_new(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">const</span> hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, newer_file_txd_pos, data, data_size);</span><br><span class="line">    newer_file_txd_pos += data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* pmem = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* patch_cache;</span><br><span class="line"></span><br><span class="line">    patch_file_len = diff_file_size;</span><br><span class="line">    patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line">    newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hpi_TInputStreamHandle  void_stream_handle = <span class="literal">NULL</span>;</span><br><span class="line">    hpi_TInputStream_read   diff_stream_read = _do_read_diff;</span><br><span class="line">    hpi_compressType        compress_type;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               new_size;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               uncompress_size;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_open(void_stream_handle, diff_stream_read, &amp;compress_type, &amp;new_size, &amp;uncompress_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">hpatchi_listener_t</span> listener;</span><br><span class="line">    listener.read_old  = _do_read_old;</span><br><span class="line">    listener.write_new = _do_write_new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (compress_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_no:  <span class="comment">// memory size: patch_cache_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(patch_cache_size);</span><br><span class="line">            patch_cache = pmem;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = void_stream_handle;</span><br><span class="line">            listener.read_diff = diff_stream_read;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _CompressPlugin_tuz</span></span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_tuz:  <span class="comment">// requirements memory size: patch_cache_size + decompress_cache_size + decompress_dict_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            tuz_TStream tuz_stream_handle;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> decompress_dict_size  = _tuz_TStream_getReservedMemSize(void_stream_handle, diff_stream_read);</span><br><span class="line"></span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(decompress_dict_size + decompress_cache_size + patch_cache_size);</span><br><span class="line"></span><br><span class="line">            tuz_TStream_open(&amp;tuz_stream_handle, void_stream_handle, diff_stream_read, pmem, (<span class="type">tuz_size_t</span>)decompress_dict_size, (<span class="type">tuz_size_t</span>)decompress_cache_size);</span><br><span class="line"></span><br><span class="line">            patch_cache = pmem + decompress_dict_size + decompress_cache_size;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = &amp;tuz_stream_handle;</span><br><span class="line">            listener.read_diff = _tuz_TStream_decompress;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> clear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(&amp;listener, new_size, patch_cache, (<span class="type">hpi_size_t</span>)patch_cache_size);</span><br><span class="line"></span><br><span class="line">clear:</span><br><span class="line">    <span class="keyword">if</span> (pmem) &#123; hpi_free(pmem); pmem=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>爲了使代碼看起來更加簡潔，因此例程中沒有進行任何異常處理。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近發現了一個優秀的差分還原算法：hdiff &amp;amp; hpatch，它通過數據流的思想把 O(n) 的空間複雜度轉嫁給了硬盤，使得內存的開銷極低，非常適合應用於嵌入式領域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff-tools-compare.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
    <category term="差分還原算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B7%AE%E5%88%86%E9%82%84%E5%8E%9F%E7%AE%97%E6%B3%95/"/>
    
    <category term="增量升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%A2%9E%E9%87%8F%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#05）增量升級</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html</id>
    <published>2023-09-30T16:00:05.000Z</published>
    <updated>2023-09-30T16:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>全量升級由於要傳輸新版程序的完整鏡像，因此升級時間通常較長，升級失敗的概率也更大。那麼能不能只傳送差異數據呢？答案是可以。這種技術被稱作增量升級&#x2F;差量升級&#x2F;差分升級。</p><p>常見的方案有：</p><ul><li>bsdiff&#x2F;bspatch + quicklz</li><li>hdifflite&#x2F;hpatchlite + tinyuz</li></ul><div class="note info no-icon"><p>不過 bsdiff + quicklz 方案的內存開銷太大，因此不建議使用。</p></div><h2 id="全量升級-amp-增量升級"><a href="#全量升級-amp-增量升級" class="headerlink" title="全量升級 &amp; 增量升級"></a>全量升級 &amp; 增量升級</h2><p>增量升級確實降低了傳輸過程中的數據量，但也帶來了版本管理複雜的問題，所以說不能因爲有了增量升級，全量升級就不用了。</p><p>以往我們做全量升級的時候沒有引入壓縮技術，在移植 hdiff&#x2F;hpatchlite 的時候我發現，hdiff 生成的差異文件不比原文件小多少，但是其可壓縮性非常高，這樣就得把解壓算法也移植進來。既然解壓算法都已經有了，不把增量升級也壓縮一下，那豈不是很浪費？</p><table><tbody><tr>    <td align="center" rowspan="2">全量升級</td>    <td align="center">未經壓縮的新版程序</td>    <td align="center">（✘）</td></tr><tr>    <td align="center">經過壓縮的新版程序</td>    <td align="center">（✔）</td></tr><tr>    <td align="center" rowspan="2">增量升級</td>    <td align="center">未經壓縮的差異文件</td>    <td align="center">（✘）</td></tr><tr>    <td align="center">經過壓縮的差異文件</td>    <td align="center">（✔）</td></tr></tbody></table><span id="more"></span><h2 id="升級包頭"><a href="#升級包頭" class="headerlink" title="升級包頭"></a>升級包頭</h2><p>在線升級無非就是把新程序或者更新補丁發送給設備，設備收到後進行升級的過程。</p><p>爲了保證升級能夠順利進行，除了新程序或者更新補丁外，我們還要向設備發送一些附加信息，這些附加信息通常被添加至升級文件的頭部。</p><table><tbody><tr>    <td align="center">魔術數字</td>    <td align="center">04B</td>    <td align="center">全量升級 ('Q','L','S','J')<br>增量升級 ('Z','L','S','J')</td></tr><tr>    <td align="center">包頭長度</td>    <td align="center">04B</td>    <td align="center">支持變長包頭 *</td></tr><tr>    <td align="center">文件摘要</td>    <td align="center">04B</td>    <td align="center">從「文件長度」之後開始計算</td></tr><tr>    <td align="center">文件長度</td>    <td align="center">04B</td>    <td align="center">從「文件長度」之後開始計算</td></tr><tr>    <td align="center">　</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">產品型號</td>    <td align="center">08B</td>    <td align="center">產品一型 ('P','N','-','A','0','0','0','1')<br>產品二型 ('P','N','-','A','0','0','0','2')</td></tr><tr>    <td align="center">設備地址</td>    <td align="center">08B</td>    <td align="center">通配地址 (0xFFFFFFFFFFFFFFFF)<br>單點地址 (0x1111111111111111)</td></tr><tr>    <td align="center">　</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">新程序 LEN 值</td>    <td align="center">04B</td>    <td align="center" rowspan="6">對舊程序進行摘要值校驗<br>或者<br>對舊程序進行差分還原時<br><br>某些可變字段必須以默認值進行處理</td></tr><tr>    <td align="center">舊程序 LEN 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">新程序 CRC 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">舊程序 CRC 值</td>    <td align="center">04B</td></tr><tr>    <td align="center">新程序 MD5 值</td>    <td align="center">16B</td></tr><tr>    <td align="center">舊程序 MD5 值</td>    <td align="center">16B</td></tr><tr>    <td align="center">......</td>    <td align="center"></td>    <td align="center"></td></tr><tr>    <td align="center">可以按需增加</td>    <td align="center"></td>    <td align="center"></td></tr></tbody></table><p><strong>變長包頭的優勢</strong></p><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.head.scalable.png"></p><div class="note info no-icon"><p>升級包頭我建議做成變長的，萬一哪天包頭長度不夠用了，擴展後也能兼容現場的老設備。</p></div><h2 id="升級文件"><a href="#升級文件" class="headerlink" title="升級文件"></a>升級文件</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.1.raw.full.png" alt="未經壓縮的全量升級文件結構"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.2.zip.full.png" alt="經過壓縮的全量升級文件結構"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.4.zip.diff.png" alt="經過壓縮的增量升級文件結構"></div></div></div><h2 id="升級方案"><a href="#升級方案" class="headerlink" title="升級方案"></a>升級方案</h2><h3 id="未經壓縮的全量升級-經過壓縮的增量升級"><a href="#未經壓縮的全量升級-經過壓縮的增量升級" class="headerlink" title="未經壓縮的全量升級 + 經過壓縮的增量升級"></a>未經壓縮的全量升級 + 經過壓縮的增量升級</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.1.raw.full+zip.diff.png"></p><h3 id="經過壓縮的全量升級-經過壓縮的增量升級"><a href="#經過壓縮的全量升級-經過壓縮的增量升級" class="headerlink" title="經過壓縮的全量升級 + 經過壓縮的增量升級"></a>經過壓縮的全量升級 + 經過壓縮的增量升級</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.2.zip.full+zip.diff.png"></p><h2 id="升級流程"><a href="#升級流程" class="headerlink" title="升級流程"></a>升級流程</h2><h3 id="接收升級數據"><a href="#接收升級數據" class="headerlink" title="接收升級數據"></a>接收升級數據</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%Start(接收升級數據&lt;br&gt;開始)--&gt;DoRecv[接收數據]--&gt;IsHeadRecvDone{文件頭接收完畢}IsHeadRecvDone--否&#x2F;繼續接收--&gt;DoRecvIsHeadRecvDone--是--&gt;IsHeadParsed{文件頭已被處理}IsHeadParsed--是----&gt;DoWrite[將接收到的數據寫入外存&lt;br&gt;如果爲「壓縮增量升級」則將數據寫入〈升級數據存儲區〉&lt;br&gt;如果爲「壓縮全量升級」則將數據寫入〈升級數據存儲區〉&lt;br&gt;如果爲「原版全量升級」則將數據寫入〈新版程序存儲區〉&lt;br&gt;（如果小程序爲舊版本則寫入時偏移75字節）]--&gt;IsFileRecvOver{文件傳輸完畢}IsFileRecvOver--否&#x2F;繼續接收--&gt;DoRecv2[繼續接收數據]IsFileRecvOver--是--&gt;DoCheck[校驗接收到的升級文件&lt;br&gt;如果爲「壓縮增量升級」則從〈升級數據存儲區〉中讀出數據並計算CRC值&lt;br&gt;如果爲「壓縮全量升級」則從〈升級數據存儲區〉中讀出數據並計算CRC值&lt;br&gt;如果爲「原版全量升級」則從〈新版程序存儲區〉中讀出數據並計算CRC值&lt;br&gt;（如果小程序爲舊版本則讀取時偏移75字節）]--&gt;IsCheckOK{校驗是否通過}IsCheckOK--否--&gt;Over3(結束)IsCheckOK--是--&gt;DoWriteHead[將文件頭中的某些數據寫入外存的第一個扇區&lt;br&gt;（如果小程序爲舊版本則將“新程序大小”加75字節）]--&gt;DoWriteHeadFlag[將該扇區中的升級標識從0xFFFFFFFF改成0xAABBFFFF]--&gt;IsA{增量升級}IsA--是--&gt;DoSetA[發起增量升級任務]--&gt;Over4(結束)IsA--否--&gt;IsB{有壓縮的&lt;br&gt;全量升級}IsB--是--&gt;DoSetB[發起全量升級任務]--&gt;Over4(結束)IsB--否--&gt;IsC{無壓縮的&lt;br&gt;全量升級}IsC--是--&gt;DoSetC[發起全量升級任務]--&gt;Over4(結束)IsC--否--&gt;Over5(結束)IsHeadParsed--否--&gt;IsHeadOK{文件頭格式正確}IsHeadOK--否--&gt;Over1(結束)IsHeadOK--是--&gt;IsDiffUpdate{是否爲增量升級}IsDiffUpdate--否&#x2F;繼續接收--&gt;DoRecvIsDiffUpdate--是--&gt;IsCRCOK{文件頭中的舊程序CRC與&lt;br&gt;當前程序的CRC是否一致}IsCRCOK--（當前程序中的可變字段以默認值進行處理）&lt;br&gt;&lt;br&gt;不一致--&gt;Over2(結束)IsCRCOK--是&#x2F;繼續接收--&gt;DoRecv</pre><h3 id="執行升級任務"><a href="#執行升級任務" class="headerlink" title="執行升級任務"></a>執行升級任務</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%Start(執行升級任務&lt;br&gt;開始)--&gt;IsUpdateFlag{升級文件接收完畢}IsUpdateFlag--否--&gt;IsUpdateFlagIsUpdateFlag--是--&gt;DoReadHead[從外存的第一個扇區中讀取升級信息]--&gt;IsReadSucc{讀取成功}IsReadSucc--否--&gt;Over1(結束)IsReadSucc--是--&gt;IsUpdateFlagIsDownload{升級標識&#x3D;&#x3D;0xAABBFFFF}IsUpdateFlagIsDownload--否--&gt;Over2(結束)IsUpdateFlagIsDownload--是--&gt;IsUpdateTypeIsZipDiff{是否爲壓縮增量升級}IsUpdateTypeIsZipDiff--是--&gt;DoUnDiff[執行差分還原操作]--如果小程序爲舊版本&lt;br&gt;則寫入時偏移75字節&lt;br&gt;當前程序中的可變字段以默認值進行處理---&gt;DoCheckNewAppCRCIsUpdateTypeIsZipDiff--否--&gt;IsUpdateTypeIsZipFull{是否爲壓縮全量升級}IsUpdateTypeIsZipFull--是--&gt;DoUnZip[執行文件解壓操作]--如果小程序爲舊版本&lt;br&gt;則寫入時偏移75字節---&gt;DoCheckNewAppCRCIsUpdateTypeIsZipFull--否--&gt;IsUpdateTypeIsRawFull{是否爲原版全量升級}IsUpdateTypeIsRawFull--是--&gt;DoNothing[無需執行任何操作]---&gt;DoCheckNewAppCRC[校驗新程序&lt;br&gt;對比文件頭中的新程序CRC與&lt;br&gt;新程序存儲區中的數據的CRC]IsUpdateTypeIsRawFull--否--&gt;Over3(結束)DoCheckNewAppCRC--如果小程序爲舊版本&lt;br&gt;則讀取時偏移75字節---&gt;IsCRCCheckOK{CRC是否一致}IsCRCCheckOK--否--&gt;Over4(結束)IsCRCCheckOK--是--&gt;DoChangeUpdateFlag[將外存中的升級標識從0xAABBFFFF改爲0xAABBCCDD]--&gt;IsChangeSucc{修改是否成功}IsChangeSucc--否--&gt;Over5(結束)IsChangeSucc--是--&gt;DoChangeInternalFlashUpdateFlag[將內部flash中的0xAABBCCDD改成0x0000CCDD]--&gt;DoReset[一秒後重啓進入引導程序]--&gt;OverX(結束)</pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;全量升級由於要傳輸新版程序的完整鏡像，因此升級時間通常較長，升級失敗的概率也更大。那麼能不能只傳送差異數據呢？答案是可以。這種技術被稱作增量升級&amp;#x2F;差量升級&amp;#x2F;差分升級。&lt;/p&gt;
&lt;p&gt;常見的方案有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bsdiff&amp;#x2F;bspatch + quicklz&lt;/li&gt;
&lt;li&gt;hdifflite&amp;#x2F;hpatchlite + tinyuz&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;不過 bsdiff + quicklz 方案的內存開銷太大，因此不建議使用。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;全量升級-amp-增量升級&quot;&gt;&lt;a href=&quot;#全量升級-amp-增量升級&quot; class=&quot;headerlink&quot; title=&quot;全量升級 &amp;amp; 增量升級&quot;&gt;&lt;/a&gt;全量升級 &amp;amp; 增量升級&lt;/h2&gt;&lt;p&gt;增量升級確實降低了傳輸過程中的數據量，但也帶來了版本管理複雜的問題，所以說不能因爲有了增量升級，全量升級就不用了。&lt;/p&gt;
&lt;p&gt;以往我們做全量升級的時候沒有引入壓縮技術，在移植 hdiff&amp;#x2F;hpatchlite 的時候我發現，hdiff 生成的差異文件不比原文件小多少，但是其可壓縮性非常高，這樣就得把解壓算法也移植進來。既然解壓算法都已經有了，不把增量升級也壓縮一下，那豈不是很浪費？&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot; rowspan=&quot;2&quot;&gt;全量升級&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;未經壓縮的新版程序&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot;&gt;經過壓縮的新版程序&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✔）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot; rowspan=&quot;2&quot;&gt;增量升級&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;未經壓縮的差異文件&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✘）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td align=&quot;center&quot;&gt;經過壓縮的差異文件&lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;（✔）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#04）技術細節</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html</id>
    <published>2023-09-30T16:00:04.000Z</published>
    <updated>2023-09-30T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>分散加載、中斷向量表重定向</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#03）流程設計</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html</id>
    <published>2023-09-30T16:00:03.000Z</published>
    <updated>2023-09-30T16:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A1(引導程序之流程)--&gt;B1(......)--&gt;C1(跳轉至應用程序)A2(應用程序之流程)--&gt;B2(......)--&gt;C2(跳轉至引導程序)</pre><span id="more"></span><h2 id="引導程序流程"><a href="#引導程序流程" class="headerlink" title="引導程序流程"></a>引導程序流程</h2><p>引導程序的設計方案我知道有兩種：</p><ul><li>立即跳轉方案</li><li>延時跳轉方案</li></ul><p>立即跳轉方案在判斷出應用程序有效之後會立即執行跳轉操作，該方案適用於對啓動時間要求比較高的產品。延時跳轉方案則是先在引導程序中等待一段時間，在這段時間內如果沒有任何請求則時間到了之後會自動跳轉至應用程序，否則將停留在引導程序中。</p><h3 id="立即跳轉方案"><a href="#立即跳轉方案" class="headerlink" title="立即跳轉方案"></a>立即跳轉方案</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%PowerReset(設備上電覆位)--&gt;IapStart(引導程序開始)--&gt;IapCheckApp[檢查應用程序有效標識]--&gt;IapIsAppValid{是否有效}IapIsAppValid--是--&gt;IapJumpToApp[跳轉進入應用程序]--&gt;IapOver(引導程序結束)IapIsAppValid--否--&gt;IapRemap[重定向中斷向量表]--&gt;IapInit[配置相關外設]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升級數據}IapIsHaveUpdateData--否--&gt;IapBeforeJumpIapIsHaveUpdateData--是--&gt;IapDoUpdate[執行升級操作]---&gt;IapEraseUpdateData[擦除升級數據]--&gt;IapIsUpdateSucc{升級成功}IapIsUpdateSucc--是---&gt;IapSetAppValid[修改應用程序有效標識：有效]--&gt;IapBeforeJump[關閉外設和中斷]--&gt;IapJumpToAppIapIsUpdateSucc--否--&gt;IapIsAppErased{應用程序已損毀}IapIsAppErased--否--&gt;IapBeforeJumpIapIsAppErased--是&lt;br&gt;留在引導程序中--&gt;IapComm[執行通信任務]--&gt;IapIsRecvDone{收到升級數據}IapIsRecvDone--否--&gt;IapCommIapIsRecvDone--是--&gt;IapDoUpdate</pre><h3 id="延時跳轉方案"><a href="#延時跳轉方案" class="headerlink" title="延時跳轉方案"></a>延時跳轉方案</h3><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%PowerReset(設備上電覆位)--&gt;IapStart(引導程序開始)--&gt;IapCheckApp[檢查應用程序有效標識]--&gt;IapIsAppValid{是否有效}IapIsAppValid--是--&gt;IapWait{計數超時&lt;br&gt;（延時跳轉）}IapWait--否--&gt;IapWaitIapWait--是----------&gt;IapJumpToApp[跳轉進入應用程序]--&gt;IapOver(引導程序結束)IapIsAppValid--否--&gt;IapRemap[重定向中斷向量表]--&gt;IapInit[配置相關外設]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升級數據}IapIsHaveUpdateData--否--&gt;IapBeforeJumpIapIsHaveUpdateData--是--&gt;IapDoUpdate[執行升級操作]---&gt;IapEraseUpdateData[擦除升級數據]--&gt;IapIsUpdateSucc{升級成功}IapIsUpdateSucc--是---&gt;IapSetAppValid[修改應用程序有效標識：有效]--&gt;IapBeforeJump[關閉外設和中斷]--&gt;IapJumpToAppIapIsUpdateSucc--否--&gt;IapIsAppErased{應用程序已損毀}IapIsAppErased--否--&gt;IapBeforeJumpIapIsAppErased--是&lt;br&gt;留在引導程序中--&gt;IapComm[執行通信任務]--&gt;IapIsRecvDone{收到升級數據}IapIsRecvDone--否--&gt;IapCommIapIsRecvDone--是--&gt;IapDoUpdate</pre><h2 id="應用程序流程"><a href="#應用程序流程" class="headerlink" title="應用程序流程"></a>應用程序流程</h2><pre class="mermaid">flowchart TB%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%AppStart(應用程序開始)--&gt;AppRemap[重定向中斷向量表]--&gt;AppInit[配置相關外設]--&gt;AppTask[執行應用功能]--&gt;AppComm[執行通信任務]--&gt;AppIsRecvDone{收到升級數據}AppIsRecvDone--否--&gt;AppTaskAppIsRecvDone--是--&gt;AppSetAppInvalid[修改應用程序有效標識：無效]--&gt;AppBeforeJump[關閉外設和中斷]--&gt;AppJumpToIap[重啓進入引導程序｜跳轉進入引導程序]--&gt;AppOver(應用程序結束)</pre>]]></content>
    
    
    <summary type="html">&lt;pre class=&quot;mermaid&quot;&gt;
flowchart TB
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A1(引導程序之流程)--&amp;gt;B1(......)--&amp;gt;C1(跳轉至應用程序)
A2(應用程序之流程)--&amp;gt;B2(......)--&amp;gt;C2(跳轉至引導程序)
&lt;/pre&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#02）升級方案</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html</id>
    <published>2023-09-30T16:00:02.000Z</published>
    <updated>2023-09-30T16:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<center>which one is better?</center><br><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(在引導程序中集成通信協議棧與解壓還原算法)~~~B(在應用程序中集成通信協議棧與解壓還原算法)</pre><span id="more"></span><h2 id="思路（-1）：引導程序主導"><a href="#思路（-1）：引導程序主導" class="headerlink" title="思路（#1）：引導程序主導"></a>思路（#1）：引導程序主導</h2><table><thead><tr><th align="center">具體分工</th><th align="center">引導程序</th><th align="center">應用程序</th></tr></thead><tbody><tr><td align="center">編程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信協議</td><td align="center">完備的通信協議棧</td><td align="center">　　　　　　　　</td></tr><tr><td align="center">文件解壓</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">差分還原</td><td align="center">✔</td><td align="center"></td></tr></tbody></table><div class="note success no-icon"><p><strong>優點</strong>：設備中沒有應用程序或應用程序異常時也可以進行 IAP 升級。</p></div><div class="note danger no-icon"><p><strong>缺點</strong>：在引導程序中集成通信協議棧、文件解壓、差分還原等功能，會導致其代碼量較大。</p></div><h2 id="思路（-2）：應用程序主導"><a href="#思路（-2）：應用程序主導" class="headerlink" title="思路（#2）：應用程序主導"></a>思路（#2）：應用程序主導</h2><table><thead><tr><th align="center">具體分工</th><th align="center">引導程序</th><th align="center">應用程序</th></tr></thead><tbody><tr><td align="center">編程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信協議</td><td align="center">　　　　　　　　</td><td align="center">完備的通信協議棧</td></tr><tr><td align="center">文件解壓</td><td align="center"></td><td align="center">✔</td></tr><tr><td align="center">差分還原</td><td align="center"></td><td align="center">✔</td></tr></tbody></table><div class="note success no-icon"><p><strong>優點</strong>：引導程序比較簡單，佔用空間小，方便維護。</p></div><div class="note danger no-icon"><p><strong>缺點</strong>：設備中沒有應用程序或應用程序異常時無法進行 IAP 升級。</p></div><h2 id="思路（-3）：兩者各取所長"><a href="#思路（-3）：兩者各取所長" class="headerlink" title="思路（#3）：兩者各取所長"></a>思路（#3）：兩者各取所長</h2><table><thead><tr><th align="center">具體分工</th><th align="center">引導程序</th><th align="center">應用程序</th></tr></thead><tbody><tr><td align="center">編程操作</td><td align="center">✔</td><td align="center"></td></tr><tr><td align="center">通信協議</td><td align="center">基礎的通信協議棧</td><td align="center">完備的通信協議棧</td></tr><tr><td align="center">文件解壓</td><td align="center"></td><td align="center">✔</td></tr><tr><td align="center">差分還原</td><td align="center"></td><td align="center">✔</td></tr></tbody></table><div class="note success no-icon"><p><strong>特點</strong>：在引導程序中集成基礎的通信協議棧，代碼量能接受，應用程序異常時也能在線升級。</p></div><div class="note success no-icon"><p><strong>特點</strong>：在應用程序中集成完整的通信協議棧、文件解壓、差分還原等功能，功能完備。</p></div><h2 id="方案（-0）"><a href="#方案（-0）" class="headerlink" title="方案（#0）"></a>方案（#0）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除應用程序存儲區，然後等待接收新版應用程序（直接寫入到升級文件存儲區），等接收完畢且校驗無誤後跳轉至應用程序，至此升級完成。</p><h2 id="方案（-1）"><a href="#方案（-1）" class="headerlink" title="方案（#1）"></a>方案（#1）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><p>或</p><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody><thead><tr><th align="center">外部flash存儲空間劃分</th><th align="center">外部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr></tbody></table><h3 id="思路（-1）"><a href="#思路（-1）" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除舊版應用程序，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><h3 id="思路（-2）"><a href="#思路（-2）" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至新版程序存儲區，重啓進入或跳轉進入引導程序。進入引導程序後對新版程序進行二次校驗，校驗通過後擦除舊版應用程序，然後將新版程序存儲區中的新版應用程序拷貝至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><h3 id="思路（-3）"><a href="#思路（-3）" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至新版程序存儲區，重啓進入或跳轉進入引導程序。進入引導程序後對新版程序進行二次校驗，校驗通過後擦除舊版應用程序，然後將新版程序存儲區中的新版應用程序拷貝至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除舊版應用程序，然後將升級文件存儲區中的新版應用程序拷貝（不支持解壓和差分還原）至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p><h2 id="方案（-2）"><a href="#方案（-2）" class="headerlink" title="方案（#2）"></a>方案（#2）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><h3 id="思路（-1）-1"><a href="#思路（-1）-1" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-2）-1"><a href="#思路（-2）-1" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-3）-1"><a href="#思路（-3）-1" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p><h2 id="方案（-3）"><a href="#方案（-3）" class="headerlink" title="方案（#3）"></a>方案（#3）</h2><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody></table><p>或</p><table><thead><tr><th align="center">內部flash存儲空間劃分</th><th align="center">內部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>    <td align="center">中斷向量表</td></tr><tr>    <td align="center">引導程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>    <td align="center">重定向的中斷向量表</td></tr><tr>    <td align="center">應用程序</td></tr><tr>    <td align="center">參數數據存儲區</td>    <td align="center">掉電不丟失的系統參數</td></tr></tbody><thead><tr><th align="center">外部flash存儲空間劃分</th><th align="center">外部flash存儲空間細分</th></tr></thead><tbody><tr>    <td align="center" rowspan="2">升級數據存儲區</td>    <td align="center">解壓後的新版程序</td></tr><tr>    <td align="center">接收到的壓縮文件</td></tr></tbody></table><h3 id="思路（-1）-2"><a href="#思路（-1）-2" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，最後翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-2）-2"><a href="#思路（-2）-2" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><h3 id="思路（-3）-2"><a href="#思路（-3）-2" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p><p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝（不支持解壓和差分還原）至備份應用存儲區，最後翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p>]]></content>
    
    
    <summary type="html">&lt;center&gt;which one is better?&lt;/center&gt;
&lt;br&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(在引導程序中集成通信協議棧與解壓還原算法)~~~B(在應用程序中集成通信協議棧與解壓還原算法)
&lt;/pre&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#01）基礎概念</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html</id>
    <published>2023-09-30T16:00:01.000Z</published>
    <updated>2023-09-30T16:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<center>傳統編程方式</center><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(先取下芯片)---&gt;B(再燒錄程序)---&gt;C(後裝回板卡)</pre><center>現代編程方式</center><pre class="mermaid">flowchart LR%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%A(&quot;在電路編程&lt;br&gt;(ＩＣＰ)&quot;)---&gt;B(&quot;在系統編程&lt;br&gt;(ＩＳＰ)&quot;)---&gt;C(&quot;在應用編程&lt;br&gt;(ＩＡＰ)&quot;)</pre><span id="more"></span><h2 id="傳統編程方式"><a href="#傳統編程方式" class="headerlink" title="傳統編程方式"></a>傳統編程方式</h2><p>傳統編程方式是先將程序燒錄至主控芯片中再焊接到電路板上。</p><p><strong>開發階段</strong></p><ul><li>➀ 從電路板上取下芯片</li><li>➁ 使用燒錄器燒寫程序</li><li>➂ 將芯片裝回至電路板</li></ul><p><strong>量產階段</strong></p><ul><li>➀ 從 tray 盤取出芯片</li><li>➁ 使用燒錄器燒寫程序</li><li>➂ 將芯片放回 tray 盤</li></ul><p><strong>維護階段</strong></p><ul><li>➀ 從電路板上拆下芯片</li><li>➁ 使用燒錄器燒寫程序</li><li>➂ 將芯片焊回至電路板</li></ul><h2 id="現代編程方式"><a href="#現代編程方式" class="headerlink" title="現代編程方式"></a>現代編程方式</h2><p>現代編程方式可以直接進行板上燒錄，不用再取下芯片放到專用的燒錄器上燒錄，極大地提高了開發、生產以及維護效率。</p><p>現代編程方式又可分爲：</p><ul><li>在電路編程 ICP (Circuit)</li><li>在系統編程 ISP (System)</li><li>在應用編程 IAP (Application)</li></ul><table><thead><tr><th align="center">編程方式</th><th align="center">在電路編程</th><th align="center">在系統編程</th><th align="center">在應用編程</th></tr></thead><tbody><tr><td align="center">核心思想</td><td align="center">藉助外部燒錄器<br>通過JTAG&#x2F;SWD接口<br>實現在電路編程</td><td align="center">藉助芯片內部<br>固化的引導程序和BOOT引腳<br>以及片上接口<br>實現在系統編程</td><td align="center">藉助用戶自己<br>編寫的引導程序、應用程序<br>以及片上接口、板上接口<br>實現在應用編程</td></tr><tr><td align="center">引導程序</td><td align="center">不需要</td><td align="center">需要芯片廠家編寫<br>並固化到某一地址空間</td><td align="center">需要用戶自己編寫<br>並燒錄至內部flash存儲器</td></tr><tr><td align="center">進入方式</td><td align="center">隨時待命</td><td align="center">需要更改BOOT引腳的電平<br>然後硬件復位<br>進入內部固化的引導程序</td><td align="center">隨時待命</td></tr><tr><td align="center">配套軟件</td><td align="center">燒錄軟件</td><td align="center">芯片廠家提供的<br>上位機ISP編程軟件</td><td align="center">用戶自己開發的數據傳輸軟件</td></tr><tr><td align="center">通信接口</td><td align="center">JTAG&#x2F;SWD</td><td align="center">取決於芯片中固化的引導程序<br>URT&#x2F;SPI&#x2F;IIC&#x2F;CAN&#x2F;USB</td><td align="center">理論上可以支持任意接口<br>URT&#x2F;SPI&#x2F;IIC<br>485&#x2F;CAN&#x2F;USB<br>WiFi&#x2F;BLE&#x2F;IrDA<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td></tr><tr><td align="center">程序升級<br>是否需要<br>拆裝芯片</td><td align="center">不需要<br>拆裝芯片</td><td align="center">不需要<br>拆裝芯片</td><td align="center">不需要<br>拆裝芯片</td></tr><tr><td align="center">程序升級<br>是否需要<br>拆裝外殼</td><td align="center">需要<br>拆開設備外殼</td><td align="center">通信接口完備的情況下<br>不需要<br>拆開設備外殼<br>485&#x2F;CAN&#x2F;USB</td><td align="center">通信接口完備的情況下<br>不需要<br>拆開設備外殼<br>485&#x2F;CAN&#x2F;USB&#x2F;WiFi&#x2F;BLE&#x2F;IrDA</td></tr><tr><td align="center">程序升級<br>是否需要<br>前往現場</td><td align="center">需要<br>前往設備安裝現場</td><td align="center">需要<br>前往設備安裝現場</td><td align="center">遠程通信功能完備的情況下<br>不需要<br>前往設備安裝現場<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td></tr></tbody></table><div class="note info no-icon"><p>ICP 主要是在開發階段使用，其燒錄速度是 ISP 和 IAP 所無法比擬的。</p></div><div class="note info no-icon"><p>IAP 與 ISP 類似，都有 bootloader 引導程序，因此無需使用燒錄器。二者的區別在於，ISP 的引導程序由芯片廠家編寫，比較簡單，無法實現用戶的定製化需求；而 IAP 的引導程序是由用戶自己實現，可以根據需求自行修改。另外 ISP 進入 boot 程序的方式是通過更改 BOOT 引腳的電平；而 IAP 則是從用戶程序中通過軟件復位或者跳轉的方式直接進入 bootloader 程序，因此相較於 ISP 來說會更加靈活。</p></div><div class="note info no-icon"><p>通過 WiFi&#x2F;BLE&#x2F;4G&#x2F;5G&#x2F;NBIoT 等無線通信技術實現 IAP 功能的方案也被稱作 OTA 空中下載技術。</p></div><table><thead><tr><th align="center">BOOT1</th><th align="center">BOOT0</th><th align="center">BOOT MODE</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">0</td><td align="center">boot from 0x08000000 : main memory</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">boot from 0x1FFF0000 : boot memory</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">boot from 0x20000000 : sram memory</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;center&gt;傳統編程方式&lt;/center&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(先取下芯片)---&amp;gt;B(再燒錄程序)---&amp;gt;C(後裝回板卡)
&lt;/pre&gt;

&lt;center&gt;現代編程方式&lt;/center&gt;

&lt;pre class=&quot;mermaid&quot;&gt;
flowchart LR
%%{init: { &amp;quot;flowchart&amp;quot;: { &amp;quot;curve&amp;quot;: &amp;quot;basis&amp;quot; } } }%%
A(&amp;quot;在電路編程&amp;lt;br&amp;gt;(ＩＣＰ)&amp;quot;)---&amp;gt;B(&amp;quot;在系統編程&amp;lt;br&amp;gt;(ＩＳＰ)&amp;quot;)---&amp;gt;C(&amp;quot;在應用編程&amp;lt;br&amp;gt;(ＩＡＰ)&amp;quot;)
&lt;/pre&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="在線升級" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%9C%A8%E7%B7%9A%E5%8D%87%E7%B4%9A/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式 IAP 升級功能（#00）目錄索引</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2023-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="clnyhr2n2004x10rq71zl3lqj.html">嵌入式 IAP 升級功能（#01）基礎概念</a><br><a href="clnyhr2n3004y10rq322c66uu.html">嵌入式 IAP 升級功能（#02）升級方案</a><br><a href="clnyhr2n3005010rqf3gcgp39.html">嵌入式 IAP 升級功能（#03）流程設計</a><br><a href="clnyhr2n4005410rqfyjmedv1.html">嵌入式 IAP 升級功能（#04）技術細節</a><br><a href="clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#05）增量升級</a><br><a href="clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植</a><br><a href="clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuztool 移植</a><br><a href="clnyhr2n5005a10rq54px6ho5.html">嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級</a></p><hr><span id="more"></span><h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://itexp.blog.csdn.net/article/details/83793309">https://itexp.blog.csdn.net/article/details/83793309</a></p><p><a href="https://blog.csdn.net/qq_24130227/article/details/123752964">https://blog.csdn.net/qq_24130227/article/details/123752964</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108379324">https://blog.csdn.net/qq_24130227/article/details/108379324</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/113003329">https://blog.csdn.net/qq_24130227/article/details/113003329</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/120061873">https://blog.csdn.net/qq_24130227/article/details/120061873</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108427842">https://blog.csdn.net/qq_24130227/article/details/108427842</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;clnyhr2n2004x10rq71zl3lqj.html&quot;&gt;嵌入式 IAP 升級功能（#01）基礎概念&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n3004y10rq322c66uu.html&quot;&gt;嵌入式 IAP 升級功能（#02）升級方案&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n3005010rqf3gcgp39.html&quot;&gt;嵌入式 IAP 升級功能（#03）流程設計&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n4005410rqfyjmedv1.html&quot;&gt;嵌入式 IAP 升級功能（#04）技術細節&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升級功能（#05）增量升級&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n4005710rqfv00ckub.html&quot;&gt;嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuztool 移植&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clnyhr2n5005a10rq54px6ho5.html&quot;&gt;嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="單片機" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%96%AE%E7%89%87%E6%A9%9F/"/>
    
    <category term="iap" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/iap/"/>
    
    <category term="bootloader" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－合集</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo3okqut006mi0rq9ecvb34e.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo3okqut006mi0rq9ecvb34e.html</id>
    <published>2023-07-04T16:00:00.000Z</published>
    <updated>2023-07-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>各個平臺下的開發環境搭建教程</p><ul><li><a href="/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html">ARM.GCC</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.MDK (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.SES (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">ARM.ADS (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">RV5.GCC (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">RV5.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">RV5.SES (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">C51.MDK (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">C51.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">MSP.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">AVR.IAR (TODO)</a></li><li><a href="/sulfurandcu.io/404/index.html">PIC.XXX (TODO)</a></li></ul><hr><span id="more"></span><h2 id="搭建方案"><a href="#搭建方案" class="headerlink" title="搭建方案"></a>搭建方案</h2><ul><li><strong>VSC</strong><ul><li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li><li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li><li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li><li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li></ul></li><li><strong>VS</strong><ul><li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li><li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li></ul></li><li><strong>Eclipse</strong></li><li><strong>Eclipse Based</strong><ul><li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a></li><li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a></li><li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a></li></ul></li></ul><h2 id="通用方案"><a href="#通用方案" class="headerlink" title="通用方案"></a>通用方案</h2><ul><li><a href="https://www.keil.arm.com/">KeilStudioCloud</a></li><li><a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Development%20Studio">ADS</a><ul><li>ARM</li></ul></li><li><a href="https://www.keil.com/">MDK</a><ul><li>ARM <a href="https://www.keil.com/pr/article/1302.htm">(ARM 6 Will start shipping towards The End of 2023)</a></li><li>C51</li></ul></li><li><a href="https://www.iar.com/products/architectures/">IAR</a><ul><li>RV5</li><li>ARM</li><li>AVR</li><li>MSP</li><li>STM</li><li>C51</li></ul></li><li><a href="https://www.segger.com/products/development-tools/embedded-studio/">SES</a><ul><li>ARM</li><li>RV5</li></ul></li><li><a href="https://embeetle.com/#">EmbeetleIDE</a></li></ul><h2 id="專用方案"><a href="#專用方案" class="headerlink" title="專用方案"></a>專用方案</h2><ul><li><strong>Eclipse Based</strong><ul><li><a href="https://www.st.com/en/development-tools/sw4stm32.html">ST: SW4STM32 System Workbench for STM32</a></li><li><a href="https://www.st.com/en/development-tools/truestudio.html">ST: TrueStudio by Atollic before 2017</a></li><li><a href="">ST: STM32CubeIDE release in 2019 &#x3D; TrueStudio+STM32CubeMX</a></li><li><a href="https://www.renesas.com/us/en/software-tool/e-studio">Renesas: E2Studio</a></li></ul></li><li><strong>NetBeans Based</strong><ul><li><a href="https://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide">Microchip: MPLAB X IDE</a></li></ul></li></ul><h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://elmagnifico.tech/2022/03/14/Embeded-IDE/">https://elmagnifico.tech/2022/03/14/Embeded-IDE/</a><br><a href="https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/">https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;各個平臺下的開發環境搭建教程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html&quot;&gt;ARM.GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.MDK (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.SES (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;ARM.ADS (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;RV5.GCC (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;RV5.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;RV5.SES (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;C51.MDK (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;C51.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;MSP.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;AVR.IAR (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/sulfurandcu.io/404/index.html&quot;&gt;PIC.XXX (TODO)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－DBG</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html</id>
    <published>2023-07-04T09:23:25.000Z</published>
    <updated>2023-07-04T09:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p><span id="more"></span><h2 id="專用的調試模塊"><a href="#專用的調試模塊" class="headerlink" title="專用的調試模塊"></a>專用的調試模塊</h2><p>常見的 IDE 內部都集成了一個專用的 GUI 調試器，且不能拎出來單獨使用。</p><ul><li>ADS</li><li>IAR</li><li>MDK</li><li>Visual Studio</li></ul><h2 id="獨立的調試工具"><a href="#獨立的調試工具" class="headerlink" title="獨立的調試工具"></a>獨立的調試工具</h2><p>當然也有一些可以獨立使用的調試器，例如：</p><ul><li>CLI: GDB, LLDB</li><li>GUI: x64dbg, WinDBG, OllyDBG</li></ul><h2 id="通用的調試協議（DebugAdapterProtocol）"><a href="#通用的調試協議（DebugAdapterProtocol）" class="headerlink" title="通用的調試協議（DebugAdapterProtocol）"></a>通用的調試協議（DebugAdapterProtocol）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapterProtocol.png"></p><p>不論是專用的調試模塊還是獨立的調試工具，如果想支持調試多種語言，就必須要爲每一種語言開發一套對應的調試程序，並且每個工具廠商都要獨自去完成這些工作。爲了減少不必要的重複勞動，微軟制定了一套通用的調試協議，藉助該協議各工具廠商只需要開發一套調試程序，向下再借助各種調試適配工具即可具備調試所有語言的能力。</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p><center><a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Adapter Protocol (DAP)</a></center><br><p>目前實現該調試協議的開發工具有（常用的）：</p><ul><li>VSC</li><li>VS</li><li>vim</li><li>emacs</li><li>EclipseIDE</li></ul><p>btw, 微軟還制定了一套通用的語言服務器協議 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/LanguageServerProtocol(LSP).png"></p><center><a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></center><h2 id="調試器適配工具（DebugAdapter）"><a href="#調試器適配工具（DebugAdapter）" class="headerlink" title="調試器適配工具（DebugAdapter）"></a>調試器適配工具（DebugAdapter）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapter.png"></p><p>調試適配器是對各類調試器的封裝，遵循 DAP 協議對上提供統一的接口，以簡化上層開發工具。常用的調試適配器有：</p><ul><li><a href="https://github.com/Microsoft/vscode-cpptools">cpptools (C&#x2F;C++ Debug Adapter)</a></li><li><a href="https://github.com/Marus/cortex-debug">cortex-debug (Embedded C&#x2F;C++ Debug Adapter)</a></li></ul><h2 id="調試器軟件本體（Debugger）"><a href="#調試器軟件本體（Debugger）" class="headerlink" title="調試器軟件本體（Debugger）"></a>調試器軟件本體（Debugger）</h2><ul><li><a href="https://sourceware.org/gdb/">GDB: The GNU Project Debugger</a><ul><li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">↑ GDB&#x2F;MI</a></li><li><a href="https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html">↓ GDB Remote Serial Protocol</a></li></ul></li><li><a href="https://developer.arm.com/downloads/-/gnu-rm">arm-none-eabi-gdb: GNU Arm Embedded GDB</a></li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Debugger.png"></p><h2 id="調試器服務程序（DebugServer）"><a href="#調試器服務程序（DebugServer）" class="headerlink" title="調試器服務程序（DebugServer）"></a>調試器服務程序（DebugServer）</h2><ul><li>OpenOCD</li><li>PyOCD</li><li>JLinkGDBServer</li><li>……</li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugServer.png"></p><h2 id="仿真器驅動程序（DongleDriver）"><a href="#仿真器驅動程序（DongleDriver）" class="headerlink" title="仿真器驅動程序（DongleDriver）"></a>仿真器驅動程序（DongleDriver）</h2><ul><li>SEGGER JLink USB Driver</li><li>SEGGER WinUSB USB Device Driver</li></ul><h2 id="仿真器設備本體（Dongle）"><a href="#仿真器設備本體（Dongle）" class="headerlink" title="仿真器設備本體（Dongle）"></a>仿真器設備本體（Dongle）</h2><ul><li>CMSIS-DAP</li><li>SEGGER JLink</li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Dongle.png"></p><h2 id="仿真器傳輸協議（DongleTransportProtocol）"><a href="#仿真器傳輸協議（DongleTransportProtocol）" class="headerlink" title="仿真器傳輸協議（DongleTransportProtocol）"></a>仿真器傳輸協議（DongleTransportProtocol）</h2><ul><li>JTAG <a href="https://www.corelis.com/education/tutorials/jtag-tutorial/">https://www.corelis.com/education/tutorials/jtag-tutorial/</a></li><li>SWD</li></ul><h2 id="目標板目標芯片（TargetBoard）"><a href="#目標板目標芯片（TargetBoard）" class="headerlink" title="目標板目標芯片（TargetBoard）"></a>目標板目標芯片（TargetBoard）</h2><ul><li>STM32F103CB</li><li>STM32F407VE</li></ul><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Target.png"></p><h2 id="本地與遠程調試"><a href="#本地與遠程調試" class="headerlink" title="本地與遠程調試"></a>本地與遠程調試</h2><p>遠程調試方案也有很多，這裏只對以下幾種方式作一簡要介紹：</p><ul><li>OpenOCD</li><li>VSCode + JLinkGDBServer</li><li>JLink + JLinkRemoteServer</li><li>KeilMDK + JLinkRemoteServer</li></ul><h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>略.</p><h3 id="VSCode-JLinkGDBServer"><a href="#VSCode-JLinkGDBServer" class="headerlink" title="VSCode + JLinkGDBServer"></a>VSCode + JLinkGDBServer</h3><p>1. 在服務主機上配置開啓 JLink 調試服務器（該服務器會監聽 2331 端口）</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.0.png"></p><div class="note danger no-icon"><p>不要勾選 Localhost Only 選項！</p></div><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.1.png"></p><p>3. 在本地主機上配置 launch.json 文件並啓動調試</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">    &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">    &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">    &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">    &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Marus/cortex-debug/issues/244">cortex-debug-issues#244 : remote debugging</a><br><a href="https://github.com/Marus/cortex-debug/wiki/External-gdb-server-configuration">cortex-debug-wiki : external gdb server configuration</a></p><div class="note info no-icon"><p>點擊啓動調試後 cortex-debug 便會幫助我們通過本地 xGDB 客戶端連接遠程 GDB 服務器。</p></div><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.2.png"></p><p>5. 遠程調試</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此處省略一張在 vscode 中調試的圖片</span><br></pre></td></tr></table></figure><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.3.png"></p><h3 id="JLink-JLinkRemoteServer"><a href="#JLink-JLinkRemoteServer" class="headerlink" title="JLink + JLinkRemoteServer"></a>JLink + JLinkRemoteServer</h3><h4 id="內網連接"><a href="#內網連接" class="headerlink" title="內網連接"></a>內網連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p><p>3. 在本地主機上配置連接 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.png"></p><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p><p>5. 遠程調試</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.1.png"></p><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p><h4 id="隧道連接"><a href="#隧道連接" class="headerlink" title="隧道連接"></a>隧道連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器（隧道方式）</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.0.png"></p><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.1.png"></p><p>3. 在本地主機上配置連接 JLink 遠程服務器（隧道方式）</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.0.png"></p><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.2.png"></p><p>5. 遠程調試</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.1.png"></p><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.3.png"></p><h3 id="KeilMDK-JLinkRemoteServer"><a href="#KeilMDK-JLinkRemoteServer" class="headerlink" title="KeilMDK + JLinkRemoteServer"></a>KeilMDK + JLinkRemoteServer</h3><h4 id="內網連接-1"><a href="#內網連接-1" class="headerlink" title="內網連接"></a>內網連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p><p>2. 等待連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p><p>3. 在本地主機上配置連接 JLink 遠程服務器</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.Keil.MDK.png"></p><p>4. 建立連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p><p>5. 遠程調試</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此處省略一張在 Keil MDK 中調試的圖片</span><br></pre></td></tr></table></figure><p>6. 斷開連接</p><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#05）程序調試</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html</id>
    <published>2023-06-14T16:00:05.000Z</published>
    <updated>2023-06-14T16:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>laugch.json</li></ul><hr><span id="more"></span><p>1. 在工程目錄下的 .vscode 目錄中新建 laugch.json 文件並填入以下內容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@JLinkGDBServerCL.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;jlink&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;device&quot;: &quot;STM32F103CB&quot;,</span><br><span class="line">            &quot;interface&quot;: &quot;swd&quot;,</span><br><span class="line">            &quot;serverArgs&quot;: [</span><br><span class="line">                // &quot;-gui&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@OpenOCD.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;openocd&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;showDevDebugOutput&quot;: &quot;none&quot;,</span><br><span class="line">            &quot;configFiles&quot;: [</span><br><span class="line">                &quot;openocd/jlink-swd.cfg&quot;,</span><br><span class="line">                &quot;openocd/stm32f1x.cfg&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin/arm-none-eabi-gdb.exe&quot;,</span><br><span class="line">            &quot;armToolchainPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2. 進入側邊欄中的 RunAndDebug 然後選擇</p><ul><li>Debug@JLinkGDBServerCL.exe</li><li>Debug@OpenOCD.exe</li><li>Debug@RemoteServer(GDBServer&#x2F;JLinkGDBServer)</li></ul><p><img src="/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey/launch.json.png"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;laugch.json&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#04）快捷任務</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html</id>
    <published>2023-06-14T16:00:04.000Z</published>
    <updated>2023-06-14T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>tasks.json</li></ul><hr><span id="more"></span><p>通過 makefile 我們將海量的指令精簡至一條 make+ 指令，但是我比較懶，一條指令都不想敲。😎</p><p>1. 在工程目錄下的 .vscode 目錄中新建 tasks.json 文件並填入以下內容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;編譯（build）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;清除（clean）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make clean&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;燒錄（write）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;燒錄（write.openocd）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write.openocd&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>在 cmd 中使用 “|” 連接兩條指令，在 powershell 中使用 “;” 連接兩條指令。</p></div><p>2. 找到菜單欄依次點擊 Terminal -&gt; RunTask 然後選擇：</p><ul><li>編譯（build）</li><li>清除（clean）</li><li>燒錄（write）</li><li>燒錄（write.openocd）</li></ul><p><img src="/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz/task.json.png"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;tasks.json&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#03）程序燒錄</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html</id>
    <published>2023-06-14T16:00:03.000Z</published>
    <updated>2023-06-14T16:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>編程&#x2F;下載&#x2F;燒錄的方式有多種，本文重點介紹以下兩種燒錄方式：</p><ul><li>JLink</li><li>OpenOCD + JLink 仿真器</li></ul><p>其中 OpenOCD 可以搭配多種仿真器使用，這裏以 JLink 仿真器爲例進行說明。</p><span id="more"></span><h2 id="JLink"><a href="#JLink" class="headerlink" title="JLink"></a>JLink</h2><p>1. 確認是否購買了 JLink 仿真器並且已經安裝了 JLink 程序。</p><p>2. 在 makefile 中添加 write 選項：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.png"></p><p>3. 在工程目錄下新建 JLinkLoad.txt 文件並寫入以下內容：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.code.png"></p><p>4. 執行 mingw32-make write 指令：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.succ.png"></p><div class="note danger no-icon"><p>再次提醒：需要使用 JLink 仿真器以及<strong>默認驅動</strong></p></div><div class="note danger no-icon"><p>如果你的電腦中有不止一個 “JLink” 程序，確保在 makefile 中通過絕對路徑使用 JLink 命令。</p></div><p>下圖是我安裝了 JavaJDK 後系統中存在的 jlink 程序，只不過此 “jlink” 非彼 “JLink”！</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLink.JavaJDK.png"></p><h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>1. 確認是否購買了 JLink 仿真器並且已經安裝了 OpenOCD 程序。</p><p>2. 在 makefile 中添加 write 選項：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.png"></p><p>3. 在工程目錄下新建 openocd.cfg 文件並寫入以下內容：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.code.png"></p><blockquote><p><a href="https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics">https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics</a></p></blockquote><p>4. 將 jlink.cfg 和 stm32f1x.cfg 拷貝至工程目錄下。</p><p>5. 使用 zadig 或 USBDriverTool 將仿真器的驅動從 WinUSB 改爲 libusb 驅動。</p><p>6. 執行 mingw32-make write 指令：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.succ.png"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="問題一：未找到-JLink-仿真器"><a href="#問題一：未找到-JLink-仿真器" class="headerlink" title="問題一：未找到 JLink 仿真器"></a>問題一：未找到 JLink 仿真器</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.1.png"></p><p>OpenOCD 對仿真器的支持是通過底層的訪問控制實現的，不依賴仿真器自身的驅動，但是需要 libusb 驅動，因此我們需要使用 zadig 或 USBDriverTool 等工具將仿真器的默認驅動改爲 libusb 驅動。</p><p>需要注意的是，將驅動改成 libusb 之後，原有的調試軟件例如 JLink&#x2F;Keil 將無法再識別到仿真器。</p><p>如果你還想繼續使用這些調試軟件，則需要卸載掉當前的驅動程序並插拔一下仿真器：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.2.png"></p><h3 id="問題二：SWD-amp-JTAG"><a href="#問題二：SWD-amp-JTAG" class="headerlink" title="問題二：SWD &amp; JTAG"></a>問題二：SWD &amp; JTAG</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.1.png"></p><p>OpenOCD 提供的 jlink.cfg 腳本默認使用 JTAG 模式，而我們實際使用的是 SWD 模式。</p><p>解決方法：在 openocd.cfg 文件中添加一條語句：</p><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;編程&amp;#x2F;下載&amp;#x2F;燒錄的方式有多種，本文重點介紹以下兩種燒錄方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JLink&lt;/li&gt;
&lt;li&gt;OpenOCD + JLink 仿真器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 OpenOCD 可以搭配多種仿真器使用，這裏以 JLink 仿真器爲例進行說明。&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#02）代碼編譯</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6400c71wrq3816hypq.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6400c71wrq3816hypq.html</id>
    <published>2023-06-14T16:00:02.000Z</published>
    <updated>2023-06-14T16:00:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>廣義的編譯包括預處理、編譯、彙編、鏈接這四個基本流程，編譯期間需要執行若干指令。</p><p>倘若只有 main.h 和 main.c 兩個文件，那麼只需要執行少量的指令即可完成編譯工作。但是實際上一個工程通常包含幾十上百個文件，意味着要執行大量的編譯指令才能得到目標文件，這是我們所無法接受的。因此需要藉助 make、ninja 等構建工具實現編譯自動化。</p><span id="more"></span><h2 id="生成腳本（makefile）"><a href="#生成腳本（makefile）" class="headerlink" title="生成腳本（makefile）"></a>生成腳本（makefile）</h2><p>相較於頭開始寫 makefile 腳本，先通過 STM32CubeMX 生成然後加以改造則要容易得多。</p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.0.png"></p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.1.png"></p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.2.png"></p><h2 id="修改腳本（makefile）"><a href="#修改腳本（makefile）" class="headerlink" title="修改腳本（makefile）"></a>修改腳本（makefile）</h2><ol><li>修改文件列表（*.c &amp; *.s）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_SOURCES = \</span><br><span class="line">../../../code/Application/src/main.c \</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASM_SOURCES = \</span><br><span class="line">startup_stm32f103xb.s \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>修改包含路徑（*.h）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_INCLUDES = \</span><br><span class="line">-I../../../code/Application \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>修改全局定義（#define）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_DEFS = \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F103xB \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>修改鏈接腳本（.ld）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDSCRIPT = STM32F103C8Tx_FLASH.ld</span><br></pre></td></tr></table></figure></li></ol><h2 id="執行編譯"><a href="#執行編譯" class="headerlink" title="執行編譯"></a>執行編譯</h2><p>在 makefile 所在的路徑下執行 make 指令開始編譯</p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.build.png"></p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.where.png"></p><div class="note danger no-icon"><p>在 windows 系統中請使用 .&#x2F;mingw32-make 命令而非 .&#x2F;make 命令！</p></div><h2 id="清除編譯"><a href="#清除編譯" class="headerlink" title="清除編譯"></a>清除編譯</h2><p>若要清除剛纔編譯的中間文件，則需要修改 makefile 文件，然後執行 mingw32-make clean 指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">#   -rm -fR $(BUILD_DIR)</span><br><span class="line">    -del /q $(BUILD_DIR)</span><br></pre></td></tr></table></figure><p>這時你大概率會遇到以下問題：</p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.fail1.png"></p><p>有人說將 clean 下的 -rm -fR $(BUILD_DIR) 改成 -del &#x2F;q $(BUILD_DIR) 就好了，實測並不管用。</p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.fail2.png"></p><p>只有顯式地將 SHELL 指定爲 cmd 纔行（在 makefile 中添加一條語句）：</p><p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.shell.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;廣義的編譯包括預處理、編譯、彙編、鏈接這四個基本流程，編譯期間需要執行若干指令。&lt;/p&gt;
&lt;p&gt;倘若只有 main.h 和 main.c 兩個文件，那麼只需要執行少量的指令即可完成編譯工作。但是實際上一個工程通常包含幾十上百個文件，意味着要執行大量的編譯指令才能得到目標文件，這是我們所無法接受的。因此需要藉助 make、ninja 等構建工具實現編譯自動化。&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#01）環境搭建</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc.html</id>
    <published>2023-06-14T16:00:01.000Z</published>
    <updated>2023-06-14T16:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png"></p><span id="more"></span><hr><h2 id="編輯器安裝"><a href="#編輯器安裝" class="headerlink" title="編輯器安裝"></a>編輯器安裝</h2><ul><li><strong>VSC</strong></li></ul><p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png"></p><center><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></center><ul><li><strong>VS</strong></li></ul><p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VS.png"></p><center><a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a></center><ul><li><strong>Eclipse.Embedded</strong></li></ul><p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.EclipseEmbedded.png"></p><center><a href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a></center><h2 id="編輯器插件"><a href="#編輯器插件" class="headerlink" title="編輯器插件"></a>編輯器插件</h2><ul><li><strong><a href="https://github.com/Marus/cortex-debug/wiki">vscode :: cortex-debug</a></strong></li><li><strong><a href="https://em-ide.com/zh-cn/">vscode :: eide</a></strong></li></ul><h2 id="編譯器安裝"><a href="#編譯器安裝" class="headerlink" title="編譯器安裝"></a>編譯器安裝</h2><ul><li><strong><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain (12.2.Rel1 based on GCC 12.2)</a></strong></li><li><strong><a href="https://developer.arm.com/downloads/-/gnu-a">Arm GNU Toolchain for the Cortex-A (10.3-2021.07 based on GCC 10.3)</a></strong></li><li><strong><a href="https://developer.arm.com/downloads/-/gnu-rm">Arm GNU Toolchain for the Cortex-R &amp; Cortex-M (10.3-2021.10 based on GCC 10.3)</a></strong></li><li><strong><a href="https://xpack.github.io/dev-tools/arm-none-eabi-gcc/releases/">xPack GNU Arm Embedded GCC toolchain</a></strong></li></ul><div class="note danger no-icon"><p>記得將安裝目錄添加至系統環境變量</p></div><h2 id="調試器安裝"><a href="#調試器安裝" class="headerlink" title="調試器安裝"></a>調試器安裝</h2><ul><li><strong><a href="https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack">SEGGER JLink Installer</a></strong></li><li><strong><a href="https://xpack.github.io/dev-tools/openocd/releases/">OpenOCD prebuilt by xPackProject</a></strong></li><li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD prebuilt by Sysprogs</a></strong></li><li><strong><a href="https://github.com/openocd-org/openocd/releases">OpenOCD prebuilt by OpenOCD.org</a></strong></li></ul><div class="note danger no-icon"><p>記得將安裝目錄添加至系統環境變量</p></div><h2 id="構建器安裝"><a href="#構建器安裝" class="headerlink" title="構建器安裝"></a>構建器安裝</h2><ul><li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">make</a></strong></li><li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">ninja</a></strong></li><li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">cmake</a></strong></li></ul><div class="note info no-icon"><p>理論上安裝完編輯器、編譯器和調試器之後就能夠正常使用了，安裝上述工具是爲了提高開發效率。</p></div><h2 id="建立新工程"><a href="#建立新工程" class="headerlink" title="建立新工程"></a>建立新工程</h2><ul><li>略.</li></ul><h2 id="拷貝至工程"><a href="#拷貝至工程" class="headerlink" title="拷貝至工程"></a>拷貝至工程</h2><ul><li>*.h, *.c<br>代碼文件：在 makefile 中引用進行編譯</li><li>*.s<br>啓動文件：在 makefile 中引用進行編譯</li><li>*.ld<br>鏈接文件：在 makefile 中引用進行鏈接</li><li>*.svd<br>描述文件：在 launch.json 中配置用於調試</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>集成開發環境－GCC.ARM（#00）目錄索引</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html</id>
    <published>2023-06-14T16:00:00.000Z</published>
    <updated>2023-06-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><a href="clo2c1l6o00dh1wrqd2o379jc.html">集成開發環境－GCC.ARM（#01）環境搭建</a><br><a href="clo2c1l6400c71wrq3816hypq.html">集成開發環境－GCC.ARM（#02）代碼編譯</a><br><a href="clo2c1l6600ca1wrqbvuabt0b.html">集成開發環境－GCC.ARM（#03）程序燒錄</a><br><a href="clo2c1l6700cd1wrqgjn53mgz.html">集成開發環境－GCC.ARM（#04）快捷任務</a><br><a href="clo2c1l6600cb1wrqewhnb8ey.html">集成開發環境－GCC.ARM（#05）程序調試</a><br><a href="clo2c1l6500c81wrqbkskaevk.html">集成開發環境－GCC.ARM（#06）遠程調試</a><br><a href="clockxig7001dj4rqc2n6542r.html">集成開發環境－DBG</a></p><hr><p>傳統的集成開發環境（MDK、IAR）通常會提供包括編輯、編譯、燒錄、調試在內的一整套工具，開發者無需配置，簡單易用，但是 license 不是一般的貴。</p><p>替代方案：</p><ul><li><strong>VSC</strong><ul><li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li><li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li><li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li><li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li><li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li></ul></li><li><strong>VS</strong><ul><li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li><li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li></ul></li><li><strong>Eclipse</strong></li><li><strong>Eclipse Based</strong><ul><li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a> (RV5 ARM JLink STLink DAP-Link QEMU)</li><li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a> (RV5 ARM)</li><li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a> (RV5)</li></ul></li></ul><blockquote><p>倘若宿主機使用 Windows 操作系統並且購買了 JLinkDebugger 仿真器，則推薦使用 JLink 方案！</p></blockquote><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一個基本的開發環境包含以下四個部分：</p><ol><li>編輯功能（vscode）</li><li>編譯功能（arm-none-eabi-xxx）</li><li>燒錄功能（OpenOCD&#x2F;JLink）</li><li>調試功能（OpenOCD&#x2F;JLinkGDBServerCL + Cortex-Debug + arm-none-eabi-gdb）</li></ol><ul><li><p><strong>vscode</strong><br>文本編輯器，其實是一個僞裝成文本編輯器的開發框架。</p></li><li><p><strong>arm-none-eabi-xxx</strong><br>交叉編譯器，可以編譯出在 Cortex-R&amp;M 平臺上運行的可執行程序。</p></li><li><p><strong>OpenOCD&#x2F;JLink</strong><br>程序燒錄器，負責將編譯好的程序燒錄到目標芯片中。</p></li><li><p><strong>arm-none-eabi-gdb</strong><br>命令調試器，支持通過命令行的方式進行調試。</p></li><li><p><strong>Cortex-Debug</strong><br>圖形調試器，提供一套圖形調試界面，需要與命令調試器搭配使用。</p></li><li><p><strong>OpenOCD&#x2F;JLinkGDBServerCL</strong><br>調試服務器，負責協助調試器識別並管理各種仿真設備和目標芯片。</p></li><li><p><strong>makefile &amp; task.json</strong><br>自動化工具，用來實現編譯和燒錄的自動化。</p></li></ul><h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://blog.csdn.net/weixin_41328027/article/details/122969985">OpenOCD添加第三方設備支持:HT32F52352 Cortex-M0+</a></p><p><a href="https://zhuanlan.zhihu.com/p/61519415">用VS Code開發STM32（一）</a><br><a href="https://zhuanlan.zhihu.com/p/61538230">用VS Code開發STM32（二）</a><br><a href="https://zhuanlan.zhihu.com/p/61541590">用VS Code開發STM32（三）</a><br><a href="https://zhuanlan.zhihu.com/p/163771273">用VS Code開發STM32（四）</a></p><p><a href="https://blog.csdn.net/weixin_42328389/article/details/128511370">矜辰所致 OpenOCD 不同仿真器使用操作總結記錄</a><br><a href="https://blog.csdn.net/weixin_42328389/article/details/119823834">矜辰所致 在window下使用 VScode 搭建 ARM 開發環境—— 詳細版</a><br><a href="https://blog.csdn.net/pyt1234567890/article/details/122522700">VsCode+OpenOCD 開發stm32系列</a><br><a href="https://blog.csdn.net/qq_49295302/article/details/124628016">vscode-armgcc-openocd搭建STM32開發調試環境</a><br><a href="https://blog.csdn.net/qq_45701067/article/details/121652228">用 vscode 搭建stm32 開發環境（詳細）</a><br><a href="http://eda88.com/essay/firmware/vscode%E6%90%AD%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E8%BD%AC%EF%BC%89/">VSCode搭建STM32開發調試環境（轉）</a><br><a href="https://blog.csdn.net/ben_black/article/details/109906781">VSCode搭建STM32開發環境（極簡自我搭建&amp;懶人直接使用插件）</a><br><a href="https://blog.csdn.net/qq_40833810/article/details/106713462">Cortex-debug 調試器使用介紹</a><br><a href="https://mcuoneclipse.com/2021/05/01/visual-studio-code-for-c-c-with-arm-cortex-m-part-1/">Visual Studio Code for C&#x2F;C++ with ARM Cortex-M: Part 1 </a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;clo2c1l6o00dh1wrqd2o379jc.html&quot;&gt;集成開發環境－GCC.ARM（#01）環境搭建&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clo2c1l6400c71wrq3816hypq.html&quot;&gt;集成開發環境－GCC.ARM（#02）代碼編譯&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clo2c1l6600ca1wrqbvuabt0b.html&quot;&gt;集成開發環境－GCC.ARM（#03）程序燒錄&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clo2c1l6700cd1wrqgjn53mgz.html&quot;&gt;集成開發環境－GCC.ARM（#04）快捷任務&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clo2c1l6600cb1wrqewhnb8ey.html&quot;&gt;集成開發環境－GCC.ARM（#05）程序調試&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clo2c1l6500c81wrqbkskaevk.html&quot;&gt;集成開發環境－GCC.ARM（#06）遠程調試&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;clockxig7001dj4rqc2n6542r.html&quot;&gt;集成開發環境－DBG&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;傳統的集成開發環境（MDK、IAR）通常會提供包括編輯、編譯、燒錄、調試在內的一整套工具，開發者無需配置，簡單易用，但是 license 不是一般的貴。&lt;/p&gt;
&lt;p&gt;替代方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VSC&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://devblogs.microsoft.com/cppblog/vscode-embedded-development/&quot;&gt;Microsoft Embedded Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Marus/cortex-debug/wiki&quot;&gt;Cortex Debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://em-ide.com/zh-cn/&quot;&gt;Embedded IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html&quot;&gt;vscode for espidf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.essemi.com/index/article/plist?cid=141&quot;&gt;vscode for essemi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VS&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/&quot;&gt;Microsoft Embedded Software Development in Visual Studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://visualgdb.com/&quot;&gt;VisualGDB by SysPROGS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eclipse&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eclipse Based&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rt-thread.io/studio.html&quot;&gt;EclipseBased: RT-Thread Studio&lt;/a&gt; (RV5 ARM JLink STLink DAP-Link QEMU)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mounriver.com/&quot;&gt;EclipseBased: MounRiver Studio&lt;/a&gt; (RV5 ARM)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rvmcu.com/nucleistudio.html&quot;&gt;EclipseBased: NucleiIDE Studio&lt;/a&gt; (RV5)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;倘若宿主機使用 Windows 操作系統並且購買了 JLinkDebugger 仿真器，則推薦使用 JLink 方案！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="嵌入式軟件開發" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC/"/>
    
    <category term="集成開發環境" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E9%9B%86%E6%88%90%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/"/>
    
    <category term="IDE" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>LilyPond</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj.html</id>
    <published>2023-06-10T02:43:05.000Z</published>
    <updated>2023-06-10T02:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>LilyPond 是什麼？(<strong><a href="https://lilypond.org/">https://lilypond.org/</a></strong>)</p><blockquote><p>LilyPond (荷花池) 是一個音樂雕版軟件，致力產生最高質量的樂譜。它把傳統音樂雕版印刷的美學，呈現在計算機打印的樂譜上。LilyPond 是自由軟件，也是 GNU Project 的一部分。</p></blockquote><p>計算機軟件的內核是將接收到的數據進行計算並輸出，LilyPond 也不例外。我們需要按照 LilyPond 開發者制定的規則編寫樂譜源碼，然後使用 LilyPond 程序將源代碼轉換爲 PNG、PDF、SVG、MIDI 等格式的文件。</p><p><strong>荷花池（線譜）的運作流程如下：</strong></p><ol><li>按照 lilypond 開發者制定的規則編寫「LilyPond 樂譜源碼」。</li><li>使用 lilypond 程序將「LilyPond 樂譜源碼」轉換爲我們期望的「樂譜」文件。</li></ol><div class="note info no-icon"><p>這裏的 lilypond.exe 程序與我們日常使用的軟件有所不同，需要通過命令行的方式來調用執行。</p></div><p>不過 LilyPond 主要用於生成五線譜，若想生成簡譜我們還需要藉助另外一個工具：</p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly.png"></p><p>與上面不同，我們不再按照 LilyPond 的規則編寫「LilyPond 樂譜源碼」而是按照 jianpuly 開發者制定的規則編寫「Jianpuly 簡譜源碼」。</p><p><strong>荷花池（簡譜）的運作流程如下：</strong></p><ol><li>按照 jianpuly 開發者制定的規則編寫「Jianpuly 簡譜源碼」。</li><li>使用 jianpuly 腳本將「Jianpuly 簡譜源碼」轉換爲「LilyPond 樂譜源碼」。</li><li>使用 lilypond 程序將「LilyPond 樂譜源碼」轉換爲我們期望的「樂譜」文件。</li></ol><div class="note info no-icon"><p>與 lilypond 類似，jianpu-ly.py 需要通過命令行的方式經 python 調用執行。</p></div><span id="more"></span><h2 id="軟件下載"><a href="#軟件下載" class="headerlink" title="軟件下載"></a>軟件下載</h2><p><strong>1. 下載 lilypond 壓縮包</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-download.png"></p><center><a href="https://lilypond.org/download.html">下載鏈接</a></center><br><p><strong>2. 下載 jianpu-ly.py 腳本文件</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly-download.png"></p><center><a href="http://ssb22.user.srcf.net/mwrhome/jianpu-ly.html">下載鏈接</a></center><br><h2 id="軟件安裝"><a href="#軟件安裝" class="headerlink" title="軟件安裝"></a>軟件安裝</h2><p><strong>1. 將下載好的 lilypond 壓縮包解壓至任意位置</strong></p><p><strong>2. 將下載好的 jianpu-ly.py 剪切至 lilypond 解壓目錄下的 bin 文件夾中</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-unpack.png"></p><p><strong>3. 將 lilypond 安裝目錄下的 bin 文件夾添加至系統環境變量 PATH 中</strong></p><p><strong>第一步：搜索「環境變量」然後點擊「編輯系統環境變量」</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath1.png"></p><p><strong>第二步：點擊「環境變量」按鈕</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath2.png"></p><p><strong>第三步：選中系統變量中的「PATH」然後點擊下方的「編輯」按鈕</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath3.png"></p><p><strong>第四步：點擊「新建」按鈕然後輸入之前解壓的 lilypond 的完整路徑</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath4.png"></p><p><strong>4. 驗證 lilypond 是否正常安裝</strong></p><p><strong>第一步：按下「Win+R」鍵打開運行對話框然後輸入 cmd 並運行</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-verify-cmd.png"></p><p><strong>第二步：輸入「lilypond –help」然後按下回車鍵</strong></p><p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-help.png"></p><p>如果你能看到上圖中的信息，那麼恭喜，安裝完成！下面可以嘗試製作一個簡單的樂譜了！</p><br><h2 id="線譜製作"><a href="#線譜製作" class="headerlink" title="線譜製作"></a>線譜製作</h2><p>寫到這裏時發現了一篇非常不錯的 lilypond 中文入門教程，既然如此，那我索性就偷個懶，各位看官請移步這裏：</p><center><a href="https://www.yuque.com/qqbunny/lilypond">《LilyPond 入門教程》 by 兔子不咬人</a></center><br><h2 id="簡譜製作"><a href="#簡譜製作" class="headerlink" title="簡譜製作"></a>簡譜製作</h2><p><strong>1. 新建一個文件夾作爲工作空間</strong></p><p><strong>2. 將 jianpu-ly.py 腳本文件拷貝至工作空間</strong></p><p><strong>3. 在工作空間中創建一個文本文檔（例如：簡譜代碼.txt）然後寫入以下內容</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% tempo: 4=60</span><br><span class="line">title=標題</span><br><span class="line">1=C</span><br><span class="line">2/4</span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6 7 1&#x27;</span><br></pre></td></tr></table></figure><p><strong>4. 在工作空間中單擊右鍵選擇「在終端中打開」然後會彈出一個黑框框</strong></p><p><strong>5. 輸入以下命令並然後按回車鍵執行</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jianpu-ly.py 簡譜代碼.txt &gt; 樂譜代碼.ly</span><br></pre></td></tr></table></figure><p><strong>6. 輸入以下命令並然後按回車鍵執行</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lilypond -o 樂譜文件 --format=pdf,png 樂譜代碼.ly</span><br></pre></td></tr></table></figure><p><strong>7. 嫌麻煩的話也可以在工作空間中新建一個「自動腳本.bat」批處理文件並填入以下內容</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line"></span><br><span class="line">set jianpuly=&quot;D:\develop.r.1\lilypond-2.24.1\bin\jianpu-ly.py&quot;</span><br><span class="line"></span><br><span class="line">set source=&quot;簡譜&quot;</span><br><span class="line">set output=&quot;曲譜&quot;</span><br><span class="line"></span><br><span class="line">set middle=&quot;荷花&quot;</span><br><span class="line"></span><br><span class="line">python %jianpuly% %source%.txt &gt; %middle%.ly</span><br><span class="line">lilypond -o %output% --format=pdf,png %middle%.ly</span><br><span class="line">lilypond -o %output% --format=svg %middle%.ly</span><br><span class="line"></span><br><span class="line">md %source%</span><br><span class="line"></span><br><span class="line">move .\%output%.* .\%source%</span><br><span class="line">move .\%middle%.* .\%source%</span><br></pre></td></tr></table></figure><p><strong>8. 以後只要雙擊該腳本即可自動生成</strong></p><div class="note info no-icon"><p>使用這種方式時，文件名就不能隨便起了，必須與「source」字段保持一致。</p></div><h2 id="簡譜規則"><a href="#簡譜規則" class="headerlink" title="簡譜規則"></a>簡譜規則</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scale going up                                              1 2 3 4 5 6 7 1&#x27;</span><br><span class="line">Accidentals                                                 1 #1 2 b2 1</span><br><span class="line">Octaves                                                     1,, 1, 1 1&#x27; 1&#x27;&#x27;</span><br><span class="line">Shortcuts for 1’ and 2’                                     8 9</span><br><span class="line">Semiquaver, quaver, crotchet (16/8/4th notes)               s1 q1 1</span><br><span class="line">Dotted versions of the above (50% longer)                   s1. q1. 1.</span><br><span class="line">Demisemiquaver, hemidemisemiquaver (32/64th notes)          d1 h1</span><br><span class="line">Minims (half notes) use dashes                              1 -</span><br><span class="line">Dotted minim                                                1 - -</span><br><span class="line">Semibreve (whole note)                                      1 - - -</span><br><span class="line">Time signature                                              4/4</span><br><span class="line">Time signature with quaver anacrusis (8th-note pickup)      4/4,8</span><br><span class="line">Key signature (major)                                       1=Bb</span><br><span class="line">Key signature (minor)                                       6=F#</span><br><span class="line">Tempo                                                       4=85</span><br><span class="line">Lyrics                                                      L: here are the syl- la- bles (all on one line)</span><br><span class="line">Lyrics (verse 1)                                            L: 1. Here is verse one</span><br><span class="line">Lyrics (verse 2)                                            L: 2. Here is verse two</span><br><span class="line">Hanzi lyrics (auto space)                                   H: hanzi (with or without spaces)</span><br><span class="line">Lilypond headers                                            title=the title (on a line of its own)</span><br><span class="line">Multiple parts                                              NextPart</span><br><span class="line">Instrument of current part                                  instrument=Flute (on a line of its own)</span><br><span class="line">Multiple movements                                          NextScore</span><br><span class="line">Prohibit page breaks until end of this movement             OnePage</span><br><span class="line">Suppress bar numbers                                        NoBarNums</span><br><span class="line">Old-style time signature                                    SeparateTimesig 1=C 4/4</span><br><span class="line">Indonesian ‘not angka’ style                                angka</span><br><span class="line">Add a Western staff doubling the tune                       WithStaff</span><br><span class="line">Tuplets                                                     3[ q1 q1 q1 ]</span><br><span class="line">Grace notes before                                          g[#45] 1</span><br><span class="line">Grace notes after                                           1 [&#x27;1]g</span><br><span class="line">Simple chords                                               135 1 13 1</span><br><span class="line">Da capo                                                     1 1 Fine 1 1 1 1 1 1 DC</span><br><span class="line">Repeat (with alternate endings)                             R&#123; 1 1 1 &#125; A&#123; 2 | 3 &#125;</span><br><span class="line">Short repeats (percent)                                     R4&#123; 1 2 &#125;</span><br><span class="line">Ties (like Lilypond’s, if you don’t want dashes)            1 ~ 1</span><br><span class="line">Slurs (like Lilypond’s)                                     1 ( 2 )</span><br><span class="line">Erhu fingering (applies to previous note)                   Fr=0 Fr=4</span><br><span class="line">Erhu symbol (applies to previous note)                      souyin harmonic up down bend tilde</span><br><span class="line">Tremolo                                                     1/// - 1///5 -</span><br><span class="line">Rehearsal letters                                           letterA letterB</span><br><span class="line">Multibar rest                                               R*8</span><br><span class="line">Dynamics (applies to previous note)                         \p \mp \f</span><br><span class="line">Other 1-word Lilypond \ commands                            \fermata \&gt; \! \( \) etc</span><br><span class="line">Text                                                        ^&quot;above note&quot; _&quot;below note&quot;</span><br><span class="line">Other Lilypond code                                         LP: (block of code) :LP (each delimeter at start of its line)</span><br><span class="line">Ignored                                                     % a comment</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LilyPond 是什麼？(&lt;strong&gt;&lt;a href=&quot;https://lilypond.org/&quot;&gt;https://lilypond.org/&lt;/a&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LilyPond (荷花池) 是一個音樂雕版軟件，致力產生最高質量的樂譜。它把傳統音樂雕版印刷的美學，呈現在計算機打印的樂譜上。LilyPond 是自由軟件，也是 GNU Project 的一部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;計算機軟件的內核是將接收到的數據進行計算並輸出，LilyPond 也不例外。我們需要按照 LilyPond 開發者制定的規則編寫樂譜源碼，然後使用 LilyPond 程序將源代碼轉換爲 PNG、PDF、SVG、MIDI 等格式的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;荷花池（線譜）的運作流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照 lilypond 開發者制定的規則編寫「LilyPond 樂譜源碼」。&lt;/li&gt;
&lt;li&gt;使用 lilypond 程序將「LilyPond 樂譜源碼」轉換爲我們期望的「樂譜」文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;這裏的 lilypond.exe 程序與我們日常使用的軟件有所不同，需要通過命令行的方式來調用執行。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;不過 LilyPond 主要用於生成五線譜，若想生成簡譜我們還需要藉助另外一個工具：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;與上面不同，我們不再按照 LilyPond 的規則編寫「LilyPond 樂譜源碼」而是按照 jianpuly 開發者制定的規則編寫「Jianpuly 簡譜源碼」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;荷花池（簡譜）的運作流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照 jianpuly 開發者制定的規則編寫「Jianpuly 簡譜源碼」。&lt;/li&gt;
&lt;li&gt;使用 jianpuly 腳本將「Jianpuly 簡譜源碼」轉換爲「LilyPond 樂譜源碼」。&lt;/li&gt;
&lt;li&gt;使用 lilypond 程序將「LilyPond 樂譜源碼」轉換爲我們期望的「樂譜」文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;note info no-icon&quot;&gt;&lt;p&gt;與 lilypond 類似，jianpu-ly.py 需要通過命令行的方式經 python 調用執行。&lt;/p&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="學點音樂" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E5%AD%B8%E9%BB%9E%E9%9F%B3%E6%A8%82/"/>
    
    
    <category term="五線譜" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E4%BA%94%E7%B7%9A%E8%AD%9C/"/>
    
    <category term="簡譜" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E7%B0%A1%E8%AD%9C/"/>
    
    <category term="lilypond" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/lilypond/"/>
    
  </entry>
  
  <entry>
    <title>crc-libc</title>
    <link href="https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mq002z10rqddw83ul7.html"/>
    <id>https://sulfurandcu.github.io/sulfurandcu.io/clnyhr2mq002z10rqddw83ul7.html</id>
    <published>2023-03-29T03:29:54.000Z</published>
    <updated>2023-03-29T03:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<center><a href="https://github.com/sulfurandcu/crc-lib">https://github.com/sulfurandcu/crc-lib</a></center><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0xbb3d residue=0x0000</span><br><span class="line"> * class: attested</span><br><span class="line"> * alias: CRC-16, CRC-16/ARC, CRC-16/IBM, CRC-16/LHA</span><br><span class="line"> */</span><br><span class="line">CRC_16_8005_0000_1_1_0000, // check=0xbb3d</span><br><span class="line">CRC_16_ARC,</span><br><span class="line">CRC_16_IBM,</span><br><span class="line">CRC_16_LHA,</span><br><span class="line">/**</span><br><span class="line"> * brief: width=16 poly=0x8005 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xfee8 residue=0x0000</span><br><span class="line"> * class: attested</span><br><span class="line"> * alias: CRC-16/UMTS, CRC-16/BUYPASS, CRC-16/VERIFONE</span><br><span class="line"> */</span><br><span class="line">CRC_16_8005_0000_0_0_0000, // check=0xfee8</span><br><span class="line">CRC_16_UMTS,</span><br><span class="line">CRC_16_BUYPASS,</span><br><span class="line">CRC_16_VERIFONE,</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>目前支持的 crc 種類有：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum crc_16_type_t</span><br><span class="line">&#123;</span><br><span class="line">    #if crc_16_poly_8005_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0xbb3d residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16, CRC-16/ARC, CRC-16/IBM, CRC-16/LHA</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_1_1_0000, // check=0xbb3d</span><br><span class="line">    CRC_16_ARC,</span><br><span class="line">    CRC_16_IBM,</span><br><span class="line">    CRC_16_LHA,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xfee8 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/UMTS, CRC-16/BUYPASS, CRC-16/VERIFONE</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_0_0_0000, // check=0xfee8</span><br><span class="line">    CRC_16_UMTS,</span><br><span class="line">    CRC_16_BUYPASS,</span><br><span class="line">    CRC_16_VERIFONE,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0xFFFF check=0x44c2 residue=0xb001</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MAXIM, CRC-16/MAXIM-DOW</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_1_1_FFFF, // check=0x44c2</span><br><span class="line">    CRC_16_MAXIM,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=1 refout=1 xorout=0x0000 check=0x4b37 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MODBUS</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_1_1_0000, // check=0x4b37</span><br><span class="line">    CRC_16_MODBUS,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x800D refin=0 refout=0 xorout=0x0000 check=0x9ecf residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DDS-110</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_800D_0_0_0000, // check=0x9ecf</span><br><span class="line">    CRC_16_DDS110,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=1 refout=1 xorout=0xFFFF check=0xb4c8 residue=0xb001</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/USB</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_1_1_FFFF, // check=0xb4c8</span><br><span class="line">    CRC_16_USB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0xaee7 residue=0x0000</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/CMS</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_0_0_0000, // check=0xaee7</span><br><span class="line">    CRC_16_CMS,</span><br><span class="line">    #endif</span><br><span class="line">    #if crc_16_poly_1021_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=0 refout=0 xorout=0xFFFF check=0xd64e residue=0x1d0f</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/GENIBUS, CRC-16/DARC, CRC-16/EPC, CRC-16/EPC-C1G2, CRC-16/I-CODE</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_0_0_FFFF, // check=0xd64e</span><br><span class="line">    CRC_16_GENIBUS,</span><br><span class="line">    CRC_16_DARC,</span><br><span class="line">    CRC_16_EPC,</span><br><span class="line">    CRC_16_EPC_C1G2,</span><br><span class="line">    CRC_16_ICODE,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=0 refout=0 xorout=0xFFFF check=0xce3c residue=0x1d0f</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/GSM</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_0_0_FFFF, // check=0xce3c</span><br><span class="line">    CRC_16_GSM,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0x29b1 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/CCITT-FALSE, CRC-16/IBM-3740, CRC-16/AUTOSAR</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_0_0_0000, // check=0x29b1</span><br><span class="line">    CRC_16_CCITT_FALSE,</span><br><span class="line">    CRC_16_IBM_3740,</span><br><span class="line">    CRC_16_AUTOSAR,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=1 refout=1 xorout=0xFFFF check=0x906e residue=0xf0b8</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/X-25, CRC-16/IBM-SDLC, CRC-16/ISO-HDLC, CRC-16/ISO-IEC-14443-3-B, CRC-B</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_1_1_FFFF, // check=0x906e</span><br><span class="line">    CRC_16_X25,</span><br><span class="line">    CRC_16_IBM_SDLC,</span><br><span class="line">    CRC_16_ISO_HDLC,</span><br><span class="line">    CRC_16_ISO_IEC_14443_3_B,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xC6C6 refin=1 refout=1 xorout=0x0000 check=0xbf05 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/ISO-IEC-14443-3-A, CRC-A</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_C6C6_1_1_0000, // check=0xbf05</span><br><span class="line">    CRC_16_ISO_IEC_14443_3_A,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0x2189 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/CCITT, CRC-16/CCITT-TRUE, CRC-16/KERMIT, CRC-16/BLUETOOTH, CRC-16/V-41-LSB</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_1_1_0000, // check=0x2189</span><br><span class="line">    CRC_16_CCITT,</span><br><span class="line">    CRC_16_CCITT_TRUE,</span><br><span class="line">    CRC_16_KERMIT,</span><br><span class="line">    CRC_16_BLUETOOTH,</span><br><span class="line">    CRC_16_V_41_LSB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=1 refout=1 xorout=0x0000 check=0x6f91 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MCRF4XX</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_1_1_0000, // check=0x6f91</span><br><span class="line">    CRC_16_MCRF4XX,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xB2AA refin=1 refout=1 xorout=0x0000 check=0x63d0 residue=0x0000</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/RIELLO</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_B2AA_1_1_0000, // check=0x63d0</span><br><span class="line">    CRC_16_RIELLO,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x1D0F refin=0 refout=0 xorout=0x0000 check=0xe5cc residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/AUG-CCITT, CRC-16/SPI-FUJITSU</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_1D0F_0_0_0000, // check=0xe5cc</span><br><span class="line">    CRC_16_AUG_CCITT,</span><br><span class="line">    CRC_16_SPI_FUJITSU,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x31c3 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/XMODEM, CRC-16/ACORN, CRC-16/LTE, CRC-16/V-41-MSB, XMODEM, YMODEM, ZMODEM</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_0_0_0000, // check=0x31c3</span><br><span class="line">    CRC_16_XMODEM,</span><br><span class="line">    CRC_16_YMODEM,</span><br><span class="line">    CRC_16_ZMODEM,</span><br><span class="line">    CRC_16_ACORN,</span><br><span class="line">    CRC_16_LTE,</span><br><span class="line">    CRC_16_V_41_MSB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x89EC refin=1 refout=1 xorout=0x0000 check=0x26b1 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/TMS37157</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_89EC_1_1_0000, // check=0x26b1</span><br><span class="line">    CRC_16_TMS37157,</span><br><span class="line">    #endif</span><br><span class="line">    #if crc_16_poly_xxxx_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x0589 init=0x0000 refin=0 refout=0 xorout=0x0001 check=0x007e residue=0x0589</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DECT-R, R-CRC-16</span><br><span class="line">     */</span><br><span class="line">    CRC_16_0589_0000_0_0_0001, // check=0x007e</span><br><span class="line">    CRC_16_DECT_R,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x0589 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x007f residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DECT-X, X-CRC-16</span><br><span class="line">     */</span><br><span class="line">    CRC_16_0589_0000_0_0_0000, // check=0x007f</span><br><span class="line">    CRC_16_DECT_X,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8bb7 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xd0db residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/T10-DIF</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8BB7_0000_0_0_0000, // check=0xd0db</span><br><span class="line">    CRC_16_T10_DIF,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x3D65 init=0x0000 refin=1 refout=1 xorout=0xFFFF check=0xea82 residue=0x66c5</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/DNP</span><br><span class="line">     */</span><br><span class="line">    CRC_16_3D65_0000_1_1_FFFF, // check=0xea82</span><br><span class="line">    CRC_16_DNP,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x3d65 init=0x0000 refin=0 refout=0 xorout=0xFFFF check=0xc2b7 residue=0xa366</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/EN-13757</span><br><span class="line">     */</span><br><span class="line">    CRC_16_3D65_0000_0_0_FFFF, // check=0xc2b7</span><br><span class="line">    CRC_16_EN_13757,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0xa097 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x0fb3 residue=0x0000</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/TELEDISK</span><br><span class="line">     */</span><br><span class="line">    CRC_16_A097_0000_0_0_0000, // check=0x0fb3</span><br><span class="line">    CRC_16_TELEDISK,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0xc867 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0x4c06 residue=0x0000</span><br><span class="line">     * class: academic</span><br><span class="line">     * alias: CRC-16/CDMA2000</span><br><span class="line">     */</span><br><span class="line">    CRC_16_C867_FFFF_0_0_0000, // check=0x4c06</span><br><span class="line">    CRC_16_CDMA2000,</span><br><span class="line">    #endif</span><br><span class="line">&#125; crc_16_type_t;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;center&gt;&lt;a href=&quot;https://github.com/sulfurandcu/crc-lib&quot;&gt;https://github.com/sulfurandcu/crc-lib&lt;/a&gt;&lt;/center&gt;&lt;br&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0xbb3d residue=0x0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * class: attested&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * alias: CRC-16, CRC-16/ARC, CRC-16/IBM, CRC-16/LHA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_8005_0000_1_1_0000, // check=0xbb3d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_ARC,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_IBM,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_LHA,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * brief: width=16 poly=0x8005 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xfee8 residue=0x0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * class: attested&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * alias: CRC-16/UMTS, CRC-16/BUYPASS, CRC-16/VERIFONE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_8005_0000_0_0_0000, // check=0xfee8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_UMTS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_BUYPASS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CRC_16_VERIFONE,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://sulfurandcu.github.io/sulfurandcu.io/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="crc" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/crc/"/>
    
    <category term="循環冗餘校驗算法" scheme="https://sulfurandcu.github.io/sulfurandcu.io/tags/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
