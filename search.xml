<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二〇二一拼音漫遊</title>
    <url>/sulfurandcu.io/clnyhr2mh001m10rq3qr434d7.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnyhr2mh001m10rq3qr434d7/2021.A.bopomofo.Odyssey.png"></p>
]]></content>
      <categories>
        <category>語言文字</category>
      </categories>
      <tags>
        <tag>漢語拼音</tag>
        <tag>注音符號</tag>
      </tags>
  </entry>
  <entry>
    <title>黃金時代隨風而逝</title>
    <url>/sulfurandcu.io/clnyhr2mh001p10rq8w62htd4.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnyhr2mh001p10rq8w62htd4/cast-away-illusions.jpg"></p>
<center><a href="https://dribbble.com/shots/16430646-CAST-AWAY-ILLUSIONS-PREPARE-FOR-STRUGGLE">囗囗囗囗　囗囗囗囗</a></center>

<br>

<center>
黃金時代<br>
1996 1997 1998 1999 2000<br>
2001 2002 2003 2004 2005<br>
2006 2007 2008 2009 2010<br>
2011 2012 2013 2014 2015<br>
2016 2017 2018 2019 2020<br>
</center>
<br>

<span id="more"></span>

<center>
白銀時代<br>
2021 2022 2023 2024 2025<br>
2026 2027 2028 2029 2030<br>
2031 2032 2033 2034 2035<br>
2036 2037 2038 2039 2040<br>
</center>
<br>
<center>
青銅時代<br>
2041 2042 2043 2044 2045<br>
2046 2047 2048 2049 2050<br>
2051 2052 2053 2054 2055<br>
2056 2057 2058 2059 2060<br>
</center>
<br>
<center>
黑鐵時代<br>
2061 2062 2063 2064 2065<br>
2066 2067 2068 2069 2070<br>
2071 2072 2073 2074 2075<br>
2076 2077 2078 2079 2080<br>
</center>
<br>
]]></content>
      <categories>
        <category>白銀時代</category>
      </categories>
  </entry>
  <entry>
    <title>張三同志姓名字號</title>
    <url>/sulfurandcu.io/clnyhr2mi001u10rq4248hyf0.html</url>
    <content><![CDATA[<center>張三，姓張名弎，字斯岸，號弋山道人，早年曾任刑部侍郎，人稱司案先生。</center>
<br>
]]></content>
      <categories>
        <category>白銀時代</category>
      </categories>
  </entry>
  <entry>
    <title>搭建一個基於 docsify 的文檔系統</title>
    <url>/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/architecture.png"></p>
<center>・文檔系統架構圖・</center>

<span id="more"></span>

<br>

<div class="note info"><p><code>#web</code> <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a></p>
</div>

<div class="note info"><p><code>#ssh</code> <a href="mailto:&#x6c;&#111;&#99;&#x61;&#108;&#x68;&#x6f;&#115;&#x74;&#x40;&#49;&#x32;&#55;&#x2e;&#48;&#46;&#x30;&#46;&#49;">&#x6c;&#111;&#99;&#x61;&#108;&#x68;&#x6f;&#115;&#x74;&#x40;&#49;&#x32;&#55;&#x2e;&#48;&#46;&#x30;&#46;&#49;</a> 📢 Password:password</p>
</div>

<div class="note info"><p><code>#svn</code> <a href="http://svn.sulfurandcu.com/doc">http://svn.sulfurandcu.com/doc</a></p>
</div>


<h2 id="系統架構"><a href="#系統架構" class="headerlink" title="系統架構"></a>系統架構</h2><p>該系統由「一個代碼庫」「若干開發者」和「一臺服務器」組成。</p>
<h3 id="代碼庫"><a href="#代碼庫" class="headerlink" title="代碼庫"></a>代碼庫</h3><p>代碼庫（SVN）中有一份文檔系統的源碼，裏面放着文檔系統的配置文件和各個項目的文檔文件。</p>
<h3 id="開發者"><a href="#開發者" class="headerlink" title="開發者"></a>開發者</h3><p>開發者可以將 SVN 中的文檔系統源碼 checkout 至本地進行編輯、預覽。修改完畢後再提交回去。</p>
<h3 id="服務器"><a href="#服務器" class="headerlink" title="服務器"></a>服務器</h3><p>服務器中也有一份從 SVN 中 checkout 出來的文檔系統源碼，這些內容被一個叫做文檔網站生成器的軟件動態轉換成網頁在 3000 端口以 HTTP 的形式對外提供訪問。這樣我們就可以通過瀏覽器以輸入 IP 地址加端口的形式訪問該文檔系統。另外該服務器上還運行着一個週期任務，這個任務每隔 15 分鐘（準確地說是在00分、15分、30分、45分的時候）<strong>從 SVN 服務器中</strong>更新一次文檔系統源碼。這樣就實現了文檔系統的自動更新。</p>
<h2 id="使用說明"><a href="#使用說明" class="headerlink" title="使用說明"></a>使用說明</h2><h3 id="第一步：搭建環境"><a href="#第一步：搭建環境" class="headerlink" title="第一步：搭建環境"></a>第一步：搭建環境</h3><p>➀ 安裝「node.js」（一個基於 Chrome V8 引擎 的 JavaScript 運行時環境）</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.png"></p>
<center>
<a href="https://nodejs.org/" target="_blank">https://nodejs.org/</a>
</center><br>

<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.install.1.png"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.install.2.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.install.3.png"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.install.4.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.install.5.png"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.install.6.png"></div></div></div>

<p>➁ 安裝「docsify」（一個使用 JavaScript 編寫的文檔網站生成器）</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/docsify.png"></p>
<center>
<a href="https://docsify.js.org/" target="_blank">https://docsify.js.org/</a>
</center><br>

<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/docsify.install.png"></p>
<center>
npm i -g docsify-cli
</center>

<div class="note warning"><p>安裝完 node.js 之後就可以使用 npm 指令安裝 docsify-cli 了</p>
</div>

<h3 id="第二步：建立文檔"><a href="#第二步：建立文檔" class="headerlink" title="第二步：建立文檔"></a>第二步：建立文檔</h3><p>本文檔系統的框架已經建好並且已經提交至 SVN 服務器中：</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/document.cloud.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://svn.sulfurandcu.com/doc</span><br></pre></td></tr></table></figure>

<h3 id="第三步：預覽效果"><a href="#第三步：預覽效果" class="headerlink" title="第三步：預覽效果"></a>第三步：預覽效果</h3><p>將上述文檔框架下載到本地，在其根目錄下執行 docsify serve 命令啓動一個本地服務器，就可以在本地預覽效果。</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/document.local.png"></p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/document.serve.png"></p>
<center>
docsify s
</center>

<div class="note warning"><p>點擊 <a href="http://localhost:3000/">http://localhost:3000</a> 即可預覽</p>
</div>

<h3 id="第四步：進入正軌（編輯文檔、本地預覽、提交變更）"><a href="#第四步：進入正軌（編輯文檔、本地預覽、提交變更）" class="headerlink" title="第四步：進入正軌（編輯文檔、本地預覽、提交變更）"></a>第四步：進入正軌（編輯文檔、本地預覽、提交變更）</h3><p>搭建好開發環境、將〈＃項目文檔〉下載到本地且知道怎麼預覽以後，就可以開始編輯、預覽、提交了，跟代碼的編輯、調試、提交沒什麼兩樣！</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/document.write.png"></p>
<p>文章使用輕量級標記語言 <a href="https://www.markdownguide.org/basic-syntax/">markdown</a> 編寫；圖例使用 <a href="https://www.diagrams.net/">draw.io</a> 繪製。</p>
<h2 id="技術細節"><a href="#技術細節" class="headerlink" title="技術細節"></a>技術細節</h2><p>這部分內容是文檔系統搭建的一些具體細節，在這裏記錄一下以供後續維護人員參考。需要說明的一點是，當前所使用的服務器運行的是 Windows 操作系統，因此以下操作均基於該操作系統。</p>
<h3 id="自動更新"><a href="#自動更新" class="headerlink" title="自動更新"></a>自動更新</h3><p>在 Windows 系統中，使用系統自帶的任務計劃程序實現：在〈計算機管理・任務計劃程序〉中創建一個週期任務，每隔一段時間執行一次以下腳本。</p>
<figure class="highlight py"><figcaption><span>doc.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;svn up \&quot;e:/＃文檔系統\&quot; --non-interactive&quot;</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure>

<div class="note info"><p>任務計劃程序配置好之後重啓電腦不影響其運行</p>
</div>

<h3 id="手動更新"><a href="#手動更新" class="headerlink" title="手動更新"></a>手動更新</h3><p>改動提交之後想立即更新至文檔服務器應該怎麼做呢？</p>
<p>遠程連接到服務器，手動執行一下 doc.py 即可。</p>
<h3 id="手動啓動-docsify-服務"><a href="#手動啓動-docsify-服務" class="headerlink" title="手動啓動 docsify 服務"></a>手動啓動 docsify 服務</h3><p>電腦關機後 docsify 服務也會隨之停止，因此每次開機後都要手動啓動 docsify 服務。我嘗試過啓動後自動運行，但是經常會執行失敗。</p>
<h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h3 id="服務器重啓後網頁無法訪問！"><a href="#服務器重啓後網頁無法訪問！" class="headerlink" title="服務器重啓後網頁無法訪問！"></a>服務器重啓後網頁無法訪問！</h3><p>檢查 docsify 服務是否已經啓動。</p>
<h3 id="修改提交之後內容沒有更新！"><a href="#修改提交之後內容沒有更新！" class="headerlink" title="修改提交之後內容沒有更新！"></a>修改提交之後內容沒有更新！</h3><p>首先看週期更新任務是否正常執行。</p>
<p>如果週期更新任務沒有問題，那麼有可能是管理員同志的公司帳號密碼修改過，而文檔服務器中 svn 的訪問密碼沒有同步修改導致的。</p>
<div class="note warning"><p>系統會強制讓職工每隔兩個月修改一次密碼</p>
</div>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>docsify</tag>
        <tag>文檔系統</tag>
      </tags>
  </entry>
  <entry>
    <title>思源字體使用指南</title>
    <url>/sulfurandcu.io/clnyhr2mj002010rq1hzhgzb2.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnyhr2mj002010rq1hzhgzb2/cover.png"></p>
<span id="more"></span>

<p>思源字體，阿逗比的開源字體項目之一，目前已經出了兩款：思源黑體和思源宋體。思源系列的字體屬於泛中日韓字體，即支持中文、日文、韓文三種文字，其中中文又分爲大陸字形、香港字形和臺灣字形。</p>
<ul>
<li>中文（大陸）<ul>
<li>大陸獨佔的漢字－簡體</li>
<li>大陸特色的漢字－繁體</li>
</ul>
</li>
<li>中文（香港）<ul>
<li>香港特色的漢字－繁體</li>
</ul>
</li>
<li>中文（臺灣）<ul>
<li>臺灣特色的漢字－繁體</li>
</ul>
</li>
<li>日文（日本）<ul>
<li>日本特色的漢字＋假名</li>
</ul>
</li>
<li>韓文（朝韓）<ul>
<li>朝韓特色的漢字＋諺文</li>
</ul>
</li>
</ul>
<h1 id="思源宋體"><a href="#思源宋體" class="headerlink" title="思源宋體"></a>思源宋體</h1><p><strong>OTF 語言</strong><br>ZIP : 日語・七個 otf 文件對應七個字重・Language Specific OTFs J・Source Han Serif<br>ZIP : 韓語・七個 otf 文件對應七個字重・Language Specific OTFs K・Source Han Serif K<br>ZIP : 簡中・七個 otf 文件對應七個字重・Language Specific OTFs S・Source Han Serif SC<br>ZIP : 臺中・七個 otf 文件對應七個字重・Language Specific OTFs T・Source Han Serif TC<br>ZIP : 港中・七個 otf 文件對應七個字重・Language Specific OTFs T・Source Han Serif HC</p>
<p><strong>OTF 地區</strong><br>ZIP : 日本・七個 otf 文件對應七個字重・Region Specific Subset OTFs JP・Source Han Serif JP<br>ZIP : 韓國・七個 otf 文件對應七個字重・Region Specific Subset OTFs KR・Source Han Serif KR<br>ZIP : 大陸・七個 otf 文件對應七個字重・Region Specific Subset OTFs CN・Source Han Serif CN<br>ZIP : 臺灣・七個 otf 文件對應七個字重・Region Specific Subset OTFs TW・Source Han Serif TW<br>ZIP : 香港・七個 otf 文件對應七個字重・Region Specific Subset OTFs HK・Source Han Serif HK</p>
<p><strong>OTF 語言</strong>（上述文件的歸檔包）<br>ZIP : All Static Language Specific OTFs</p>
<p><strong>OTF 地區</strong>（上述文件的歸檔包）<br>ZIP : All Static Region Specific Subset OTFs</p>
<p><strong>OTC 版本</strong><br>ZIP : 全部・七個 ttc 文件對應七個字重・All Static Language Specific OTCs・Source Han Serif</p>
<p><strong>SuperOTC 版本</strong><br>ZIP : 全部・一個 ttc 文件包含所有字重・Static Super OTC・Source Han Serif</p>
<p><strong>All Variable Fonts</strong> (OTF, TTF, OTC, WOFF2)</p>
<ul>
<li>OTF<ul>
<li>OTF 語言（五個 otf 文件對應五種字形）</li>
<li>OTF 地區（五個 otf 文件對應五種字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 語言（五個 ttf 文件對應五種字形）</li>
<li>TTF 地區（五個 ttf 文件對應五種字形）</li>
</ul>
</li>
<li>OTC<ul>
<li>一個 otf.ttc 文件（上面 OTF 語言的合集）</li>
<li>一個 ttf.ttc 文件（上面 TTF 語言的合集）</li>
</ul>
</li>
<li>WOFF2<ul>
<li>OTF<ul>
<li>OTF 語言（五個 otf.woff2 文件對應五種字形）</li>
<li>OTF 地區（五個 otf.woff2 文件對應五種字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 語言（五個 ttf.woff2 文件對應五種字形）</li>
<li>TTF 地區（五個 ttf.woff2 文件對應五種字形）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>思源宋體的七個字重：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 - extralight</span><br><span class="line">300 - light</span><br><span class="line">400 - regular</span><br><span class="line">500 - medium</span><br><span class="line">600 - semibold</span><br><span class="line">700 - bold</span><br><span class="line">900 - heavy</span><br></pre></td></tr></table></figure>


<h1 id="思源黑體"><a href="#思源黑體" class="headerlink" title="思源黑體"></a>思源黑體</h1><p><strong>OTF 語言</strong><br>ZIP : 日語・七個 otf 文件對應七個字重・Language Specific OTFs J・Source Han Sans<br>ZIP : 韓語・七個 otf 文件對應七個字重・Language Specific OTFs K・Source Han Sans K<br>ZIP : 簡中・七個 otf 文件對應七個字重・Language Specific OTFs S・Source Han Sans SC<br>ZIP : 臺中・七個 otf 文件對應七個字重・Language Specific OTFs T・Source Han Sans TC<br>ZIP : 港中・七個 otf 文件對應七個字重・Language Specific OTFs T・Source Han Sans HC</p>
<p><strong>OTF 語言</strong>（HW）<br>ZIP : 日語・七個 otf 文件對應七個字重・Language Specific OTFs J HW・Source Han Sans HW<br>ZIP : 韓語・七個 otf 文件對應七個字重・Language Specific OTFs K HW・Source Han Sans K HW<br>ZIP : 簡中・七個 otf 文件對應七個字重・Language Specific OTFs S HW・Source Han Sans SC HW<br>ZIP : 臺中・七個 otf 文件對應七個字重・Language Specific OTFs T HW・Source Han Sans TC HW<br>ZIP : 港中・七個 otf 文件對應七個字重・Language Specific OTFs T HW・Source Han Sans HC HW</p>
<p><strong>OTF 地區</strong><br>ZIP : 日本・七個 otf 文件對應七個字重・Region Specific Subset OTFs JP・Source Han Sans JP<br>ZIP : 韓國・七個 otf 文件對應七個字重・Region Specific Subset OTFs KR・Source Han Sans KR<br>ZIP : 大陸・七個 otf 文件對應七個字重・Region Specific Subset OTFs CN・Source Han Sans CN<br>ZIP : 臺灣・七個 otf 文件對應七個字重・Region Specific Subset OTFs TW・Source Han Sans TW<br>ZIP : 香港・七個 otf 文件對應七個字重・Region Specific Subset OTFs HK・Source Han Sans HK</p>
<p><strong>OTF 語言</strong>（上述文件的歸檔包）<br>ZIP : All Static Language Specific OTFs</p>
<p><strong>OTF 地區</strong>（上述文件的歸檔包）<br>ZIP : All Static Region Specific Subset OTFs</p>
<p><strong>OTC 版本</strong><br>ZIP : 全部・七個 ttc 文件對應七個字重・All Static Language Specific OTCs・Source Han Sans</p>
<p><strong>SuperOTC 版本</strong><br>ZIP : 全部・一個 ttc 文件包含所有字重・Static Super OTC・Source Han Sans</p>
<p><strong>All Variable Fonts</strong> (OTF, TTF, OTC, WOFF2)</p>
<ul>
<li>OTF<ul>
<li>OTF 語言（五個 otf 文件對應五種字形）</li>
<li>OTF 地區（五個 otf 文件對應五種字形）</li>
<li>OTF 等寬（五個 otf 文件對應五種字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 語言（五個 ttf 文件對應五種字形）</li>
<li>TTF 地區（五個 ttf 文件對應五種字形）</li>
<li>TTF 等寬（五個 ttf 文件對應五種字形）</li>
</ul>
</li>
<li>OTC<ul>
<li>一個 otf.ttc 文件（上面 OTF 語言的合集）</li>
<li>一個 ttf.ttc 文件（上面 TTF 語言的合集）</li>
<li>一個 otf.ttc 文件（上面 OTF 等寬的合集）</li>
<li>一個 ttf.ttc 文件（上面 TTF 等寬的合集）</li>
</ul>
</li>
<li>WOFF2<ul>
<li>OTF<ul>
<li>OTF 語言（五個 otf.woff2 文件對應五種字形）</li>
<li>OTF 地區（五個 otf.woff2 文件對應五種字形）</li>
<li>OTF 等寬（五個 otf.woff2 文件對應五種字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 語言（五個 ttf.woff2 文件對應五種字形）</li>
<li>TTF 地區（五個 ttf.woff2 文件對應五種字形）</li>
<li>TTF 等寬（五個 ttf.woff2 文件對應五種字形）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>思源黑體的七個字重：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 - extralight</span><br><span class="line">300 - light</span><br><span class="line">    - normal</span><br><span class="line">400 - regular</span><br><span class="line">500 - medium</span><br><span class="line">700 - bold</span><br><span class="line">900 - heavy</span><br></pre></td></tr></table></figure>


<h1 id="標準字重"><a href="#標準字重" class="headerlink" title="標準字重"></a>標準字重</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 - Thin</span><br><span class="line">200 - Extra Light</span><br><span class="line">300 - Light</span><br><span class="line">400 - Semi Light (Normal)</span><br><span class="line">500 - Medium</span><br><span class="line">600 - Semi Bold</span><br><span class="line">700 - Bold</span><br><span class="line">800 - Extra Bold</span><br><span class="line">900 - Heavy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>語言文字</category>
      </categories>
      <tags>
        <tag>思源字體</tag>
      </tags>
  </entry>
  <entry>
    <title>DLT645</title>
    <url>/sulfurandcu.io/clnyhr2ml002810rq6pxn7cmn.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>DLT645</tag>
        <tag>多功能電能表通信協議</tag>
        <tag>電力</tag>
        <tag>行業標準</tag>
      </tags>
  </entry>
  <entry>
    <title>網頁字體使用指南</title>
    <url>/sulfurandcu.io/clnyhr2mj002210rq74hmcdni.html</url>
    <content><![CDATA[<p>在被 fontmin 和 font-spider 這倆貨虐得體無完膚之後，我決定試試<a href="https://hsingko.github.io/post/compress_webfont/">這篇文章</a>中提到的另一個字體壓縮工具</p>
<p><strong><center>“<a href="https://github.com/fonttools/fonttools">fonttools</a>”</center></strong></p>
<span id="more"></span>

<h3 id="網頁使用中文字體的方案？"><a href="#網頁使用中文字體的方案？" class="headerlink" title="網頁使用中文字體的方案？"></a>網頁使用中文字體的方案？</h3><ol start="0">
<li>使用安全字體</li>
<li>使用壓縮字體</li>
<li>谷歌字體接口（google fonts api）</li>
</ol>
<p>大多數網站的中文字體使用的都是安全字體，也就是機器中原生攜帶的字體，這樣的好處是無需通過網絡傳輸字體文件，也就不存在加載過慢的問題。安全字體好用是好用，但是架不住它醜啊，否則我也不會捯飭字體壓縮了不是！</p>
<p>使用谷歌的服務就意味着要拒絕來自不懂得科學上網的讀者的訪問，這是我所不能接受的。</p>
<p>所以，唯一的選擇就是“字體壓縮”！</p>
<h3 id="爲什麼要對字體進行壓縮？"><a href="#爲什麼要對字體進行壓縮？" class="headerlink" title="爲什麼要對字體進行壓縮？"></a>爲什麼要對字體進行壓縮？</h3><p>這裏的字體指的是漢字（泛中日韓）字體，拉丁字符或者西里爾字符這種字符數量較少的字體的體積通常比較小，沒有壓縮的必要。漢字字體通常收錄幾千上萬個字符，大小能達到幾十兆字節，而常用的漢字不過兩三千，聚焦至單篇文章中可能連一千都不到。倘若每次加載網頁時都要將完整的字體文件下載下來，其加載時間是往往是難以忍受的，這樣我們就要想法子縮減字體文件的體積。巧的是，字體壓縮就是幹這個的。</p>
<p>字體壓縮這麼“中藥”，社區應該非常活躍纔是啊，爲啥像 fontmin 和 font-spider 之類的工具基本都不怎麼維護了呢？</p>
<p>這裏的重要是有前提的，在無利可圖的情況下，沒有人或資本會給自己找不痛快，像我這種閒得蛋疼的除外。所以，知道前提是啥了不？😏</p>
<h3 id="使用-fonttools-進行靜態壓縮！"><a href="#使用-fonttools-進行靜態壓縮！" class="headerlink" title="使用 fonttools 進行靜態壓縮！"></a>使用 fonttools 進行靜態壓縮！</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyftsubset font.ttf --text=$(cat hanzi.txt) --no-hinting</span><br></pre></td></tr></table></figure>

<p>靜態壓縮的問題在於，無法保證文章中不會用到常用字表以外的字。</p>
<h3 id="使用-fonttools-進行動態壓縮！"><a href="#使用-fonttools-進行動態壓縮！" class="headerlink" title="使用 fonttools 進行動態壓縮！"></a>使用 fonttools 進行動態壓縮！</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyftsubset ../font/SourceHanSerifSC-Regular.otf --text=$(rg -e &#x27;[\u&#123;0100&#125;-\u&#123;10ffff&#125;]&#x27; -oN --no-filename|sort|uniq|tr -d &#x27;\n&#x27;) --no-hinting</span><br></pre></td></tr></table></figure>

<p>動態壓縮的問題在於，每次更新文章後都要執行一次字體壓縮流程。</p>
<p>因此流程自動化迫在眉睫！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由於本人太忙（懶），自動化腳本隨緣更新！</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>語言文字</category>
      </categories>
      <tags>
        <tag>網頁字體</tag>
      </tags>
  </entry>
  <entry>
    <title>億枝紅杏兒出牆來</title>
    <url>/sulfurandcu.io/clnyhr2mm002g10rqgzfk3qms.html</url>
    <content><![CDATA[<center><a href="https://www.v2ray.com/awesome/tools.html">神一樣的工具們</a></center>
<center><a href="https://shadowsocks.org/en/index.html">https://shadowsocks.org/en/index.html</a></center>

<span id="more"></span>

<h3 id="真香定律"><a href="#真香定律" class="headerlink" title="真香定律"></a>真香定律</h3><p>更新（2021-05-05）</p>
<p>技術無時無刻不在發展，各種代理方案如雨後春筍般冒出來。新技術雖然一個比一個強大，但是配置起來也確實麻煩，咱畢竟不是專業玩家，日常使用更應注重方便快捷。</p>
<p>最近同事給推薦了一個代理軟件 <a href="https://github.com/Fndroid/clash_for_windows_pkg">clash4windows</a> 還不錯，搭配各路機場，比 <a href="https://github.com/2dust/v2rayN">V2rayN</a> 要好用不少。</p>
<p><a href="https://github.com/Dreamacro/clash/wiki/configuration">官方出品Clash配置文件</a><br><a href="https://v2raytech.com/deep-in-clash-config-file/">深入理解Clash配置文件</a></p>
<h3 id="後起之秀"><a href="#後起之秀" class="headerlink" title="後起之秀"></a>後起之秀</h3><p>更新（2020-03-15）</p>
<p>由於牆的封鎖能力愈來愈強，本文之前所列舉的方案已經不再適用，目前本人已棄用 shadowsocks 轉投 v2ray 的懷抱。</p>
<p>技術文檔：<a href="https://www.v2ray.com/">v2ray site</a><br>技術文檔：<a href="https://toutyrater.github.io/">v2ray 白話文教程 - 原版</a><br>技術文檔：<a href="https://guide.v2fly.org/">v2ray 白話文教程 - 新版</a></p>
<p><a href="https://guide.v2fly.org/basics/vmess.html#%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90">這裏</a>介紹了 v2ray 的工作原理。</p>
<blockquote>
<p>v2ray 可同時開啓多個協議支持，包括 http、socks、shadowsocks、vmess 等。每個協議可單獨設置傳輸載體，比如 TCP、mKCP、http&#x2F;2、WebSocket 等。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vmess + TCP + TLS + Web</span><br><span class="line">Vmess + KCP + TLS + Web</span><br><span class="line">Vmess + HTTP/2 + TLS + Web</span><br><span class="line">Vmess + WebSocket + TLS + Web</span><br><span class="line">Vmess + WebSocket + TLS + Web + CDN</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(HTTP)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(shadowsocks)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(VMess)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br><span class="line"></span><br><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(VMess/TLS/TCP)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(VMess/TLS/KCP)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(VMess/h2/TLS/TCP)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br><span class="line">&#123;瀏覽器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客戶端 inbound &lt;-&gt; V2Ray 客戶端 outbound&#125; &lt;--(VMess/ws/TLS/TCP)--&gt;  &#123;V2Ray 服務器 inbound &lt;-&gt; V2Ray 服務器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目標網站&#125;</span><br></pre></td></tr></table></figure>

<p>上面所陳列的若干技術文檔對實現原理進行了詳細說明，不過真要根據上述理論做出一套現實可行的代理方案出來，對於我這種半瓶水玩家來說還是有點難度的，還是老老實實按別人的教程來吧：<a href="http://iqotom.com/?p=1327">Vmess + WebSocket + TLS(domain) + Web(Caddy) + CDN(Cloudflare) 方案復活</a>。</p>
<h3 id="懵懂時期"><a href="#懵懂時期" class="headerlink" title="懵懂時期"></a>懵懂時期</h3><p>以下方案在 2018 年前後尚能對付着用，現在（2020）基本上是一封一個準兒，牆愈來愈高，吾輩還是要跟上時代的步伐呀！</p>
<h4 id="使用-bbr-加速"><a href="#使用-bbr-加速" class="headerlink" title="使用 bbr 加速"></a>使用 bbr 加速</h4><p><strong>安裝、設置、重啓</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"></span><br><span class="line">sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum --enablerepo=elrepo-kernel install kernel-ml -y</span><br><span class="line"></span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line"></span><br><span class="line">sudo egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \&#x27;</span><br><span class="line"></span><br><span class="line">sudo grub2-set-default 0</span><br><span class="line"></span><br><span class="line">sudo shutdown -r now</span><br></pre></td></tr></table></figure>

<p><strong>重啓過後</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"></span><br><span class="line">echo &#x27;net.core.default_qdisc=fq&#x27; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">echo &#x27;net.ipv4.tcp_congestion_control=bbr&#x27; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br><span class="line"></span><br><span class="line">sudo sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class="line"></span><br><span class="line">sudo sysctl -n net.ipv4.tcp_congestion_control</span><br><span class="line"></span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p><strong>測試工具｜可選</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install httpd -y</span><br><span class="line">sudo systemctl start httpd.service</span><br><span class="line">sudo firewall-cmd --zone=public --permanent --add-service=http</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line">cd /var/www/html</span><br><span class="line">sudo dd if=/dev/zero of=500mb.zip bs=1024k count=500</span><br><span class="line"></span><br><span class="line">http://[your-server-IP]/500mb.zip</span><br></pre></td></tr></table></figure>

<h4 id="服務端工具之-shadowsocks"><a href="#服務端工具之-shadowsocks" class="headerlink" title="服務端工具之 shadowsocks"></a>服務端工具之 shadowsocks</h4><p><strong>程序安裝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python get-pip.py</span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line">pip install shadowsocks</span><br><span class="line">pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U</span><br></pre></td></tr></table></figure>

<p><strong>編輯配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置一：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">  &quot;server_port&quot;: 10235,</span><br><span class="line">  &quot;password&quot;: &quot;Pass3ord&quot;,</span><br><span class="line">  &quot;timeout&quot;: 300,</span><br><span class="line">  &quot;method&quot;: &quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置二：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;port_password&quot;: &#123;</span><br><span class="line">        &quot;10236&quot;: &quot;password&quot;,</span><br><span class="line">        &quot;10237&quot;: &quot;password&quot;</span><br><span class="line">        &quot;10238&quot;: &quot;password&quot;</span><br><span class="line">        &quot;10239&quot;: &quot;password&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;: 300,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>啓動服務</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure>

<h4 id="服務端工具之-shadowsocksR"><a href="#服務端工具之-shadowsocksR" class="headerlink" title="服務端工具之 shadowsocksR"></a>服務端工具之 shadowsocksR</h4><h4 id="服務端工具之-v2ray"><a href="#服務端工具之-v2ray" class="headerlink" title="服務端工具之 v2ray"></a>服務端工具之 v2ray</h4><p><strong>程序安裝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">yum -y install zip unzip</span><br><span class="line">wget https://install.direct/go.sh</span><br><span class="line">bash go.sh</span><br></pre></td></tr></table></figure>

<p><strong>編輯配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/v2ray/config.json</span><br></pre></td></tr></table></figure>

<p><strong>啓動服務</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start v2ray</span><br></pre></td></tr></table></figure>

<h4 id="服務端防火牆-firewalld"><a href="#服務端防火牆-firewalld" class="headerlink" title="服務端防火牆 firewalld"></a>服務端防火牆 firewalld</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install firewalld</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=80/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=443/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=10235/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=10245/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<h4 id="客戶端工具之-shadowrocket"><a href="#客戶端工具之-shadowrocket" class="headerlink" title="客戶端工具之 shadowrocket"></a>客戶端工具之 shadowrocket</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">略.</span><br></pre></td></tr></table></figure>

<h4 id="客戶端工具之-outline"><a href="#客戶端工具之-outline" class="headerlink" title="客戶端工具之 outline"></a>客戶端工具之 outline</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss://base64(method:password)@server-address:port</span><br><span class="line">ss://YWVzLTI1Ni1jZmI6UGFzc3dvcmQ=@xxx.xxx.xxx.xxx:xxxxx</span><br></pre></td></tr></table></figure>

<h3 id="上古時代"><a href="#上古時代" class="headerlink" title="上古時代"></a>上古時代</h3><p>諸位還記得通過修改 host 文件來科學上網的方式嗎，好懷念呀！</p>
]]></content>
      <categories>
        <category>科學上網</category>
      </categories>
      <tags>
        <tag>clash</tag>
        <tag>v2ray</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>別鬧了！費曼先生</title>
    <url>/sulfurandcu.io/clnyhr2mn002j10rqbhpkhcgy.html</url>
    <content><![CDATA[<center>Knowing the name of something is not the same as knowing something.</center>

<br>
]]></content>
      <categories>
        <category>費曼先生</category>
      </categories>
  </entry>
  <entry>
    <title>dƷvorak</title>
    <url>/sulfurandcu.io/clnyhr2mk002410rq6z6893sz.html</url>
    <content><![CDATA[<p><strong><center>The <a href="https://github.com/sulfurandcu/d3vorak">dƷvorak</a> keyboard layout has been released !</center></strong></p>
<br>

<p style="font-family:courier new">
　　　　　　　　1　　2　　3　　4　　5　　6　　7　　8　　9　　0　　[　　]　　 　　　　　　　<br>
　　　　　　　　;　　,　　.　　y　　w　　r　　k　　d　　l　　c　　/　　=　　\　　　　　　　<br>
　　　　　　　　a　　o　　e　　i　　u　　g　　h　　t　　n　　s　　-　　 　　 　　　　　　　<br>
　　　　　　　　'　　q　　x　　j　　v　　b　　f　　m　　p　　z　　 　　 　　 　　　　　　　<br>
</p>

<span id="more"></span>

<br>
]]></content>
      <categories>
        <category>輸入方案</category>
      </categories>
      <tags>
        <tag>鍵位佈局</tag>
        <tag>qwerty</tag>
        <tag>dvorak</tag>
        <tag>dƷvorak</tag>
      </tags>
  </entry>
  <entry>
    <title>拓撲分析算法</title>
    <url>/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu.html</url>
    <content><![CDATA[<p>2022年09月01日於武漢</p>
<pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合終端&lt;br&gt;SCU]
R0---&gt;N1[斷路器&lt;br&gt;9]
R0---&gt;N2[斷路器&lt;br&gt;16]
N1---&gt;N1.1[斷路器&lt;br&gt;7]
N1---&gt;N1.2[斷路器&lt;br&gt;6]
N1---&gt;N1.3[斷路器&lt;br&gt;10]
N1---&gt;N1.4[斷路器&lt;br&gt;12]
N2---&gt;N2.1[斷路器&lt;br&gt;18]
N2---&gt;N2.2[斷路器&lt;br&gt;19]
N2---&gt;N2.3[斷路器&lt;br&gt;14]
N1.1---&gt;N1.1.1[斷路器&lt;br&gt;3]
N1.1---&gt;N1.1.2[斷路器&lt;br&gt;4]
N1.1---&gt;N1.1.3[斷路器&lt;br&gt;5]
N1.2---&gt;N1.2.1[斷路器&lt;br&gt;8]
N1.2---&gt;N1.2.2[斷路器&lt;br&gt;11]
N1.3---&gt;N1.3.1[斷路器&lt;br&gt;2]
N2.2---&gt;N2.2.1[斷路器&lt;br&gt;13]
N2.2---&gt;N2.2.2[斷路器&lt;br&gt;17]
N1.1.1---&gt;N1.1.1.1[斷路器&lt;br&gt;0]
N1.2.2---&gt;N1.2.2.1[斷路器&lt;br&gt;1]
N2.2.2---&gt;N2.2.2.1[斷路器&lt;br&gt;15]
</pre>

<span id="more"></span>

<h2 id="拓撲識別"><a href="#拓撲識別" class="headerlink" title="拓撲識別"></a>拓撲識別</h2><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.standard.1.png"></p>
<p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.standard.2.png"></p>
<p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.standard.3.png"></p>
<div class="note danger no-icon"><p>本文所述的拓撲分析算法針對的是有時間戳的拓撲識別</p>
</div>

<h2 id="拓撲流程"><a href="#拓撲流程" class="headerlink" title="拓撲流程"></a>拓撲流程</h2><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合終端&lt;br&gt;SCU]--&gt;A2[&quot; &quot;]
R0--&gt;A1[斷路器&lt;br&gt;1]
A1--&gt;B2[&quot; &quot;]
A1--&gt;B1[斷路器&lt;br&gt;2]
B1--&gt;C2[&quot; &quot;]
B1--&gt;C1[斷路器&lt;br&gt;3]
</pre>

<p>以上面這個簡單的拓撲結構爲例：</p>
<p>當 SCU 給一號斷路器發送拓撲信號發生指令後一號斷路器會存儲一條發生記錄。</p>
<p>當 SCU 給二號斷路器發送拓撲信號發生指令後二號斷路器會存儲一條發生記錄，此時一號斷路器會識別到拓撲信號並存儲一條識別記錄，並且這兩條記錄中的時間基本一致。</p>
<p>當 SCU 給三號斷路器發送拓撲信號發生指令後三號斷路器會存儲一條發生記錄，此時一號斷路器和二號斷路器均會識別到拓撲信號並存儲一條識別記錄，並且這三條記錄中的時間基本一致。</p>
<p>最終：</p>
<ul>
<li>一號斷路器總計存儲 3 條拓撲記錄；</li>
<li>二號斷路器總計存儲 2 條拓撲記錄；</li>
<li>三號斷路器總計存儲 1 條拓撲記錄；</li>
</ul>
<p>拓撲信號發生流程結束後，智能融合終端會讀取每臺斷路器中的拓撲記錄，並將數據整理爲以下格式：</p>
<p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.record.png"></p>
<p>然後智能融合終端便可通過本算法以及上述數據計算出所有斷路器之間的拓撲關係。</p>
<div class="note info no-icon"><p>記錄數量：每臺斷路器中拓撲記錄的數量<br>記錄內容：每條拓撲記錄產生時的時間戳</p>
</div>

<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p><strong>核心思想：從末端節點開始，依次尋找每個節點的父節點，最終找到根節點。最後遞歸打印出拓撲關係。</strong></p>
<p>1. 遍歷只有一條記錄的節點（末端節點）遍歷完之後將末端節點的記錄數量置爲零。</p>
<p>2. 遍歷其他大於一條記錄的節點</p>
<p>3. 判斷該節點是否存在與末端節點時間相同的記錄｜如果存在則表示該節點爲末端節點的潛在父節點（並將該節點的記錄數量減一）</p>
<p>4. 拓撲記錄數量最少的那個節點即爲當前末端節點的父節點</p>
<p>5. 更新拓撲網絡（記錄父節點）</p>
<p>6. 更新修改過的記錄數量｜然後開始下一循環｜直至所有記錄數量爲零爲止</p>
<p>7. 最後可以得到每個節點的父節點是誰（父節點爲自身的即爲根節點，可以存在多個根節點）</p>
<p>8. 將上述數據遞歸打印即可得到期望結果</p>
<h2 id="算法詳解"><a href="#算法詳解" class="headerlink" title="算法詳解"></a>算法詳解</h2><p>這裏通過一個示例來描述該算法的邏輯。</p>
<h3 id="遍歷之前的拓撲結構（示例）"><a href="#遍歷之前的拓撲結構（示例）" class="headerlink" title="遍歷之前的拓撲結構（示例）"></a>遍歷之前的拓撲結構（示例）</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合終端&lt;br&gt;SCU]
R0---&gt;N1[斷路器&lt;br&gt;9]
R0---&gt;N2[斷路器&lt;br&gt;16]
N1---&gt;N1.1[斷路器&lt;br&gt;7]
N1---&gt;N1.2[斷路器&lt;br&gt;6]
N1---&gt;N1.3[斷路器&lt;br&gt;10]
N1---&gt;N1.4[斷路器&lt;br&gt;12]
N2---&gt;N2.1[斷路器&lt;br&gt;18]
N2---&gt;N2.2[斷路器&lt;br&gt;19]
N2---&gt;N2.3[斷路器&lt;br&gt;14]
N1.1---&gt;N1.1.1[斷路器&lt;br&gt;3]
N1.1---&gt;N1.1.2[斷路器&lt;br&gt;4]
N1.1---&gt;N1.1.3[斷路器&lt;br&gt;5]
N1.2---&gt;N1.2.1[斷路器&lt;br&gt;8]
N1.2---&gt;N1.2.2[斷路器&lt;br&gt;11]
N1.3---&gt;N1.3.1[斷路器&lt;br&gt;2]
N2.2---&gt;N2.2.1[斷路器&lt;br&gt;13]
N2.2---&gt;N2.2.2[斷路器&lt;br&gt;17]
N1.1.1---&gt;N1.1.1.1[斷路器&lt;br&gt;0]
N1.2.2---&gt;N1.2.2.1[斷路器&lt;br&gt;1]
N2.2.2---&gt;N2.2.2.1[斷路器&lt;br&gt;15]
</pre>

<h3 id="遍歷之前的數據結構（示例）"><a href="#遍歷之前的數據結構（示例）" class="headerlink" title="遍歷之前的數據結構（示例）"></a>遍歷之前的數據結構（示例）</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.0.svg"></p>
<h3 id="第一次遍歷後的拓撲結構"><a href="#第一次遍歷後的拓撲結構" class="headerlink" title="第一次遍歷後的拓撲結構"></a>第一次遍歷後的拓撲結構</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合終端&lt;br&gt;SCU]
R0---&gt;N1[斷路器&lt;br&gt;9]
R0---&gt;N2[斷路器&lt;br&gt;16]
N1---&gt;N1.1[斷路器&lt;br&gt;7]
N1---&gt;N1.2[斷路器&lt;br&gt;6]
N1---&gt;N1.3[斷路器&lt;br&gt;10]
N1---&gt;N1.4[&quot; &quot;]
N2---&gt;N2.1[&quot; &quot;]
N2---&gt;N2.2[斷路器&lt;br&gt;19]
N2---&gt;N2.3[&quot; &quot;]
N1.1---&gt;N1.1.1[斷路器&lt;br&gt;3]
N1.1---&gt;N1.1.2[&quot; &quot;]
N1.1---&gt;N1.1.3[&quot; &quot;]
N1.2---&gt;N1.2.1[&quot; &quot;]
N1.2---&gt;N1.2.2[斷路器&lt;br&gt;11]
N1.3---&gt;N1.3.1[&quot; &quot;]
N2.2---&gt;N2.2.1[&quot; &quot;]
N2.2---&gt;N2.2.2[斷路器&lt;br&gt;17]
N1.1.1---&gt;N1.1.1.1[&quot; &quot;]
N1.2.2---&gt;N1.2.2.1[&quot; &quot;]
N2.2.2---&gt;N2.2.2.1[&quot; &quot;]
</pre>

<h3 id="第一次遍歷後的數據結構"><a href="#第一次遍歷後的數據結構" class="headerlink" title="第一次遍歷後的數據結構"></a>第一次遍歷後的數據結構</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.1.svg"></p>
<h3 id="第二次遍歷後的拓撲結構"><a href="#第二次遍歷後的拓撲結構" class="headerlink" title="第二次遍歷後的拓撲結構"></a>第二次遍歷後的拓撲結構</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合終端&lt;br&gt;SCU]
R0---&gt;N1[斷路器&lt;br&gt;9]
R0---&gt;N2[斷路器&lt;br&gt;16]
N1---&gt;N1.1[斷路器&lt;br&gt;7]
N1---&gt;N1.2[斷路器&lt;br&gt;6]
N1---&gt;N1.3[&quot; &quot;]
N1---&gt;N1.4[&quot; &quot;]
N2---&gt;N2.1[&quot; &quot;]
N2---&gt;N2.2[斷路器&lt;br&gt;19]
N2---&gt;N2.3[&quot; &quot;]
N1.1---&gt;N1.1.1[&quot; &quot;]
N1.1---&gt;N1.1.2[&quot; &quot;]
N1.1---&gt;N1.1.3[&quot; &quot;]
N1.2---&gt;N1.2.1[&quot; &quot;]
N1.2---&gt;N1.2.2[&quot; &quot;]
N2.2---&gt;N2.2.1[&quot; &quot;]
N2.2---&gt;N2.2.2[&quot; &quot;]
</pre>

<h3 id="第二次遍歷後的數據結構"><a href="#第二次遍歷後的數據結構" class="headerlink" title="第二次遍歷後的數據結構"></a>第二次遍歷後的數據結構</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.2.svg"></p>
<h3 id="第三次遍歷後的拓撲結構"><a href="#第三次遍歷後的拓撲結構" class="headerlink" title="第三次遍歷後的拓撲結構"></a>第三次遍歷後的拓撲結構</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合終端&lt;br&gt;SCU]
R0---&gt;N1[斷路器&lt;br&gt;9]
R0---&gt;N2[斷路器&lt;br&gt;16]
N1---&gt;N1.1[&quot; &quot;]
N1---&gt;N1.2[&quot; &quot;]
N1---&gt;N1.3[&quot; &quot;]
N1---&gt;N1.4[&quot; &quot;]
N2---&gt;N2.1[&quot; &quot;]
N2---&gt;N2.2[&quot; &quot;]
N2---&gt;N2.3[&quot; &quot;]
</pre>

<h3 id="第三次遍歷後的數據結構"><a href="#第三次遍歷後的數據結構" class="headerlink" title="第三次遍歷後的數據結構"></a>第三次遍歷後的數據結構</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.3.svg"></p>
<h3 id="遍歷完成之後得到的數據"><a href="#遍歷完成之後得到的數據" class="headerlink" title="遍歷完成之後得到的數據"></a>遍歷完成之後得到的數據</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.x.png"></p>
<h2 id="核心代碼"><a href="#核心代碼" class="headerlink" title="核心代碼"></a>核心代碼</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 計算拓撲關係</span><br><span class="line">while (HaveData &amp;&amp; HaveDataOneRecord)</span><br><span class="line">&#123;</span><br><span class="line">    HaveData = false;</span><br><span class="line">    HaveDataOneRecord = false;</span><br><span class="line"></span><br><span class="line">    for (int idx = 0; idx &lt; TOPO_NODE_NUM; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned int MinNum = 0xFFFFFFFF;</span><br><span class="line">        unsigned int MinIdx = idx;</span><br><span class="line"></span><br><span class="line">        if (TopoNum[idx] &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            HaveData = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (TopoNum[idx] == 1) // 遍歷只有一條記錄的節點（末端節點）</span><br><span class="line">        &#123;</span><br><span class="line">            HaveDataOneRecord = true;</span><br><span class="line"></span><br><span class="line">            TopoNumMod[idx]--;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; TOPO_NODE_NUM; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                if (TopoNum[i] &lt;= 1) // 遍歷其他大於一條記錄的節點</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (int n = 1; n &lt;= TopoSrc[i][0]; ++n) // 判斷該節點是否存在與末端節點時間相同的記錄</span><br><span class="line">                &#123;</span><br><span class="line">                    if (TimeCompare(TopoSrc[idx][1], TopoSrc[i][n], TOPO_TIME_BIAS)) // 4example bias==3 (±3s)</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 如果存在則表示該節點爲末端節點的潛在父節點（並將該節點的記錄數量減一）</span><br><span class="line">                        TopoNumMod[i]--;</span><br><span class="line">                        if (TopoSrc[i][0] &lt; MinNum)</span><br><span class="line">                        &#123;</span><br><span class="line">                            MinNum = TopoSrc[i][0];</span><br><span class="line">                            MinIdx = i; // 查找拓撲記錄數量最少的節點</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TopoNet[idx] = MinIdx; // 拓撲記錄數量最少的那個節點即爲當前末端節點的父節點</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 經過上述步驟，拓撲記錄數量爲一的節點的記錄數量被清零，同時又重新生成了一批新的拓撲記錄數量爲一的節點。</span><br><span class="line">    // 這裏更新中間變量，然後繼續上述步驟：遍歷新的只有一條記錄的節點（新的末端節點），直至遍歷完畢。</span><br><span class="line">    memcpy(TopoNum, TopoNumMod, sizeof(TopoNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遞歸打印"><a href="#遞歸打印" class="headerlink" title="遞歸打印"></a>遞歸打印</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void TopoPrint(unsigned int root, unsigned int *node, int node_num) // *node : 節點關係（所有節點的父節點信息）</span><br><span class="line">&#123;</span><br><span class="line">    static int depth = 1;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; node_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node[i] == root)</span><br><span class="line">        &#123;</span><br><span class="line">            fp = fopen(TOPO_FILE_PATH, &quot;a+&quot;);</span><br><span class="line"></span><br><span class="line">            // 根節點禁止遞歸</span><br><span class="line">            if (i == root)</span><br><span class="line">            &#123;</span><br><span class="line">                fclose(fp);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            printf(&quot;|---&quot;);</span><br><span class="line"></span><br><span class="line">            for (int d = 0; d &lt; depth; ++d)</span><br><span class="line">            &#123;</span><br><span class="line">                #if (ENABLE_PRINT)</span><br><span class="line">                printf(&quot;|---&quot;);</span><br><span class="line">                #endif</span><br><span class="line">                #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">                fprintf(fp, &quot;|---&quot;);</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 打印序號</span><br><span class="line">            #if (ENABLE_PRINT)</span><br><span class="line">            printf(&quot;%-8d&quot;, i);</span><br><span class="line">            printf(TOPO_ALIGN_STR);</span><br><span class="line">            #endif</span><br><span class="line">            #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">            fprintf(fp, &quot;%-8d&quot;, i);</span><br><span class="line">            fprintf(fp, TOPO_ALIGN_STR);</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            // 打印地址</span><br><span class="line">            for (int len = 0; len &lt; 6; ++len)</span><br><span class="line">            &#123;</span><br><span class="line">                #if (ENABLE_PRINT)</span><br><span class="line">                printf(&quot;%02X&quot;, TopoDev[i][len]);</span><br><span class="line">                #endif</span><br><span class="line">                #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">                fprintf(fp, &quot;%02X&quot;, TopoDev[i][len]);</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 打印換行</span><br><span class="line">            #if (ENABLE_PRINT)</span><br><span class="line">            printf(&quot;\r\n&quot;);</span><br><span class="line">            #endif</span><br><span class="line">            #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">            fprintf(fp, &quot;\n&quot;);</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            fclose(fp);</span><br><span class="line"></span><br><span class="line">            // 遞歸調用</span><br><span class="line">            depth++;</span><br><span class="line">            TopoPrint(i, node, node_num);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>拓撲識別</tag>
        <tag>拓撲分析</tag>
      </tags>
  </entry>
  <entry>
    <title>crc-libc</title>
    <url>/sulfurandcu.io/clnyhr2mq002z10rqddw83ul7.html</url>
    <content><![CDATA[<center><a href="https://github.com/sulfurandcu/crc-lib">https://github.com/sulfurandcu/crc-lib</a></center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0xbb3d residue=0x0000</span><br><span class="line"> * class: attested</span><br><span class="line"> * alias: CRC-16, CRC-16/ARC, CRC-16/IBM, CRC-16/LHA</span><br><span class="line"> */</span><br><span class="line">CRC_16_8005_0000_1_1_0000, // check=0xbb3d</span><br><span class="line">CRC_16_ARC,</span><br><span class="line">CRC_16_IBM,</span><br><span class="line">CRC_16_LHA,</span><br><span class="line">/**</span><br><span class="line"> * brief: width=16 poly=0x8005 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xfee8 residue=0x0000</span><br><span class="line"> * class: attested</span><br><span class="line"> * alias: CRC-16/UMTS, CRC-16/BUYPASS, CRC-16/VERIFONE</span><br><span class="line"> */</span><br><span class="line">CRC_16_8005_0000_0_0_0000, // check=0xfee8</span><br><span class="line">CRC_16_UMTS,</span><br><span class="line">CRC_16_BUYPASS,</span><br><span class="line">CRC_16_VERIFONE,</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>目前支持的 crc 種類有：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum crc_16_type_t</span><br><span class="line">&#123;</span><br><span class="line">    #if crc_16_poly_8005_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0xbb3d residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16, CRC-16/ARC, CRC-16/IBM, CRC-16/LHA</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_1_1_0000, // check=0xbb3d</span><br><span class="line">    CRC_16_ARC,</span><br><span class="line">    CRC_16_IBM,</span><br><span class="line">    CRC_16_LHA,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xfee8 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/UMTS, CRC-16/BUYPASS, CRC-16/VERIFONE</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_0_0_0000, // check=0xfee8</span><br><span class="line">    CRC_16_UMTS,</span><br><span class="line">    CRC_16_BUYPASS,</span><br><span class="line">    CRC_16_VERIFONE,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0xFFFF check=0x44c2 residue=0xb001</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MAXIM, CRC-16/MAXIM-DOW</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_1_1_FFFF, // check=0x44c2</span><br><span class="line">    CRC_16_MAXIM,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=1 refout=1 xorout=0x0000 check=0x4b37 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MODBUS</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_1_1_0000, // check=0x4b37</span><br><span class="line">    CRC_16_MODBUS,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x800D refin=0 refout=0 xorout=0x0000 check=0x9ecf residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DDS-110</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_800D_0_0_0000, // check=0x9ecf</span><br><span class="line">    CRC_16_DDS110,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=1 refout=1 xorout=0xFFFF check=0xb4c8 residue=0xb001</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/USB</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_1_1_FFFF, // check=0xb4c8</span><br><span class="line">    CRC_16_USB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0xaee7 residue=0x0000</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/CMS</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_0_0_0000, // check=0xaee7</span><br><span class="line">    CRC_16_CMS,</span><br><span class="line">    #endif</span><br><span class="line">    #if crc_16_poly_1021_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=0 refout=0 xorout=0xFFFF check=0xd64e residue=0x1d0f</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/GENIBUS, CRC-16/DARC, CRC-16/EPC, CRC-16/EPC-C1G2, CRC-16/I-CODE</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_0_0_FFFF, // check=0xd64e</span><br><span class="line">    CRC_16_GENIBUS,</span><br><span class="line">    CRC_16_DARC,</span><br><span class="line">    CRC_16_EPC,</span><br><span class="line">    CRC_16_EPC_C1G2,</span><br><span class="line">    CRC_16_ICODE,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=0 refout=0 xorout=0xFFFF check=0xce3c residue=0x1d0f</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/GSM</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_0_0_FFFF, // check=0xce3c</span><br><span class="line">    CRC_16_GSM,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0x29b1 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/CCITT-FALSE, CRC-16/IBM-3740, CRC-16/AUTOSAR</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_0_0_0000, // check=0x29b1</span><br><span class="line">    CRC_16_CCITT_FALSE,</span><br><span class="line">    CRC_16_IBM_3740,</span><br><span class="line">    CRC_16_AUTOSAR,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=1 refout=1 xorout=0xFFFF check=0x906e residue=0xf0b8</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/X-25, CRC-16/IBM-SDLC, CRC-16/ISO-HDLC, CRC-16/ISO-IEC-14443-3-B, CRC-B</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_1_1_FFFF, // check=0x906e</span><br><span class="line">    CRC_16_X25,</span><br><span class="line">    CRC_16_IBM_SDLC,</span><br><span class="line">    CRC_16_ISO_HDLC,</span><br><span class="line">    CRC_16_ISO_IEC_14443_3_B,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xC6C6 refin=1 refout=1 xorout=0x0000 check=0xbf05 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/ISO-IEC-14443-3-A, CRC-A</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_C6C6_1_1_0000, // check=0xbf05</span><br><span class="line">    CRC_16_ISO_IEC_14443_3_A,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0x2189 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/CCITT, CRC-16/CCITT-TRUE, CRC-16/KERMIT, CRC-16/BLUETOOTH, CRC-16/V-41-LSB</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_1_1_0000, // check=0x2189</span><br><span class="line">    CRC_16_CCITT,</span><br><span class="line">    CRC_16_CCITT_TRUE,</span><br><span class="line">    CRC_16_KERMIT,</span><br><span class="line">    CRC_16_BLUETOOTH,</span><br><span class="line">    CRC_16_V_41_LSB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=1 refout=1 xorout=0x0000 check=0x6f91 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MCRF4XX</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_1_1_0000, // check=0x6f91</span><br><span class="line">    CRC_16_MCRF4XX,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xB2AA refin=1 refout=1 xorout=0x0000 check=0x63d0 residue=0x0000</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/RIELLO</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_B2AA_1_1_0000, // check=0x63d0</span><br><span class="line">    CRC_16_RIELLO,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x1D0F refin=0 refout=0 xorout=0x0000 check=0xe5cc residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/AUG-CCITT, CRC-16/SPI-FUJITSU</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_1D0F_0_0_0000, // check=0xe5cc</span><br><span class="line">    CRC_16_AUG_CCITT,</span><br><span class="line">    CRC_16_SPI_FUJITSU,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x31c3 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/XMODEM, CRC-16/ACORN, CRC-16/LTE, CRC-16/V-41-MSB, XMODEM, YMODEM, ZMODEM</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_0_0_0000, // check=0x31c3</span><br><span class="line">    CRC_16_XMODEM,</span><br><span class="line">    CRC_16_YMODEM,</span><br><span class="line">    CRC_16_ZMODEM,</span><br><span class="line">    CRC_16_ACORN,</span><br><span class="line">    CRC_16_LTE,</span><br><span class="line">    CRC_16_V_41_MSB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x89EC refin=1 refout=1 xorout=0x0000 check=0x26b1 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/TMS37157</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_89EC_1_1_0000, // check=0x26b1</span><br><span class="line">    CRC_16_TMS37157,</span><br><span class="line">    #endif</span><br><span class="line">    #if crc_16_poly_xxxx_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x0589 init=0x0000 refin=0 refout=0 xorout=0x0001 check=0x007e residue=0x0589</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DECT-R, R-CRC-16</span><br><span class="line">     */</span><br><span class="line">    CRC_16_0589_0000_0_0_0001, // check=0x007e</span><br><span class="line">    CRC_16_DECT_R,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x0589 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x007f residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DECT-X, X-CRC-16</span><br><span class="line">     */</span><br><span class="line">    CRC_16_0589_0000_0_0_0000, // check=0x007f</span><br><span class="line">    CRC_16_DECT_X,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8bb7 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xd0db residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/T10-DIF</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8BB7_0000_0_0_0000, // check=0xd0db</span><br><span class="line">    CRC_16_T10_DIF,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x3D65 init=0x0000 refin=1 refout=1 xorout=0xFFFF check=0xea82 residue=0x66c5</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/DNP</span><br><span class="line">     */</span><br><span class="line">    CRC_16_3D65_0000_1_1_FFFF, // check=0xea82</span><br><span class="line">    CRC_16_DNP,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x3d65 init=0x0000 refin=0 refout=0 xorout=0xFFFF check=0xc2b7 residue=0xa366</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/EN-13757</span><br><span class="line">     */</span><br><span class="line">    CRC_16_3D65_0000_0_0_FFFF, // check=0xc2b7</span><br><span class="line">    CRC_16_EN_13757,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0xa097 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x0fb3 residue=0x0000</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/TELEDISK</span><br><span class="line">     */</span><br><span class="line">    CRC_16_A097_0000_0_0_0000, // check=0x0fb3</span><br><span class="line">    CRC_16_TELEDISK,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0xc867 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0x4c06 residue=0x0000</span><br><span class="line">     * class: academic</span><br><span class="line">     * alias: CRC-16/CDMA2000</span><br><span class="line">     */</span><br><span class="line">    CRC_16_C867_FFFF_0_0_0000, // check=0x4c06</span><br><span class="line">    CRC_16_CDMA2000,</span><br><span class="line">    #endif</span><br><span class="line">&#125; crc_16_type_t;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>crc</tag>
        <tag>循環冗餘校驗算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LilyPond</title>
    <url>/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj.html</url>
    <content><![CDATA[<p>LilyPond 是什麼？(<strong><a href="https://lilypond.org/">https://lilypond.org/</a></strong>)</p>
<blockquote>
<p>LilyPond (荷花池) 是一個音樂雕版軟件，致力產生最高質量的樂譜。它把傳統音樂雕版印刷的美學，呈現在計算機打印的樂譜上。LilyPond 是自由軟件，也是 GNU Project 的一部分。</p>
</blockquote>
<p>計算機軟件的內核是將接收到的數據進行計算並輸出，LilyPond 也不例外。我們需要按照 LilyPond 開發者制定的規則編寫樂譜源碼，然後使用 LilyPond 程序將源代碼轉換爲 PNG、PDF、SVG、MIDI 等格式的文件。</p>
<p><strong>荷花池（線譜）的運作流程如下：</strong></p>
<ol>
<li>按照 lilypond 開發者制定的規則編寫「LilyPond 樂譜源碼」。</li>
<li>使用 lilypond 程序將「LilyPond 樂譜源碼」轉換爲我們期望的「樂譜」文件。</li>
</ol>
<div class="note info no-icon"><p>這裏的 lilypond.exe 程序與我們日常使用的軟件有所不同，需要通過命令行的方式來調用執行。</p>
</div>

<p>不過 LilyPond 主要用於生成五線譜，若想生成簡譜我們還需要藉助另外一個工具：</p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly.png"></p>
<p>與上面不同，我們不再按照 LilyPond 的規則編寫「LilyPond 樂譜源碼」而是按照 jianpuly 開發者制定的規則編寫「Jianpuly 簡譜源碼」。</p>
<p><strong>荷花池（簡譜）的運作流程如下：</strong></p>
<ol>
<li>按照 jianpuly 開發者制定的規則編寫「Jianpuly 簡譜源碼」。</li>
<li>使用 jianpuly 腳本將「Jianpuly 簡譜源碼」轉換爲「LilyPond 樂譜源碼」。</li>
<li>使用 lilypond 程序將「LilyPond 樂譜源碼」轉換爲我們期望的「樂譜」文件。</li>
</ol>
<div class="note info no-icon"><p>與 lilypond 類似，jianpu-ly.py 需要通過命令行的方式經 python 調用執行。</p>
</div>

<span id="more"></span>

<h2 id="軟件下載"><a href="#軟件下載" class="headerlink" title="軟件下載"></a>軟件下載</h2><p><strong>1. 下載 lilypond 壓縮包</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-download.png"></p>
<center><a href="https://lilypond.org/download.html">下載鏈接</a></center><br>

<p><strong>2. 下載 jianpu-ly.py 腳本文件</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly-download.png"></p>
<center><a href="http://ssb22.user.srcf.net/mwrhome/jianpu-ly.html">下載鏈接</a></center><br>

<h2 id="軟件安裝"><a href="#軟件安裝" class="headerlink" title="軟件安裝"></a>軟件安裝</h2><p><strong>1. 將下載好的 lilypond 壓縮包解壓至任意位置</strong></p>
<p><strong>2. 將下載好的 jianpu-ly.py 剪切至 lilypond 解壓目錄下的 bin 文件夾中</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-unpack.png"></p>
<p><strong>3. 將 lilypond 安裝目錄下的 bin 文件夾添加至系統環境變量 PATH 中</strong></p>
<p><strong>第一步：搜索「環境變量」然後點擊「編輯系統環境變量」</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath1.png"></p>
<p><strong>第二步：點擊「環境變量」按鈕</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath2.png"></p>
<p><strong>第三步：選中系統變量中的「PATH」然後點擊下方的「編輯」按鈕</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath3.png"></p>
<p><strong>第四步：點擊「新建」按鈕然後輸入之前解壓的 lilypond 的完整路徑</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-systempath4.png"></p>
<p><strong>4. 驗證 lilypond 是否正常安裝</strong></p>
<p><strong>第一步：按下「Win+R」鍵打開運行對話框然後輸入 cmd 並運行</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-install-verify-cmd.png"></p>
<p><strong>第二步：輸入「lilypond –help」然後按下回車鍵</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond-help.png"></p>
<p>如果你能看到上圖中的信息，那麼恭喜，安裝完成！下面可以嘗試製作一個簡單的樂譜了！</p>
<br>

<h2 id="線譜製作"><a href="#線譜製作" class="headerlink" title="線譜製作"></a>線譜製作</h2><p>寫到這裏時發現了一篇非常不錯的 lilypond 中文入門教程，既然如此，那我索性就偷個懶，各位看官請移步這裏：</p>
<center><a href="https://www.yuque.com/qqbunny/lilypond">《LilyPond 入門教程》 by 兔子不咬人</a></center><br>

<h2 id="簡譜製作"><a href="#簡譜製作" class="headerlink" title="簡譜製作"></a>簡譜製作</h2><p><strong>1. 新建一個文件夾作爲工作空間</strong></p>
<p><strong>2. 將 jianpu-ly.py 腳本文件拷貝至工作空間</strong></p>
<p><strong>3. 在工作空間中創建一個文本文檔（例如：簡譜代碼.txt）然後寫入以下內容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% tempo: 4=60</span><br><span class="line">title=標題</span><br><span class="line">1=C</span><br><span class="line">2/4</span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6 7 1&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>4. 在工作空間中單擊右鍵選擇「在終端中打開」然後會彈出一個黑框框</strong></p>
<p><strong>5. 輸入以下命令並然後按回車鍵執行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jianpu-ly.py 簡譜代碼.txt &gt; 樂譜代碼.ly</span><br></pre></td></tr></table></figure>

<p><strong>6. 輸入以下命令並然後按回車鍵執行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lilypond -o 樂譜文件 --format=pdf,png 樂譜代碼.ly</span><br></pre></td></tr></table></figure>

<p><strong>7. 嫌麻煩的話也可以在工作空間中新建一個「自動腳本.bat」批處理文件並填入以下內容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line"></span><br><span class="line">set jianpuly=&quot;D:\develop.r.1\lilypond-2.24.1\bin\jianpu-ly.py&quot;</span><br><span class="line"></span><br><span class="line">set source=&quot;簡譜&quot;</span><br><span class="line">set output=&quot;曲譜&quot;</span><br><span class="line"></span><br><span class="line">set middle=&quot;荷花&quot;</span><br><span class="line"></span><br><span class="line">python %jianpuly% %source%.txt &gt; %middle%.ly</span><br><span class="line">lilypond -o %output% --format=pdf,png %middle%.ly</span><br><span class="line">lilypond -o %output% --format=svg %middle%.ly</span><br><span class="line"></span><br><span class="line">md %source%</span><br><span class="line"></span><br><span class="line">move .\%output%.* .\%source%</span><br><span class="line">move .\%middle%.* .\%source%</span><br></pre></td></tr></table></figure>

<p><strong>8. 以後只要雙擊該腳本即可自動生成</strong></p>
<div class="note info no-icon"><p>使用這種方式時，文件名就不能隨便起了，必須與「source」字段保持一致。</p>
</div>

<h2 id="簡譜規則"><a href="#簡譜規則" class="headerlink" title="簡譜規則"></a>簡譜規則</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scale going up                                              1 2 3 4 5 6 7 1&#x27;</span><br><span class="line">Accidentals                                                 1 #1 2 b2 1</span><br><span class="line">Octaves                                                     1,, 1, 1 1&#x27; 1&#x27;&#x27;</span><br><span class="line">Shortcuts for 1’ and 2’                                     8 9</span><br><span class="line">Semiquaver, quaver, crotchet (16/8/4th notes)               s1 q1 1</span><br><span class="line">Dotted versions of the above (50% longer)                   s1. q1. 1.</span><br><span class="line">Demisemiquaver, hemidemisemiquaver (32/64th notes)          d1 h1</span><br><span class="line">Minims (half notes) use dashes                              1 -</span><br><span class="line">Dotted minim                                                1 - -</span><br><span class="line">Semibreve (whole note)                                      1 - - -</span><br><span class="line">Time signature                                              4/4</span><br><span class="line">Time signature with quaver anacrusis (8th-note pickup)      4/4,8</span><br><span class="line">Key signature (major)                                       1=Bb</span><br><span class="line">Key signature (minor)                                       6=F#</span><br><span class="line">Tempo                                                       4=85</span><br><span class="line">Lyrics                                                      L: here are the syl- la- bles (all on one line)</span><br><span class="line">Lyrics (verse 1)                                            L: 1. Here is verse one</span><br><span class="line">Lyrics (verse 2)                                            L: 2. Here is verse two</span><br><span class="line">Hanzi lyrics (auto space)                                   H: hanzi (with or without spaces)</span><br><span class="line">Lilypond headers                                            title=the title (on a line of its own)</span><br><span class="line">Multiple parts                                              NextPart</span><br><span class="line">Instrument of current part                                  instrument=Flute (on a line of its own)</span><br><span class="line">Multiple movements                                          NextScore</span><br><span class="line">Prohibit page breaks until end of this movement             OnePage</span><br><span class="line">Suppress bar numbers                                        NoBarNums</span><br><span class="line">Old-style time signature                                    SeparateTimesig 1=C 4/4</span><br><span class="line">Indonesian ‘not angka’ style                                angka</span><br><span class="line">Add a Western staff doubling the tune                       WithStaff</span><br><span class="line">Tuplets                                                     3[ q1 q1 q1 ]</span><br><span class="line">Grace notes before                                          g[#45] 1</span><br><span class="line">Grace notes after                                           1 [&#x27;1]g</span><br><span class="line">Simple chords                                               135 1 13 1</span><br><span class="line">Da capo                                                     1 1 Fine 1 1 1 1 1 1 DC</span><br><span class="line">Repeat (with alternate endings)                             R&#123; 1 1 1 &#125; A&#123; 2 | 3 &#125;</span><br><span class="line">Short repeats (percent)                                     R4&#123; 1 2 &#125;</span><br><span class="line">Ties (like Lilypond’s, if you don’t want dashes)            1 ~ 1</span><br><span class="line">Slurs (like Lilypond’s)                                     1 ( 2 )</span><br><span class="line">Erhu fingering (applies to previous note)                   Fr=0 Fr=4</span><br><span class="line">Erhu symbol (applies to previous note)                      souyin harmonic up down bend tilde</span><br><span class="line">Tremolo                                                     1/// - 1///5 -</span><br><span class="line">Rehearsal letters                                           letterA letterB</span><br><span class="line">Multibar rest                                               R*8</span><br><span class="line">Dynamics (applies to previous note)                         \p \mp \f</span><br><span class="line">Other 1-word Lilypond \ commands                            \fermata \&gt; \! \( \) etc</span><br><span class="line">Text                                                        ^&quot;above note&quot; _&quot;below note&quot;</span><br><span class="line">Other Lilypond code                                         LP: (block of code) :LP (each delimeter at start of its line)</span><br><span class="line">Ignored                                                     % a comment</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學點音樂</category>
      </categories>
      <tags>
        <tag>五線譜</tag>
        <tag>簡譜</tag>
        <tag>lilypond</tag>
      </tags>
  </entry>
  <entry>
    <title>沒事兒也來做做題</title>
    <url>/sulfurandcu.io/clnyhr2mo002m10rq48l66wah.html</url>
    <content><![CDATA[<center><a href="http://sdoi.programming-rabbit.com/">http://sdoi.programming-rabbit.com/</a></center>

<span id="more"></span>

<h3 id="第一題"><a href="#第一題" class="headerlink" title="第一題"></a>第一題</h3><h4 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h4><p>張三和李四在玩一種遊戲。</p>
<p>首先，張三從 A 與 B 之間（包括A和B）選擇一個整數，告訴李四。</p>
<p>其次，李四從 C 與 D 之間（包括C和D）選擇一個整數。</p>
<p>兩個整數之和，如果是素數，張三贏，負責李四贏。</p>
<p>當兩個人都是最佳發揮時，誰會贏？</p>
<p><strong>輸入格式：</strong><br>一行四個正整數 A B C D 以空格隔開。</p>
<p><strong>輸入格式：</strong><br>如果張三贏了，輸出 X，否則輸出 Y。</p>
<h4 id="代碼實現"><a href="#代碼實現" class="headerlink" title="代碼實現"></a>代碼實現</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool IsPrimeNumber(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if (n &lt; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int SquareRoot = 1;</span><br><span class="line"></span><br><span class="line">	while (SquareRoot * SquareRoot &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		SquareRoot++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 2; i &lt;= SquareRoot; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (n % i == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int a = 0;</span><br><span class="line">	int b = 0;</span><br><span class="line">	int c = 0;</span><br><span class="line">	int d = 0;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j = 0;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	int x_win = 0;</span><br><span class="line">	int y_win = 0;</span><br><span class="line">	bool PrimeExist = false;</span><br><span class="line"></span><br><span class="line">	int usec_bgn;</span><br><span class="line">	int usec_end;</span><br><span class="line">	int usec_sub;</span><br><span class="line">	struct timeval tv;</span><br><span class="line"></span><br><span class="line">	/* 等待輸入 */</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">	// a = 1; b = 100; c = 2; d = 3;</span><br><span class="line"></span><br><span class="line">	/* 參數判斷 */</span><br><span class="line">	if (a &lt;= 0 || a &gt; 100 || b &lt;= 0 || b &gt; 100 || c &lt;= 0 || c &gt; 100 || d &lt;= 0 || d &gt; 100)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error input! a, b, c, d should be greater than zero and less than or equal to 100! \r\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 參數判斷 */</span><br><span class="line">	if (a &gt; b || c &gt; d)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error input! b is bigger than a!\r\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 參數判斷 */</span><br><span class="line">	if (c &gt; d)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error input! d is bigger than c!\r\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// printf(&quot;%d,%d,%d,%d\r\n&quot;, a, b, c, d);</span><br><span class="line"></span><br><span class="line">	/* 起始時間 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_bgn = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;bgn time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 勝負推演 */</span><br><span class="line">	for (i = a; i &lt;= b; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		PrimeExist = false;</span><br><span class="line"></span><br><span class="line">		for (j = c; j &lt;= d; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = i + j;</span><br><span class="line"></span><br><span class="line">			if (IsPrimeNumber(sum))</span><br><span class="line">			&#123;</span><br><span class="line">				PrimeExist = true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (PrimeExist)</span><br><span class="line">		&#123;</span><br><span class="line">			y_win++;</span><br><span class="line"></span><br><span class="line">			#if 1 /* 如果不想顯示中間過程，可以屏蔽下行（將 #if 1 改爲 #if 0） */</span><br><span class="line">			printf(&quot;X = %d\tY = %d\tSUM  = %d \tY WIN !\r\n&quot;, i, j, sum);</span><br><span class="line">			#endif</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			x_win++;</span><br><span class="line"></span><br><span class="line">			#if 1 /* 如果不想顯示中間過程，可以屏蔽下行（將 #if 1 改爲 #if 0） */</span><br><span class="line">			printf(&quot;X = %d\tY =  \tSUM != Prime \tX WIN !\r\n&quot;, i);</span><br><span class="line">			#endif</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 比較小X和小Y總的勝負次數 */</span><br><span class="line">	if (x_win &gt; y_win)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;X WIN TIMES = %d, Y WIN TIMES = %d, SO X WINS FINALLY !\r\n&quot;, x_win, y_win);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	if (x_win &lt; y_win)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;X WIN TIMES = %d, Y WIN TIMES = %d, SO Y WINS FINALLY !\r\n&quot;, x_win, y_win);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;X WIN TIMES = %d, Y WIN TIMES = %d, DRAWN GAME !\r\n&quot;, x_win, y_win);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 結束時間 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_end = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;end time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 計算耗時 */</span><br><span class="line">	if (usec_end &gt;= usec_bgn)</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = usec_end - usec_bgn;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = 1000000 - (usec_bgn - usec_end);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;time cost :%d us\r\n&quot;, usec_sub);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="測試記錄"><a href="#測試記錄" class="headerlink" title="測試記錄"></a>測試記錄</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">編譯環境 windows subsystem for linux (wsl) &amp; gcc/g++ v9.3.0</span><br><span class="line"></span><br><span class="line">user@localhost:/mnt/e/gcc$ g++ main.cpp -o main.cppout</span><br><span class="line">user@localhost:/mnt/e/gcc$ ./main.cppout</span><br><span class="line">1 100 2 3</span><br><span class="line"></span><br><span class="line">bgn time (second, micro-second): 1656168565s, 669332us</span><br><span class="line"></span><br><span class="line">X = 1   Y = 2   SUM  = 3        Y WIN !</span><br><span class="line">X = 2   Y = 3   SUM  = 5        Y WIN !</span><br><span class="line">X = 3   Y = 2   SUM  = 5        Y WIN !</span><br><span class="line">X = 4   Y = 3   SUM  = 7        Y WIN !</span><br><span class="line">X = 5   Y = 2   SUM  = 7        Y WIN !</span><br><span class="line">X = 6   Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 7   Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 8   Y = 3   SUM  = 11       Y WIN !</span><br><span class="line">X = 9   Y = 2   SUM  = 11       Y WIN !</span><br><span class="line">X = 10  Y = 3   SUM  = 13       Y WIN !</span><br><span class="line">X = 11  Y = 2   SUM  = 13       Y WIN !</span><br><span class="line">X = 12  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 13  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 14  Y = 3   SUM  = 17       Y WIN !</span><br><span class="line">X = 15  Y = 2   SUM  = 17       Y WIN !</span><br><span class="line">X = 16  Y = 3   SUM  = 19       Y WIN !</span><br><span class="line">X = 17  Y = 2   SUM  = 19       Y WIN !</span><br><span class="line">X = 18  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 19  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 20  Y = 3   SUM  = 23       Y WIN !</span><br><span class="line">X = 21  Y = 2   SUM  = 23       Y WIN !</span><br><span class="line">X = 22  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 23  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 24  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 25  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 26  Y = 3   SUM  = 29       Y WIN !</span><br><span class="line">X = 27  Y = 2   SUM  = 29       Y WIN !</span><br><span class="line">X = 28  Y = 3   SUM  = 31       Y WIN !</span><br><span class="line">X = 29  Y = 2   SUM  = 31       Y WIN !</span><br><span class="line">X = 30  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 31  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 32  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 33  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 34  Y = 3   SUM  = 37       Y WIN !</span><br><span class="line">X = 35  Y = 2   SUM  = 37       Y WIN !</span><br><span class="line">X = 36  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 37  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 38  Y = 3   SUM  = 41       Y WIN !</span><br><span class="line">X = 39  Y = 2   SUM  = 41       Y WIN !</span><br><span class="line">X = 40  Y = 3   SUM  = 43       Y WIN !</span><br><span class="line">X = 41  Y = 2   SUM  = 43       Y WIN !</span><br><span class="line">X = 42  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 43  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 44  Y = 3   SUM  = 47       Y WIN !</span><br><span class="line">X = 45  Y = 2   SUM  = 47       Y WIN !</span><br><span class="line">X = 46  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 47  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 48  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 49  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 50  Y = 3   SUM  = 53       Y WIN !</span><br><span class="line">X = 51  Y = 2   SUM  = 53       Y WIN !</span><br><span class="line">X = 52  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 53  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 54  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 55  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 56  Y = 3   SUM  = 59       Y WIN !</span><br><span class="line">X = 57  Y = 2   SUM  = 59       Y WIN !</span><br><span class="line">X = 58  Y = 3   SUM  = 61       Y WIN !</span><br><span class="line">X = 59  Y = 2   SUM  = 61       Y WIN !</span><br><span class="line">X = 60  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 61  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 62  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 63  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 64  Y = 3   SUM  = 67       Y WIN !</span><br><span class="line">X = 65  Y = 2   SUM  = 67       Y WIN !</span><br><span class="line">X = 66  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 67  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 68  Y = 3   SUM  = 71       Y WIN !</span><br><span class="line">X = 69  Y = 2   SUM  = 71       Y WIN !</span><br><span class="line">X = 70  Y = 3   SUM  = 73       Y WIN !</span><br><span class="line">X = 71  Y = 2   SUM  = 73       Y WIN !</span><br><span class="line">X = 72  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 73  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 74  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 75  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 76  Y = 3   SUM  = 79       Y WIN !</span><br><span class="line">X = 77  Y = 2   SUM  = 79       Y WIN !</span><br><span class="line">X = 78  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 79  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 80  Y = 3   SUM  = 83       Y WIN !</span><br><span class="line">X = 81  Y = 2   SUM  = 83       Y WIN !</span><br><span class="line">X = 82  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 83  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 84  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 85  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 86  Y = 3   SUM  = 89       Y WIN !</span><br><span class="line">X = 87  Y = 2   SUM  = 89       Y WIN !</span><br><span class="line">X = 88  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 89  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 90  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 91  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 92  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 93  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 94  Y = 3   SUM  = 97       Y WIN !</span><br><span class="line">X = 95  Y = 2   SUM  = 97       Y WIN !</span><br><span class="line">X = 96  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 97  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 98  Y = 3   SUM  = 101      Y WIN !</span><br><span class="line">X = 99  Y = 2   SUM  = 101      Y WIN !</span><br><span class="line">X = 100 Y = 3   SUM  = 103      Y WIN !</span><br><span class="line"></span><br><span class="line">X WIN TIMES = 50, Y WIN TIMES = 50, DRAWN GAME !</span><br><span class="line"></span><br><span class="line">end time (second, micro-second): 1656168565s, 670078us</span><br><span class="line"></span><br><span class="line">time cost :746 us</span><br><span class="line"></span><br><span class="line">user@localhost:/mnt/e/gcc$</span><br></pre></td></tr></table></figure>

<h3 id="第二題"><a href="#第二題" class="headerlink" title="第二題"></a>第二題</h3><h4 id="題目描述-1"><a href="#題目描述-1" class="headerlink" title="題目描述"></a>題目描述</h4><p>張三成爲了一家餐廳的採購員。作爲一個採購員要有良好的職業素養。必須保證每次採購的物資不超過自己車輛的容量，然後在此條件下使得餐廳賺取的收益最大。</p>
<p>商場中共有 n 種物資，編號爲 1 到 n 。每種物資都有兩個參數 v 和 w，分別表示這種物資的體積和採購這種物資可以給餐廳帶來的收益。注意每種物資每天至多隻能採購一件。</p>
<p>張三有一輛容量爲 V 的採購車，每天張三隻去採購一次，採購的物資體積之和不能超過車輛的容量。</p>
<p>對於每天採購的物資，餐廳老闆還有特殊的要求，第 i 天老闆要求張三不能採購編號大於等於 Li 並且小於等於 Ri 的物資（即不能採購編號在 [Li,Ri] 之間的物資）。特別的，當 Li&gt;Ri 時表示這天沒有不可採購的物資。</p>
<p>對於接下來的 m 天，你需要告訴張三他每天分別最多可以給餐廳賺取多少的收益。</p>
<p><strong>輸入格式：</strong><br>輸入第一行兩個個整數 n, V 表示共有 n 種物資，張三的車子容量是 V。<br>接下來 n 行，每行兩個整數。<br>第 i+1 行輸入vi, wi 表示第 i 種物資的體積和收益。<br>接下來一行輸入一個整數 m ，表示需要採購的天數。<br>接下來 m 行，每行輸入兩個整數 Li, Ri 表示第 i 天不能採購編號位於 Li 到 Ri 之間的物資。</p>
<p><strong>輸出格式：</strong><br>輸出共 m 行，每行一個整數表示張三第 i 天可以給餐廳帶來的收益。</p>
<p><strong>輸入樣例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6   290     物資種類，容量</span><br><span class="line">85  97      1號體積，收益</span><br><span class="line">80  81      2號體積，收益</span><br><span class="line">83  1       3號體積，收益</span><br><span class="line">79  81      4號體積，收益</span><br><span class="line">89  1       5號體積，收益</span><br><span class="line">92  97      6號體積，收益</span><br><span class="line">5           天數</span><br><span class="line">3   5       Li-Ri</span><br><span class="line">1   1</span><br><span class="line">1   3</span><br><span class="line">5   2</span><br><span class="line">3   1</span><br></pre></td></tr></table></figure>

<p><strong>輸出樣例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">275</span><br><span class="line">259</span><br><span class="line">179</span><br><span class="line">275</span><br><span class="line">275</span><br></pre></td></tr></table></figure>

<p><strong>補充說明：</strong><br>前 20% 的數據滿足: 1&lt;&#x3D;n&lt;&#x3D;10,1&lt;&#x3D;m&lt;&#x3D;1000.<br>前 50% 的數據滿足: 1&lt;&#x3D;n, m, V&lt;&#x3D;300.<br>對於 100% 的數據滿足: 1&lt;&#x3D;n, m, V&lt;&#x3D;3000; 1&lt;&#x3D;vi&lt;&#x3D;3000; 1&lt;&#x3D;Li, Ri&lt;&#x3D;n; 1&lt;&#x3D;wi&lt;&#x3D;10^6.</p>
<p><strong>時間限制：</strong>1s</p>
<p><strong>空間限制：</strong>512M</p>
<h4 id="代碼實現-1"><a href="#代碼實現-1" class="headerlink" title="代碼實現"></a>代碼實現</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int daytotal;                       // 天數</span><br><span class="line">	int category;                       // 種類</span><br><span class="line">	int capacity;                       // 容量</span><br><span class="line">	int capacity_left;                  // 容量（剩餘）</span><br><span class="line">	int edge[3001][2];                  // 邊界條件</span><br><span class="line">	int menu[3001][2];                  // 貨單</span><br><span class="line">	int menu_sort[3001][3];             // 貨單（根據每件貨物的收益率排序）</span><br><span class="line">	int idx = 0;</span><br><span class="line">	int sum = 0;                        // 收益</span><br><span class="line">	double rate_max = 0;                // 收益率</span><br><span class="line">	double rate_tmp = 0;                // 收益率</span><br><span class="line"></span><br><span class="line">	int usec_bgn;</span><br><span class="line">	int usec_end;</span><br><span class="line">	int usec_sub;</span><br><span class="line">	struct timeval tv;</span><br><span class="line"></span><br><span class="line">	#if 0</span><br><span class="line">	cin&gt;&gt;category&gt;&gt;capacity;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; category; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;menu[i][0]&gt;&gt;menu[i][1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;daytotal;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; daytotal; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;edge[i][0]&gt;&gt;edge[i][1];</span><br><span class="line">	&#125;</span><br><span class="line">	#else</span><br><span class="line">	category = 10;</span><br><span class="line">	capacity = 300;</span><br><span class="line">	menu[0][0] = 85; menu[0][1] = 97;</span><br><span class="line">	menu[1][0] = 80; menu[1][1] = 81;</span><br><span class="line">	menu[2][0] = 83; menu[2][1] = 1;</span><br><span class="line">	menu[3][0] = 79; menu[3][1] = 81;</span><br><span class="line">	menu[4][0] = 89; menu[4][1] = 1;</span><br><span class="line">	menu[5][0] = 92; menu[5][1] = 97;</span><br><span class="line">	daytotal = 10;</span><br><span class="line">	edge[0][0] = 3; edge[0][1] = 5;</span><br><span class="line">	edge[1][0] = 1; edge[1][1] = 1;</span><br><span class="line">	edge[2][0] = 1; edge[2][1] = 3;</span><br><span class="line">	edge[3][0] = 5; edge[3][1] = 2;</span><br><span class="line">	edge[4][0] = 3; edge[4][1] = 1;</span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">	/* 起始時間 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_bgn = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;bgn time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	for (int j = 0; j &lt; category; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		idx = 0;</span><br><span class="line">		rate_max = 0;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; category; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			if (menu[i][0] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rate_tmp = (double)menu[i][1] / (double)menu[i][0];</span><br><span class="line"></span><br><span class="line">			if (rate_tmp &gt; rate_max)</span><br><span class="line">			&#123;</span><br><span class="line">				rate_max = rate_tmp;</span><br><span class="line">				idx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		menu_sort[j][0] = menu[idx][0];</span><br><span class="line">		menu_sort[j][1] = menu[idx][1];</span><br><span class="line">		menu_sort[j][2] = idx;</span><br><span class="line">		menu[idx][0] = 0;</span><br><span class="line">		menu[idx][1] = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int day_idx = 0; day_idx &lt; daytotal; ++day_idx) /* 第n天 */</span><br><span class="line">	&#123;</span><br><span class="line">		sum = 0;</span><br><span class="line">		capacity_left = capacity;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; category; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			if ((menu_sort[i][2]+1) &gt;= edge[day_idx][0] &amp;&amp; (menu_sort[i][2]+1) &lt;= edge[day_idx][1])</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (capacity_left &gt;= menu_sort[i][0])</span><br><span class="line">			&#123;</span><br><span class="line">				capacity_left -= menu_sort[i][0];</span><br><span class="line">				sum += menu_sort[i][1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\r\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 結束時間 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_end = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;end time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 計算耗時 */</span><br><span class="line">	if (usec_end &gt;= usec_bgn)</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = usec_end - usec_bgn;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = 1000000 - (usec_bgn - usec_end);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;time cost :%d us\r\n&quot;, usec_sub);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="測試記錄-1"><a href="#測試記錄-1" class="headerlink" title="測試記錄"></a>測試記錄</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@localhost:/mnt/e/gcc$ g++ main.cpp -o main.cppout</span><br><span class="line">user@localhost:/mnt/e/gcc$ ./main.cppout</span><br><span class="line"></span><br><span class="line">bgn time (second, micro-second): 1656593986s, 560594us</span><br><span class="line"></span><br><span class="line">275</span><br><span class="line">259</span><br><span class="line">179</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line"></span><br><span class="line">end time (second, micro-second): 1656593986s, 560641us</span><br><span class="line"></span><br><span class="line">time cost :47 us</span><br><span class="line"></span><br><span class="line">user@localhost:/mnt/e/gcc$</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>編寫一個根據 svn 提交記錄自動生成日報的腳本</title>
    <url>/sulfurandcu.io/clnyhr2mp002w10rq4yxkans0.html</url>
    <content><![CDATA[<center>beep...領導要求每天寫日報，但是我不太想寫，於是就有了本段代碼。</center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一鍵生成日報 V2.0.0</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import datetime</span><br><span class="line">from datetime import timedelta</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一鍵生成日報 V2.0.0</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import datetime</span><br><span class="line">from datetime import timedelta</span><br><span class="line"></span><br><span class="line"># 是否完成</span><br><span class="line">funccode = 0</span><br><span class="line"></span><br><span class="line"># 任務名稱</span><br><span class="line">taskname = &quot;編碼工作&quot;</span><br><span class="line"># 基準日期</span><br><span class="line">basedate = datetime.datetime.now() - timedelta(days=0)</span><br><span class="line"># 過去幾天</span><br><span class="line">lastnday = 1</span><br><span class="line"># 查詢深度</span><br><span class="line">userdeep = &quot;100&quot;</span><br><span class="line"># 用戶名稱</span><br><span class="line">username = &quot;liujitong&quot;</span><br><span class="line"># 用戶路徑</span><br><span class="line">userpath = &quot;http://svn.sulfurandcu.com&quot;</span><br><span class="line"></span><br><span class="line">TEXT = &quot;&quot;</span><br><span class="line">for i in range(0, lastnday):</span><br><span class="line">    svn_find = &quot;--search-and &quot; + username + &quot; --search-and &quot; + (basedate - timedelta(days=i)).strftime(&quot;%Y-%m-%d&quot;)</span><br><span class="line">    svn_deep = &quot;--limit &quot; + userdeep</span><br><span class="line">    cmd = &quot;svn log &quot; + svn_deep + &quot; &quot; + svn_find + &quot; &quot; + userpath + &quot; --non-interactive&quot;</span><br><span class="line">    with os.popen(cmd) as f:</span><br><span class="line">        text = f.read()</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\n------------------------------------------------------------------------&quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;r.* \| &quot; + username + &quot; \| &quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\) \| .*line\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;)&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\) \| .*lines\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;)&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;\n　　　　　&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;------------------------------------------------------------------------\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        text = text + &quot;EOF&quot;</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;　　　　　EOF&quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\n　　　　　\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;\n&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot; \+0800.*\)\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;\n&quot;, text)</span><br><span class="line"></span><br><span class="line">        if funccode == 1:</span><br><span class="line">            text = &quot;任務名稱：&quot; + taskname + &quot;\n工作內容：\n&quot; + text</span><br><span class="line">            text = text + &quot;是否完成：是&quot;</span><br><span class="line"></span><br><span class="line">        if funccode == 0:</span><br><span class="line">            if (basedate.weekday() == 0):</span><br><span class="line">                deadline = basedate + timedelta(days=4)</span><br><span class="line">            if (basedate.weekday() == 1):</span><br><span class="line">                deadline = basedate + timedelta(days=3)</span><br><span class="line">            if (basedate.weekday() == 2):</span><br><span class="line">                deadline = basedate + timedelta(days=2)</span><br><span class="line">            if (basedate.weekday() == 3):</span><br><span class="line">                deadline = basedate + timedelta(days=1)</span><br><span class="line">            if (basedate.weekday() == 4):</span><br><span class="line">                deadline = basedate + timedelta(days=7)</span><br><span class="line">            if (basedate.weekday() == 5):</span><br><span class="line">                deadline = basedate + timedelta(days=6)</span><br><span class="line">            if (basedate.weekday() == 6):</span><br><span class="line">                deadline = basedate + timedelta(days=5)</span><br><span class="line"></span><br><span class="line">            deadline = deadline.strftime(&quot;%Y年%m月%d日&quot;)</span><br><span class="line"></span><br><span class="line">            text = &quot;任務名稱：&quot; + taskname + &quot;\n工作內容：\n&quot; + text</span><br><span class="line">            text = text + &quot;是否完成：否（計劃&quot; + deadline + &quot;完成）&quot;</span><br><span class="line"></span><br><span class="line">        TEXT = TEXT + text</span><br><span class="line"></span><br><span class="line">        if i &lt; lastnday-1:</span><br><span class="line">            TEXT = TEXT + &quot;\n\n&quot;</span><br><span class="line"></span><br><span class="line">filename = &quot;ooooooDailyGenerator.py.&quot; + username + &quot;.txt&quot;</span><br><span class="line">with open(filename, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(TEXT)</span><br><span class="line"></span><br><span class="line"># input()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>我的生產力工具</title>
    <url>/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html</url>
    <content><![CDATA[<center>一些提高工作效率的工具</center>

<span id="more"></span>

<h2 id="機械鍵盤"><a href="#機械鍵盤" class="headerlink" title="機械鍵盤"></a>機械鍵盤</h2><ul>
<li>使用 tmk, qmk 等工具燒錄自定義固件</li>
</ul>
<h2 id="鍵位佈局"><a href="#鍵位佈局" class="headerlink" title="鍵位佈局"></a>鍵位佈局</h2><ul>
<li><a href="/sulfurandcu.io/clnor6mvz0015ocrq2jks39ew.html">dƷvorak</a></li>
</ul>
<h2 id="輸入法兒"><a href="#輸入法兒" class="headerlink" title="輸入法兒"></a>輸入法兒</h2><ul>
<li>昨夏雙拼</li>
<li>小鶴雙拼</li>
<li>朙月拼音</li>
<li>宮保拼音</li>
</ul>
<h2 id="輸入引擎"><a href="#輸入引擎" class="headerlink" title="輸入引擎"></a>輸入引擎</h2><ul>
<li>中州韻輸入法引擎（rime, weasel, squirrel）</li>
</ul>
<h2 id="顯示字體"><a href="#顯示字體" class="headerlink" title="顯示字體"></a>顯示字體</h2><ul>
<li>思源宋體</li>
<li>思源黑體</li>
<li>更紗黑體</li>
<li>等寬字體（iosevka）</li>
<li>可變字體（Amstelvar）</li>
</ul>
<h2 id="日程計劃"><a href="#日程計劃" class="headerlink" title="日程計劃"></a>日程計劃</h2><ul>
<li>microsoft.todo</li>
</ul>
<h2 id="系統優化"><a href="#系統優化" class="headerlink" title="系統優化"></a>系統優化</h2><ul>
<li>powertoys</li>
<li>ContextMenuManager</li>
<li>RightMenuMgr</li>
<li>WinXEditor</li>
<li>StartAllBack</li>
<li>W11ClassicMenu</li>
<li>Fliqlo</li>
<li>zadig</li>
<li>UsbDriverTool</li>
<li>SmartSystemMenu</li>
</ul>
<h2 id="科學上網"><a href="#科學上網" class="headerlink" title="科學上網"></a>科學上網</h2><ul>
<li>clash.for.windows (<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a>)</li>
<li>xtls.space (<a href="https://xtlspace.20181024.xyz/#/register?code=bUox1yaB">https://xtlspace.20181024.xyz/#/register?code=bUox1yaB</a>)</li>
<li>tor.browser (<a href="https://www.torproject.org/download/">https://www.torproject.org/download/</a>)</li>
<li>tor.zlibrary (<a href="http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/">http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/</a>)</li>
</ul>
<h2 id="文件下載"><a href="#文件下載" class="headerlink" title="文件下載"></a>文件下載</h2><ul>
<li>Aria2</li>
<li>ndm</li>
<li>qbittorrent</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul>
<li>localsend</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul>
<li>qdir</li>
<li>everything</li>
</ul>
<h2 id="虛擬環境"><a href="#虛擬環境" class="headerlink" title="虛擬環境"></a>虛擬環境</h2><ul>
<li>windows.terminal</li>
<li>wsl</li>
<li>vmware</li>
<li>docker</li>
<li>cygwin (posix.api&#x2F;cygwin1.dll, bin&#x3D;windows.pe)</li>
</ul>
<h2 id="遠程終端"><a href="#遠程終端" class="headerlink" title="遠程終端"></a>遠程終端</h2><ul>
<li>windterm</li>
</ul>
<h2 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h2><ul>
<li>mingw&#x2F;msys1 (shell) (posix.api&#x2F;msys-1.0.dll) (msys1~cmd.exe, mingw&#x2F;msys1~cygwin)</li>
<li>mingw&#x2F;msys2 (shell) (posix.api&#x2F;msys-2.0.dll) (msys2~cmd.exe, mingw&#x2F;msys2~cygwin)</li>
<li>cmake.for.windows</li>
<li>ninja.for.windows</li>
<li>mingw.for.windows   (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li>
<li>mingw32 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li>
<li>mingw64 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li>
<li>unxutils</li>
<li>llvm</li>
<li>python.sdk</li>
<li>java.sdk</li>
<li>go.sdk</li>
<li>node.js</li>
</ul>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><ul>
<li>svn</li>
<li>git</li>
</ul>
<h2 id="文件對比"><a href="#文件對比" class="headerlink" title="文件對比"></a>文件對比</h2><ul>
<li>winmerge</li>
</ul>
<h2 id="文本編輯"><a href="#文本編輯" class="headerlink" title="文本編輯"></a>文本編輯</h2><ul>
<li>wxMEdit</li>
</ul>
<h2 id="軟件開發"><a href="#軟件開發" class="headerlink" title="軟件開發"></a>軟件開發</h2><ul>
<li>vscode</li>
<li>vs</li>
<li>eclipse</li>
<li>android.studio</li>
<li>x64dbg</li>
</ul>
<h2 id="軟件開發（嵌入式）"><a href="#軟件開發（嵌入式）" class="headerlink" title="軟件開發（嵌入式）"></a>軟件開發（嵌入式）</h2><ul>
<li>gcc-arm-none-eabi</li>
<li>openocd</li>
<li>jlink</li>
<li>jlink debugger</li>
<li>keil</li>
<li>embeetle</li>
<li>rt-thread.studio</li>
</ul>
<h2 id="硬件開發"><a href="#硬件開發" class="headerlink" title="硬件開發"></a>硬件開發</h2><ul>
<li>KiCAD</li>
<li>AD</li>
<li>CadenceSPB</li>
</ul>
<h2 id="機械工業"><a href="#機械工業" class="headerlink" title="機械工業"></a>機械工業</h2><ul>
<li>AutoCAD</li>
<li>FreeCAD</li>
<li>Revit</li>
<li>Rhino</li>
<li>3dsMax</li>
<li>SketchUp</li>
<li>Render.Vray</li>
<li>Render.D5</li>
<li>Render.Enscape</li>
</ul>
<h2 id="圖片文檔"><a href="#圖片文檔" class="headerlink" title="圖片文檔"></a>圖片文檔</h2><ul>
<li>截屏工具<ul>
<li>fscapture</li>
<li>sharex</li>
</ul>
</li>
<li>圖片查看<ul>
<li>honeyview</li>
</ul>
</li>
<li>圖片編輯<ul>
<li>GIMP</li>
<li>inkscape</li>
<li>shift.n</li>
<li>ascii.generator</li>
</ul>
</li>
<li>文檔查看<ul>
<li>PDF.24</li>
</ul>
</li>
<li>文檔編輯<ul>
<li>PDF.XChange.Editor</li>
<li>draw.io</li>
<li>wave.drom.editor</li>
</ul>
</li>
</ul>
<h2 id="視頻音頻"><a href="#視頻音頻" class="headerlink" title="視頻音頻"></a>視頻音頻</h2><ul>
<li>錄屏工具<ul>
<li>obs.studio</li>
<li>lonelyscreen (ios screen display)</li>
</ul>
</li>
<li>視頻播放<ul>
<li>MPC-HC</li>
<li>VLC</li>
<li>PotPlayer</li>
</ul>
</li>
<li>視頻剪輯<ul>
<li>shotcut</li>
<li>losslesscut</li>
</ul>
</li>
<li>視頻轉碼<ul>
<li>handbrake</li>
</ul>
</li>
<li>音頻播放<ul>
<li>foobar2000</li>
</ul>
</li>
<li>音頻剪輯<ul>
<li>audacity</li>
<li>wavosaur</li>
</ul>
</li>
<li>音頻轉碼<ul>
<li>略.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>生產工具</tag>
      </tags>
  </entry>
  <entry>
    <title>囗－囗</title>
    <url>/sulfurandcu.io/clnyhr2mt003b10rq5snfeg6t.html</url>
    <content><![CDATA[<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center><br></center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>

<br>

<span id="more"></span>

<br>
]]></content>
  </entry>
  <entry>
    <title>極樂迪斯科歐序篇</title>
    <url>/sulfurandcu.io/clnyhr2ml002c10rq648736uf.html</url>
    <content><![CDATA[<p>- There’s this giant ball there. And evil apes. And the evil apes are dukin’ it out on the ball. You’re one of them. It’s basically all just evil apes dukin’ it out on a giant ball.</p>
<p>- How big is the ball?<br>- You can’t even make out it’s a ball, when you’re dukin’it out. It’s that large.</p>
<p>- How small are the apes?<br>- Infinitesimally small.</p>
<p>- And this “dukin’ it out” I keep hearing about - what’s that?<br>- Vying for resources? It’s just a stupid expression you picked up somewhere. The part of the presentation you want to take home with you is this: you have to beat the other evil apes in the face or you lose.</p>
<p>- That sounds like something I would like to do.</p>
]]></content>
      <categories>
        <category>遊戲筆記</category>
      </categories>
      <tags>
        <tag>極樂迪斯科</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－合集</title>
    <url>/sulfurandcu.io/clo3okqut006mi0rq9ecvb34e.html</url>
    <content><![CDATA[<hr>
<p>各個平臺下的開發環境搭建教程</p>
<ul>
<li><a href="/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html">ARM.GCC</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.MDK (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.SES (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.ADS (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">RV5.GCC (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">RV5.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">RV5.SES (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">C51.MDK (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">C51.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">MSP.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">AVR.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">PIC.XXX (TODO)</a></li>
</ul>
<hr>
<span id="more"></span>

<h2 id="搭建方案"><a href="#搭建方案" class="headerlink" title="搭建方案"></a>搭建方案</h2><ul>
<li><strong>VSC</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li>
<li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li>
<li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li>
<li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li>
<li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li>
</ul>
</li>
<li><strong>VS</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li>
<li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li>
</ul>
</li>
<li><strong>Eclipse</strong></li>
<li><strong>Eclipse Based</strong><ul>
<li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a></li>
<li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a></li>
<li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a></li>
</ul>
</li>
</ul>
<h2 id="通用方案"><a href="#通用方案" class="headerlink" title="通用方案"></a>通用方案</h2><ul>
<li><a href="https://www.keil.arm.com/">KeilStudioCloud</a></li>
<li><a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Development%20Studio">ADS</a><ul>
<li>ARM</li>
</ul>
</li>
<li><a href="https://www.keil.com/">MDK</a><ul>
<li>ARM <a href="https://www.keil.com/pr/article/1302.htm">(ARM 6 Will start shipping towards The End of 2023)</a></li>
<li>C51</li>
</ul>
</li>
<li><a href="https://www.iar.com/products/architectures/">IAR</a><ul>
<li>RV5</li>
<li>ARM</li>
<li>AVR</li>
<li>MSP</li>
<li>STM</li>
<li>C51</li>
</ul>
</li>
<li><a href="https://www.segger.com/products/development-tools/embedded-studio/">SES</a><ul>
<li>ARM</li>
<li>RV5</li>
</ul>
</li>
<li><a href="https://embeetle.com/#">EmbeetleIDE</a></li>
</ul>
<h2 id="專用方案"><a href="#專用方案" class="headerlink" title="專用方案"></a>專用方案</h2><ul>
<li><strong>Eclipse Based</strong><ul>
<li><a href="https://www.st.com/en/development-tools/sw4stm32.html">ST: SW4STM32 System Workbench for STM32</a></li>
<li><a href="https://www.st.com/en/development-tools/truestudio.html">ST: TrueStudio by Atollic before 2017</a></li>
<li><a href="">ST: STM32CubeIDE release in 2019 &#x3D; TrueStudio+STM32CubeMX</a></li>
<li><a href="https://www.renesas.com/us/en/software-tool/e-studio">Renesas: E2Studio</a></li>
</ul>
</li>
<li><strong>NetBeans Based</strong><ul>
<li><a href="https://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide">Microchip: MPLAB X IDE</a></li>
</ul>
</li>
</ul>
<h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://elmagnifico.tech/2022/03/14/Embeded-IDE/">https://elmagnifico.tech/2022/03/14/Embeded-IDE/</a><br><a href="https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/">https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/</a></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－DBG</title>
    <url>/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p>
<span id="more"></span>

<h2 id="專用的調試模塊"><a href="#專用的調試模塊" class="headerlink" title="專用的調試模塊"></a>專用的調試模塊</h2><p>常見的 IDE 內部都集成了一個專用的 GUI 調試器，且不能拎出來單獨使用。</p>
<ul>
<li>ADS</li>
<li>IAR</li>
<li>MDK</li>
<li>Visual Studio</li>
</ul>
<h2 id="獨立的調試工具"><a href="#獨立的調試工具" class="headerlink" title="獨立的調試工具"></a>獨立的調試工具</h2><p>當然也有一些可以獨立使用的調試器，例如：</p>
<ul>
<li>CLI: GDB, LLDB</li>
<li>GUI: x64dbg, WinDBG, OllyDBG</li>
</ul>
<h2 id="通用的調試協議（DebugAdapterProtocol）"><a href="#通用的調試協議（DebugAdapterProtocol）" class="headerlink" title="通用的調試協議（DebugAdapterProtocol）"></a>通用的調試協議（DebugAdapterProtocol）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapterProtocol.png"></p>
<p>不論是專用的調試模塊還是獨立的調試工具，如果想支持調試多種語言，就必須要爲每一種語言開發一套對應的調試程序，並且每個工具廠商都要獨自去完成這些工作。爲了減少不必要的重複勞動，微軟制定了一套通用的調試協議，藉助該協議各工具廠商只需要開發一套調試程序，向下再借助各種調試適配工具即可具備調試所有語言的能力。</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p>
<center><a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Adapter Protocol (DAP)</a></center><br>

<p>目前實現該調試協議的開發工具有（常用的）：</p>
<ul>
<li>VSC</li>
<li>VS</li>
<li>vim</li>
<li>emacs</li>
<li>EclipseIDE</li>
</ul>
<p>btw, 微軟還制定了一套通用的語言服務器協議 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/LanguageServerProtocol(LSP).png"></p>
<center><a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></center>

<h2 id="調試器適配工具（DebugAdapter）"><a href="#調試器適配工具（DebugAdapter）" class="headerlink" title="調試器適配工具（DebugAdapter）"></a>調試器適配工具（DebugAdapter）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapter.png"></p>
<p>調試適配器是對各類調試器的封裝，遵循 DAP 協議對上提供統一的接口，以簡化上層開發工具。常用的調試適配器有：</p>
<ul>
<li><a href="https://github.com/Microsoft/vscode-cpptools">cpptools (C&#x2F;C++ Debug Adapter)</a></li>
<li><a href="https://github.com/Marus/cortex-debug">cortex-debug (Embedded C&#x2F;C++ Debug Adapter)</a></li>
</ul>
<h2 id="調試器軟件本體（Debugger）"><a href="#調試器軟件本體（Debugger）" class="headerlink" title="調試器軟件本體（Debugger）"></a>調試器軟件本體（Debugger）</h2><ul>
<li><a href="https://sourceware.org/gdb/">GDB: The GNU Project Debugger</a><ul>
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">↑ GDB&#x2F;MI</a></li>
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html">↓ GDB Remote Serial Protocol</a></li>
</ul>
</li>
<li><a href="https://developer.arm.com/downloads/-/gnu-rm">arm-none-eabi-gdb: GNU Arm Embedded GDB</a></li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Debugger.png"></p>
<h2 id="調試器服務程序（DebugServer）"><a href="#調試器服務程序（DebugServer）" class="headerlink" title="調試器服務程序（DebugServer）"></a>調試器服務程序（DebugServer）</h2><ul>
<li>OpenOCD</li>
<li>PyOCD</li>
<li>JLinkGDBServer</li>
<li>……</li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugServer.png"></p>
<h2 id="仿真器驅動程序（DongleDriver）"><a href="#仿真器驅動程序（DongleDriver）" class="headerlink" title="仿真器驅動程序（DongleDriver）"></a>仿真器驅動程序（DongleDriver）</h2><ul>
<li>SEGGER JLink USB Driver</li>
<li>SEGGER WinUSB USB Device Driver</li>
</ul>
<h2 id="仿真器設備本體（Dongle）"><a href="#仿真器設備本體（Dongle）" class="headerlink" title="仿真器設備本體（Dongle）"></a>仿真器設備本體（Dongle）</h2><ul>
<li>CMSIS-DAP</li>
<li>SEGGER JLink</li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Dongle.png"></p>
<h2 id="仿真器傳輸協議（DongleTransportProtocol）"><a href="#仿真器傳輸協議（DongleTransportProtocol）" class="headerlink" title="仿真器傳輸協議（DongleTransportProtocol）"></a>仿真器傳輸協議（DongleTransportProtocol）</h2><ul>
<li>JTAG <a href="https://www.corelis.com/education/tutorials/jtag-tutorial/">https://www.corelis.com/education/tutorials/jtag-tutorial/</a></li>
<li>SWD</li>
</ul>
<h2 id="目標板目標芯片（TargetBoard）"><a href="#目標板目標芯片（TargetBoard）" class="headerlink" title="目標板目標芯片（TargetBoard）"></a>目標板目標芯片（TargetBoard）</h2><ul>
<li>STM32F103CB</li>
<li>STM32F407VE</li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Target.png"></p>
<h2 id="本地與遠程調試"><a href="#本地與遠程調試" class="headerlink" title="本地與遠程調試"></a>本地與遠程調試</h2><p>遠程調試方案也有很多，這裏只對以下幾種方式作一簡要介紹：</p>
<ul>
<li>OpenOCD</li>
<li>VSCode + JLinkGDBServer</li>
<li>JLink + JLinkRemoteServer</li>
<li>KeilMDK + JLinkRemoteServer</li>
</ul>
<h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>略.</p>
<h3 id="VSCode-JLinkGDBServer"><a href="#VSCode-JLinkGDBServer" class="headerlink" title="VSCode + JLinkGDBServer"></a>VSCode + JLinkGDBServer</h3><p>1. 在服務主機上配置開啓 JLink 調試服務器（該服務器會監聽 2331 端口）</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.0.png"></p>
<div class="note danger no-icon"><p>不要勾選 Localhost Only 選項！</p>
</div>

<p>2. 等待連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.1.png"></p>
<p>3. 在本地主機上配置 launch.json 文件並啓動調試</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">    &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">    &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">    &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">    &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Marus/cortex-debug/issues/244">cortex-debug-issues#244 : remote debugging</a><br><a href="https://github.com/Marus/cortex-debug/wiki/External-gdb-server-configuration">cortex-debug-wiki : external gdb server configuration</a></p>
<div class="note info no-icon"><p>點擊啓動調試後 cortex-debug 便會幫助我們通過本地 xGDB 客戶端連接遠程 GDB 服務器。</p>
</div>

<p>4. 建立連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.2.png"></p>
<p>5. 遠程調試</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此處省略一張在 vscode 中調試的圖片</span><br></pre></td></tr></table></figure>

<p>6. 斷開連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.3.png"></p>
<h3 id="JLink-JLinkRemoteServer"><a href="#JLink-JLinkRemoteServer" class="headerlink" title="JLink + JLinkRemoteServer"></a>JLink + JLinkRemoteServer</h3><h4 id="內網連接"><a href="#內網連接" class="headerlink" title="內網連接"></a>內網連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p>
<p>2. 等待連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p>
<p>3. 在本地主機上配置連接 JLink 遠程服務器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.png"></p>
<p>4. 建立連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p>
<p>5. 遠程調試</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.1.png"></p>
<p>6. 斷開連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p>
<h4 id="隧道連接"><a href="#隧道連接" class="headerlink" title="隧道連接"></a>隧道連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器（隧道方式）</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.0.png"></p>
<p>2. 等待連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.1.png"></p>
<p>3. 在本地主機上配置連接 JLink 遠程服務器（隧道方式）</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.0.png"></p>
<p>4. 建立連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.2.png"></p>
<p>5. 遠程調試</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.1.png"></p>
<p>6. 斷開連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.3.png"></p>
<h3 id="KeilMDK-JLinkRemoteServer"><a href="#KeilMDK-JLinkRemoteServer" class="headerlink" title="KeilMDK + JLinkRemoteServer"></a>KeilMDK + JLinkRemoteServer</h3><h4 id="內網連接-1"><a href="#內網連接-1" class="headerlink" title="內網連接"></a>內網連接</h4><p>1. 在服務主機上配置開啓 JLink 遠程服務器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p>
<p>2. 等待連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p>
<p>3. 在本地主機上配置連接 JLink 遠程服務器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.Keil.MDK.png"></p>
<p>4. 建立連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p>
<p>5. 遠程調試</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此處省略一張在 Keil MDK 中調試的圖片</span><br></pre></td></tr></table></figure>

<p>6. 斷開連接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－GCC.ARM（#00）目錄索引</title>
    <url>/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html</url>
    <content><![CDATA[<hr>
<p><a href="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc.html">集成開發環境－GCC.ARM（#01）環境搭建</a><br><a href="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq.html">集成開發環境－GCC.ARM（#02）代碼編譯</a><br><a href="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html">集成開發環境－GCC.ARM（#03）程序燒錄</a><br><a href="/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html">集成開發環境－GCC.ARM（#04）快捷任務</a><br><a href="/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html">集成開發環境－GCC.ARM（#05）程序調試</a><br><a href="/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html">集成開發環境－DBG</a></p>
<hr>
<p>傳統的集成開發環境（MDK、IAR）通常會提供包括編輯、編譯、燒錄、調試在內的一整套工具，開發者無需配置，簡單易用，但是 license 不是一般的貴。</p>
<p>替代方案：</p>
<ul>
<li><strong>VSC</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li>
<li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li>
<li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li>
<li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li>
<li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li>
</ul>
</li>
<li><strong>VS</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li>
<li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li>
</ul>
</li>
<li><strong>Eclipse</strong></li>
<li><strong>Eclipse Based</strong><ul>
<li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a> (RV5 ARM JLink STLink DAP-Link QEMU)</li>
<li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a> (RV5 ARM)</li>
<li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a> (RV5)</li>
</ul>
</li>
</ul>
<blockquote>
<p>倘若宿主機使用 Windows 操作系統並且購買了 JLinkDebugger 仿真器，則推薦使用 JLink 方案！</p>
</blockquote>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一個基本的開發環境包含以下四個部分：</p>
<ol>
<li>編輯功能（vscode）</li>
<li>編譯功能（arm-none-eabi-xxx）</li>
<li>燒錄功能（OpenOCD&#x2F;JLink）</li>
<li>調試功能（OpenOCD&#x2F;JLinkGDBServerCL + Cortex-Debug + arm-none-eabi-gdb）</li>
</ol>
<ul>
<li><p><strong>vscode</strong><br>文本編輯器，其實是一個僞裝成文本編輯器的開發框架。</p>
</li>
<li><p><strong>arm-none-eabi-xxx</strong><br>交叉編譯器，可以編譯出在 Cortex-R&amp;M 平臺上運行的可執行程序。</p>
</li>
<li><p><strong>OpenOCD&#x2F;JLink</strong><br>程序燒錄器，負責將編譯好的程序燒錄到目標芯片中。</p>
</li>
<li><p><strong>arm-none-eabi-gdb</strong><br>命令調試器，支持通過命令行的方式進行調試。</p>
</li>
<li><p><strong>Cortex-Debug</strong><br>圖形調試器，提供一套圖形調試界面，需要與命令調試器搭配使用。</p>
</li>
<li><p><strong>OpenOCD&#x2F;JLinkGDBServerCL</strong><br>調試服務器，負責協助調試器識別並管理各種仿真設備和目標芯片。</p>
</li>
<li><p><strong>makefile &amp; task.json</strong><br>自動化工具，用來實現編譯和燒錄的自動化。</p>
</li>
</ul>
<h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://blog.csdn.net/weixin_41328027/article/details/122969985">OpenOCD添加第三方設備支持:HT32F52352 Cortex-M0+</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/61519415">用VS Code開發STM32（一）</a><br><a href="https://zhuanlan.zhihu.com/p/61538230">用VS Code開發STM32（二）</a><br><a href="https://zhuanlan.zhihu.com/p/61541590">用VS Code開發STM32（三）</a><br><a href="https://zhuanlan.zhihu.com/p/163771273">用VS Code開發STM32（四）</a></p>
<p><a href="https://blog.csdn.net/weixin_42328389/article/details/128511370">矜辰所致 OpenOCD 不同仿真器使用操作總結記錄</a><br><a href="https://blog.csdn.net/weixin_42328389/article/details/119823834">矜辰所致 在window下使用 VScode 搭建 ARM 開發環境—— 詳細版</a><br><a href="https://blog.csdn.net/pyt1234567890/article/details/122522700">VsCode+OpenOCD 開發stm32系列</a><br><a href="https://blog.csdn.net/qq_49295302/article/details/124628016">vscode-armgcc-openocd搭建STM32開發調試環境</a><br><a href="https://blog.csdn.net/qq_45701067/article/details/121652228">用 vscode 搭建stm32 開發環境（詳細）</a><br><a href="http://eda88.com/essay/firmware/vscode%E6%90%AD%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E8%BD%AC%EF%BC%89/">VSCode搭建STM32開發調試環境（轉）</a><br><a href="https://blog.csdn.net/ben_black/article/details/109906781">VSCode搭建STM32開發環境（極簡自我搭建&amp;懶人直接使用插件）</a><br><a href="https://blog.csdn.net/qq_40833810/article/details/106713462">Cortex-debug 調試器使用介紹</a><br><a href="https://mcuoneclipse.com/2021/05/01/visual-studio-code-for-c-c-with-arm-cortex-m-part-1/">Visual Studio Code for C&#x2F;C++ with ARM Cortex-M: Part 1 </a></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－GCC.ARM（#01）環境搭建</title>
    <url>/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png"></p>
<span id="more"></span>

<hr>
<h2 id="編輯器安裝"><a href="#編輯器安裝" class="headerlink" title="編輯器安裝"></a>編輯器安裝</h2><ul>
<li><strong>VSC</strong></li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png"></p>
<center><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></center>

<ul>
<li><strong>VS</strong></li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VS.png"></p>
<center><a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a></center>

<ul>
<li><strong>Eclipse.Embedded</strong></li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.EclipseEmbedded.png"></p>
<center><a href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a></center>

<h2 id="編輯器插件"><a href="#編輯器插件" class="headerlink" title="編輯器插件"></a>編輯器插件</h2><ul>
<li><strong><a href="https://github.com/Marus/cortex-debug/wiki">vscode :: cortex-debug</a></strong></li>
<li><strong><a href="https://em-ide.com/zh-cn/">vscode :: eide</a></strong></li>
</ul>
<h2 id="編譯器安裝"><a href="#編譯器安裝" class="headerlink" title="編譯器安裝"></a>編譯器安裝</h2><ul>
<li><strong><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain (12.2.Rel1 based on GCC 12.2)</a></strong></li>
<li><strong><a href="https://developer.arm.com/downloads/-/gnu-a">Arm GNU Toolchain for the Cortex-A (10.3-2021.07 based on GCC 10.3)</a></strong></li>
<li><strong><a href="https://developer.arm.com/downloads/-/gnu-rm">Arm GNU Toolchain for the Cortex-R &amp; Cortex-M (10.3-2021.10 based on GCC 10.3)</a></strong></li>
<li><strong><a href="https://xpack.github.io/dev-tools/arm-none-eabi-gcc/releases/">xPack GNU Arm Embedded GCC toolchain</a></strong></li>
</ul>
<div class="note danger no-icon"><p>記得將安裝目錄添加至系統環境變量</p>
</div>

<h2 id="調試器安裝"><a href="#調試器安裝" class="headerlink" title="調試器安裝"></a>調試器安裝</h2><ul>
<li><strong><a href="https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack">SEGGER JLink Installer</a></strong></li>
<li><strong><a href="https://xpack.github.io/dev-tools/openocd/releases/">OpenOCD prebuilt by xPackProject</a></strong></li>
<li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD prebuilt by Sysprogs</a></strong></li>
<li><strong><a href="https://github.com/openocd-org/openocd/releases">OpenOCD prebuilt by OpenOCD.org</a></strong></li>
</ul>
<div class="note danger no-icon"><p>記得將安裝目錄添加至系統環境變量</p>
</div>

<h2 id="構建器安裝"><a href="#構建器安裝" class="headerlink" title="構建器安裝"></a>構建器安裝</h2><ul>
<li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">make</a></strong></li>
<li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">ninja</a></strong></li>
<li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">cmake</a></strong></li>
</ul>
<div class="note info no-icon"><p>理論上安裝完編輯器、編譯器和調試器之後就能夠正常使用了，安裝上述工具是爲了提高開發效率。</p>
</div>

<h2 id="建立新工程"><a href="#建立新工程" class="headerlink" title="建立新工程"></a>建立新工程</h2><ul>
<li>略.</li>
</ul>
<h2 id="拷貝至工程"><a href="#拷貝至工程" class="headerlink" title="拷貝至工程"></a>拷貝至工程</h2><ul>
<li>*.h, *.c<br>代碼文件：在 makefile 中引用進行編譯</li>
<li>*.s<br>啓動文件：在 makefile 中引用進行編譯</li>
<li>*.ld<br>鏈接文件：在 makefile 中引用進行鏈接</li>
<li>*.svd<br>描述文件：在 launch.json 中配置用於調試</li>
</ul>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－GCC.ARM（#02）代碼編譯</title>
    <url>/sulfurandcu.io/clo2c1l6400c71wrq3816hypq.html</url>
    <content><![CDATA[<p>廣義的編譯包括預處理、編譯、彙編、鏈接這四個基本流程，編譯期間需要執行若干指令。</p>
<p>倘若只有 main.h 和 main.c 兩個文件，那麼只需要執行少量的指令即可完成編譯工作。但是實際上一個工程通常包含幾十上百個文件，意味着要執行大量的編譯指令才能得到目標文件，這是我們所無法接受的。因此需要藉助 make、ninja 等構建工具實現編譯自動化。</p>
<span id="more"></span>

<h2 id="生成腳本（makefile）"><a href="#生成腳本（makefile）" class="headerlink" title="生成腳本（makefile）"></a>生成腳本（makefile）</h2><p>相較於頭開始寫 makefile 腳本，先通過 STM32CubeMX 生成然後加以改造則要容易得多。</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.0.png"></p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.1.png"></p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.2.png"></p>
<h2 id="修改腳本（makefile）"><a href="#修改腳本（makefile）" class="headerlink" title="修改腳本（makefile）"></a>修改腳本（makefile）</h2><ol>
<li>修改文件列表（*.c &amp; *.s）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_SOURCES = \</span><br><span class="line">../../../code/Application/src/main.c \</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASM_SOURCES = \</span><br><span class="line">startup_stm32f103xb.s \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>修改包含路徑（*.h）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_INCLUDES = \</span><br><span class="line">-I../../../code/Application \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>修改全局定義（#define）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_DEFS = \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F103xB \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>修改鏈接腳本（.ld）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDSCRIPT = STM32F103C8Tx_FLASH.ld</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="執行編譯"><a href="#執行編譯" class="headerlink" title="執行編譯"></a>執行編譯</h2><p>在 makefile 所在的路徑下執行 make 指令開始編譯</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.build.png"></p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.where.png"></p>
<div class="note danger no-icon"><p>在 windows 系統中請使用 .&#x2F;mingw32-make 命令而非 .&#x2F;make 命令！</p>
</div>

<h2 id="清除編譯"><a href="#清除編譯" class="headerlink" title="清除編譯"></a>清除編譯</h2><p>若要清除剛纔編譯的中間文件，則需要修改 makefile 文件，然後執行 mingw32-make clean 指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">#   -rm -fR $(BUILD_DIR)</span><br><span class="line">    -del /q $(BUILD_DIR)</span><br></pre></td></tr></table></figure>

<p>這時你大概率會遇到以下問題：</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.fail1.png"></p>
<p>有人說將 clean 下的 -rm -fR $(BUILD_DIR) 改成 -del &#x2F;q $(BUILD_DIR) 就好了，實測並不管用。</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.fail2.png"></p>
<p>只有顯式地將 SHELL 指定爲 cmd 纔行（在 makefile 中添加一條語句）：</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.shell.png"></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－GCC.ARM（#03）程序燒錄</title>
    <url>/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html</url>
    <content><![CDATA[<p>編程&#x2F;下載&#x2F;燒錄的方式有多種，本文重點介紹以下兩種燒錄方式：</p>
<ul>
<li>JLink</li>
<li>OpenOCD + JLink 仿真器</li>
</ul>
<p>其中 OpenOCD 可以搭配多種仿真器使用，這裏以 JLink 仿真器爲例進行說明。</p>
<span id="more"></span>

<h2 id="JLink"><a href="#JLink" class="headerlink" title="JLink"></a>JLink</h2><p>1. 確認是否購買了 JLink 仿真器並且已經安裝了 JLink 程序。</p>
<p>2. 在 makefile 中添加 write 選項：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.png"></p>
<p>3. 在工程目錄下新建 JLinkLoad.txt 文件並寫入以下內容：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.code.png"></p>
<p>4. 執行 mingw32-make write 指令：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.succ.png"></p>
<div class="note danger no-icon"><p>再次提醒：需要使用 JLink 仿真器以及<strong>默認驅動</strong></p>
</div>

<div class="note danger no-icon"><p>如果你的電腦中有不止一個 “JLink” 程序，確保在 makefile 中通過絕對路徑使用 JLink 命令。</p>
</div>

<p>下圖是我安裝了 JavaJDK 後系統中存在的 jlink 程序，只不過此 “jlink” 非彼 “JLink”！</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLink.JavaJDK.png"></p>
<h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>1. 確認是否購買了 JLink 仿真器並且已經安裝了 OpenOCD 程序。</p>
<p>2. 在 makefile 中添加 write 選項：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.png"></p>
<p>3. 在工程目錄下新建 openocd.cfg 文件並寫入以下內容：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.code.png"></p>
<blockquote>
<p><a href="https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics">https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics</a></p>
</blockquote>
<p>4. 將 jlink.cfg 和 stm32f1x.cfg 拷貝至工程目錄下。</p>
<p>5. 使用 zadig 或 USBDriverTool 將仿真器的驅動從 WinUSB 改爲 libusb 驅動。</p>
<p>6. 執行 mingw32-make write 指令：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.succ.png"></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="問題一：未找到-JLink-仿真器"><a href="#問題一：未找到-JLink-仿真器" class="headerlink" title="問題一：未找到 JLink 仿真器"></a>問題一：未找到 JLink 仿真器</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.1.png"></p>
<p>OpenOCD 對仿真器的支持是通過底層的訪問控制實現的，不依賴仿真器自身的驅動，但是需要 libusb 驅動，因此我們需要使用 zadig 或 USBDriverTool 等工具將仿真器的默認驅動改爲 libusb 驅動。</p>
<p>需要注意的是，將驅動改成 libusb 之後，原有的調試軟件例如 JLink&#x2F;Keil 將無法再識別到仿真器。</p>
<p>如果你還想繼續使用這些調試軟件，則需要卸載掉當前的驅動程序並插拔一下仿真器：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.2.png"></p>
<h3 id="問題二：SWD-amp-JTAG"><a href="#問題二：SWD-amp-JTAG" class="headerlink" title="問題二：SWD &amp; JTAG"></a>問題二：SWD &amp; JTAG</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.1.png"></p>
<p>OpenOCD 提供的 jlink.cfg 腳本默認使用 JTAG 模式，而我們實際使用的是 SWD 模式。</p>
<p>解決方法：在 openocd.cfg 文件中添加一條語句：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.2.png"></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－GCC.ARM（#04）快捷任務</title>
    <url>/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html</url>
    <content><![CDATA[<hr>
<ul>
<li>tasks.json</li>
</ul>
<hr>
<span id="more"></span>

<p>通過 makefile 我們將海量的指令精簡至一條 make+ 指令，但是我比較懶，一條指令都不想敲。😎</p>
<p>1. 在工程目錄下的 .vscode 目錄中新建 tasks.json 文件並填入以下內容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;編譯（build）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;清除（clean）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make clean&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;燒錄（write）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;燒錄（write.openocd）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write.openocd&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info no-icon"><p>在 cmd 中使用 “|” 連接兩條指令，在 powershell 中使用 “;” 連接兩條指令。</p>
</div>

<p>2. 找到菜單欄依次點擊 Terminal -&gt; RunTask 然後選擇：</p>
<ul>
<li>編譯（build）</li>
<li>清除（clean）</li>
<li>燒錄（write）</li>
<li>燒錄（write.openocd）</li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz/task.json.png"></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成開發環境－GCC.ARM（#05）程序調試</title>
    <url>/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html</url>
    <content><![CDATA[<hr>
<ul>
<li>laugch.json</li>
</ul>
<hr>
<span id="more"></span>

<p>1. 在工程目錄下的 .vscode 目錄中新建 laugch.json 文件並填入以下內容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@JLinkGDBServerCL.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;jlink&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;device&quot;: &quot;STM32F103CB&quot;,</span><br><span class="line">            &quot;interface&quot;: &quot;swd&quot;,</span><br><span class="line">            &quot;serverArgs&quot;: [</span><br><span class="line">                // &quot;-gui&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@OpenOCD.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;openocd&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;showDevDebugOutput&quot;: &quot;none&quot;,</span><br><span class="line">            &quot;configFiles&quot;: [</span><br><span class="line">                &quot;openocd/jlink-swd.cfg&quot;,</span><br><span class="line">                &quot;openocd/stm32f1x.cfg&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin/arm-none-eabi-gdb.exe&quot;,</span><br><span class="line">            &quot;armToolchainPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2. 進入側邊欄中的 RunAndDebug 然後選擇</p>
<ul>
<li>Debug@JLinkGDBServerCL.exe</li>
<li>Debug@OpenOCD.exe</li>
<li>Debug@RemoteServer(GDBServer&#x2F;JLinkGDBServer)</li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey/launch.json.png"></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>集成開發環境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#00）目錄索引</title>
    <url>/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html</url>
    <content><![CDATA[<hr>
<p><a href="/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html">嵌入式 IAP 升級功能（#01）基礎概念</a><br><a href="/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html">嵌入式 IAP 升級功能（#02）升級方案</a><br><a href="/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html">嵌入式 IAP 升級功能（#03）流程設計</a><br><a href="/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html">嵌入式 IAP 升級功能（#04）技術細節</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#05）增量升級</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuztool 移植</a><br><a href="/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html">嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級</a></p>
<hr>
<span id="more"></span>

<h2 id="參考鏈接"><a href="#參考鏈接" class="headerlink" title="參考鏈接"></a>參考鏈接</h2><p><a href="https://itexp.blog.csdn.net/article/details/83793309">https://itexp.blog.csdn.net/article/details/83793309</a></p>
<p><a href="https://blog.csdn.net/qq_24130227/article/details/123752964">https://blog.csdn.net/qq_24130227/article/details/123752964</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108379324">https://blog.csdn.net/qq_24130227/article/details/108379324</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/113003329">https://blog.csdn.net/qq_24130227/article/details/113003329</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/120061873">https://blog.csdn.net/qq_24130227/article/details/120061873</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108427842">https://blog.csdn.net/qq_24130227/article/details/108427842</a></p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>單片機</tag>
        <tag>iap</tag>
        <tag>bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#02）升級方案</title>
    <url>/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html</url>
    <content><![CDATA[<center>which one is better?</center>
<br>

<pre class="mermaid">
flowchart LR
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A(在引導程序中集成通信協議棧與解壓還原算法)~~~B(在應用程序中集成通信協議棧與解壓還原算法)
</pre>

<span id="more"></span>

<h2 id="思路（-1）：引導程序主導"><a href="#思路（-1）：引導程序主導" class="headerlink" title="思路（#1）：引導程序主導"></a>思路（#1）：引導程序主導</h2><table>
<thead>
<tr>
<th align="center">具體分工</th>
<th align="center">引導程序</th>
<th align="center">應用程序</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">編程操作</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">通信協議</td>
<td align="center">完備的通信協議棧</td>
<td align="center">　　　　　　　　</td>
</tr>
<tr>
<td align="center">文件解壓</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">差分還原</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<div class="note success no-icon"><p><strong>優點</strong>：設備中沒有應用程序或應用程序異常時也可以進行 IAP 升級。</p>
</div>

<div class="note danger no-icon"><p><strong>缺點</strong>：在引導程序中集成通信協議棧、文件解壓、差分還原等功能，會導致其代碼量較大。</p>
</div>

<h2 id="思路（-2）：應用程序主導"><a href="#思路（-2）：應用程序主導" class="headerlink" title="思路（#2）：應用程序主導"></a>思路（#2）：應用程序主導</h2><table>
<thead>
<tr>
<th align="center">具體分工</th>
<th align="center">引導程序</th>
<th align="center">應用程序</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">編程操作</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">通信協議</td>
<td align="center">　　　　　　　　</td>
<td align="center">完備的通信協議棧</td>
</tr>
<tr>
<td align="center">文件解壓</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">差分還原</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody>
</table>

<div class="note success no-icon"><p><strong>優點</strong>：引導程序比較簡單，佔用空間小，方便維護。</p>
</div>

<div class="note danger no-icon"><p><strong>缺點</strong>：設備中沒有應用程序或應用程序異常時無法進行 IAP 升級。</p>
</div>

<h2 id="思路（-3）：兩者各取所長"><a href="#思路（-3）：兩者各取所長" class="headerlink" title="思路（#3）：兩者各取所長"></a>思路（#3）：兩者各取所長</h2><table>
<thead>
<tr>
<th align="center">具體分工</th>
<th align="center">引導程序</th>
<th align="center">應用程序</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">編程操作</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">通信協議</td>
<td align="center">基礎的通信協議棧</td>
<td align="center">完備的通信協議棧</td>
</tr>
<tr>
<td align="center">文件解壓</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">差分還原</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody>
</table>

<div class="note success no-icon"><p><strong>特點</strong>：在引導程序中集成基礎的通信協議棧，代碼量能接受，應用程序異常時也能在線升級。</p>
</div>

<div class="note success no-icon"><p><strong>特點</strong>：在應用程序中集成完整的通信協議棧、文件解壓、差分還原等功能，功能完備。</p>
</div>

<h2 id="方案（-0）"><a href="#方案（-0）" class="headerlink" title="方案（#0）"></a>方案（#0）</h2><table>
<thead>
<tr>
<th align="center">內部flash存儲空間劃分</th>
<th align="center">內部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>
    <td align="center">中斷向量表</td>
</tr>
<tr>
    <td align="center">引導程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center">參數數據存儲區</td>
    <td align="center">掉電不丟失的系統參數</td>
</tr>
</tbody>
</table>

<p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除應用程序存儲區，然後等待接收新版應用程序（直接寫入到升級文件存儲區），等接收完畢且校驗無誤後跳轉至應用程序，至此升級完成。</p>
<h2 id="方案（-1）"><a href="#方案（-1）" class="headerlink" title="方案（#1）"></a>方案（#1）</h2><table>
<thead>
<tr>
<th align="center">內部flash存儲空間劃分</th>
<th align="center">內部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>
    <td align="center">中斷向量表</td>
</tr>
<tr>
    <td align="center">引導程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">升級數據存儲區</td>
    <td align="center">解壓後的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的壓縮文件</td>
</tr>
<tr>
    <td align="center">參數數據存儲區</td>
    <td align="center">掉電不丟失的系統參數</td>
</tr>
</tbody>
</table>

<p>或</p>
<table>
<thead>
<tr>
<th align="center">內部flash存儲空間劃分</th>
<th align="center">內部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>
    <td align="center">中斷向量表</td>
</tr>
<tr>
    <td align="center">引導程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center">參數數據存儲區</td>
    <td align="center">掉電不丟失的系統參數</td>
</tr>
</tbody>
<thead>
<tr>
<th align="center">外部flash存儲空間劃分</th>
<th align="center">外部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">升級數據存儲區</td>
    <td align="center">解壓後的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的壓縮文件</td>
</tr>
</tbody>
</table>

<h3 id="思路（-1）"><a href="#思路（-1）" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除舊版應用程序，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p>
<h3 id="思路（-2）"><a href="#思路（-2）" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至新版程序存儲區，重啓進入或跳轉進入引導程序。進入引導程序後對新版程序進行二次校驗，校驗通過後擦除舊版應用程序，然後將新版程序存儲區中的新版應用程序拷貝至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p>
<h3 id="思路（-3）"><a href="#思路（-3）" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至新版程序存儲區，重啓進入或跳轉進入引導程序。進入引導程序後對新版程序進行二次校驗，校驗通過後擦除舊版應用程序，然後將新版程序存儲區中的新版應用程序拷貝至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p>
<p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除舊版應用程序，然後將升級文件存儲區中的新版應用程序拷貝（不支持解壓和差分還原）至應用程序存儲區，最後跳轉至應用程序，至此升級完成。</p>
<h2 id="方案（-2）"><a href="#方案（-2）" class="headerlink" title="方案（#2）"></a>方案（#2）</h2><table>
<thead>
<tr>
<th align="center">內部flash存儲空間劃分</th>
<th align="center">內部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>
    <td align="center">中斷向量表</td>
</tr>
<tr>
    <td align="center">引導程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center">參數數據存儲區</td>
    <td align="center">掉電不丟失的系統參數</td>
</tr>
</tbody>
</table>

<h3 id="思路（-1）-1"><a href="#思路（-1）-1" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p>
<h3 id="思路（-2）-1"><a href="#思路（-2）-1" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p>
<h3 id="思路（-3）-1"><a href="#思路（-3）-1" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p>
<p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除備份應用存儲區，然後等待接收新版應用程序（直接寫入到備份應用存儲區），等接收完畢且校驗無誤後，翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p>
<h2 id="方案（-3）"><a href="#方案（-3）" class="headerlink" title="方案（#3）"></a>方案（#3）</h2><table>
<thead>
<tr>
<th align="center">內部flash存儲空間劃分</th>
<th align="center">內部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>
    <td align="center">中斷向量表</td>
</tr>
<tr>
    <td align="center">引導程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">升級數據存儲區</td>
    <td align="center">解壓後的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的壓縮文件</td>
</tr>
<tr>
    <td align="center">參數數據存儲區</td>
    <td align="center">掉電不丟失的系統參數</td>
</tr>
</tbody>
</table>

<p>或</p>
<table>
<thead>
<tr>
<th align="center">內部flash存儲空間劃分</th>
<th align="center">內部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引導程序存儲區<br>bootloader</td>
    <td align="center">中斷向量表</td>
</tr>
<tr>
    <td align="center">引導程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區<br>（1）</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">應用程序存儲區<br>（2）</td>
    <td align="center">重定向的中斷向量表</td>
</tr>
<tr>
    <td align="center">應用程序</td>
</tr>
<tr>
    <td align="center">參數數據存儲區</td>
    <td align="center">掉電不丟失的系統參數</td>
</tr>
</tbody>
<thead>
<tr>
<th align="center">外部flash存儲空間劃分</th>
<th align="center">外部flash存儲空間細分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">升級數據存儲區</td>
    <td align="center">解壓後的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的壓縮文件</td>
</tr>
</tbody>
</table>

<h3 id="思路（-1）-2"><a href="#思路（-1）-2" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>設備收到升級指令後，重啓進入或跳轉進入引導程序。進入引導程序後首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，最後翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p>
<h3 id="思路（-2）-2"><a href="#思路（-2）-2" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p>
<h3 id="思路（-3）-2"><a href="#思路（-3）-2" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>設備收到升級指令後，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝&#x2F;解壓&#x2F;差分還原至備份應用存儲區，翻轉APP1與APP2的有效標識，重啓進入或跳轉進入引導程序，在引導程序中根據標識跳轉至正確的應用程序，至此升級完成。</p>
<p>抹除應用程序有效標識後，重啓進入或跳轉進入引導程序。進入引導程序後等待通信，若收到升級指令，首先擦除升級文件存儲區，然後等待接收新版應用程序（暫時存放至升級文件存儲區），等接收完畢且校驗無誤後，擦除備份應用存儲區，然後將升級文件存儲區中的新版應用程序拷貝（不支持解壓和差分還原）至備份應用存儲區，最後翻轉APP1與APP2的有效標識，並根據標識跳轉至正確的應用程序，至此升級完成。</p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#04）技術細節</title>
    <url>/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html</url>
    <content><![CDATA[<p>分散加載、中斷向量表重定向</p>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#01）基礎概念</title>
    <url>/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html</url>
    <content><![CDATA[<center>傳統編程方式</center>

<pre class="mermaid">
flowchart LR
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A(先取下芯片)---&gt;B(再燒錄程序)---&gt;C(後裝回板卡)
</pre>

<center>現代編程方式</center>

<pre class="mermaid">
flowchart LR
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A(&quot;在電路編程&lt;br&gt;(ＩＣＰ)&quot;)---&gt;B(&quot;在系統編程&lt;br&gt;(ＩＳＰ)&quot;)---&gt;C(&quot;在應用編程&lt;br&gt;(ＩＡＰ)&quot;)
</pre>

<span id="more"></span>

<h2 id="傳統編程方式"><a href="#傳統編程方式" class="headerlink" title="傳統編程方式"></a>傳統編程方式</h2><p>傳統編程方式是先將程序燒錄至主控芯片中再焊接到電路板上。</p>
<p><strong>開發階段</strong></p>
<ul>
<li>➀ 從電路板上取下芯片</li>
<li>➁ 使用燒錄器燒寫程序</li>
<li>➂ 將芯片裝回至電路板</li>
</ul>
<p><strong>量產階段</strong></p>
<ul>
<li>➀ 從 tray 盤取出芯片</li>
<li>➁ 使用燒錄器燒寫程序</li>
<li>➂ 將芯片放回 tray 盤</li>
</ul>
<p><strong>維護階段</strong></p>
<ul>
<li>➀ 從電路板上拆下芯片</li>
<li>➁ 使用燒錄器燒寫程序</li>
<li>➂ 將芯片焊回至電路板</li>
</ul>
<h2 id="現代編程方式"><a href="#現代編程方式" class="headerlink" title="現代編程方式"></a>現代編程方式</h2><p>現代編程方式可以直接進行板上燒錄，不用再取下芯片放到專用的燒錄器上燒錄，極大地提高了開發、生產以及維護效率。</p>
<p>現代編程方式又可分爲：</p>
<ul>
<li>在電路編程 ICP (Circuit)</li>
<li>在系統編程 ISP (System)</li>
<li>在應用編程 IAP (Application)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">編程方式</th>
<th align="center">在電路編程</th>
<th align="center">在系統編程</th>
<th align="center">在應用編程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">核心思想</td>
<td align="center">藉助外部燒錄器<br>通過JTAG&#x2F;SWD接口<br>實現在電路編程</td>
<td align="center">藉助芯片內部<br>固化的引導程序和BOOT引腳<br>以及片上接口<br>實現在系統編程</td>
<td align="center">藉助用戶自己<br>編寫的引導程序、應用程序<br>以及片上接口、板上接口<br>實現在應用編程</td>
</tr>
<tr>
<td align="center">引導程序</td>
<td align="center">不需要</td>
<td align="center">需要芯片廠家編寫<br>並固化到某一地址空間</td>
<td align="center">需要用戶自己編寫<br>並燒錄至內部flash存儲器</td>
</tr>
<tr>
<td align="center">進入方式</td>
<td align="center">隨時待命</td>
<td align="center">需要更改BOOT引腳的電平<br>然後硬件復位<br>進入內部固化的引導程序</td>
<td align="center">隨時待命</td>
</tr>
<tr>
<td align="center">配套軟件</td>
<td align="center">燒錄軟件</td>
<td align="center">芯片廠家提供的<br>上位機ISP編程軟件</td>
<td align="center">用戶自己開發的數據傳輸軟件</td>
</tr>
<tr>
<td align="center">通信接口</td>
<td align="center">JTAG&#x2F;SWD</td>
<td align="center">取決於芯片中固化的引導程序<br>URT&#x2F;SPI&#x2F;IIC&#x2F;CAN&#x2F;USB</td>
<td align="center">理論上可以支持任意接口<br>URT&#x2F;SPI&#x2F;IIC<br>485&#x2F;CAN&#x2F;USB<br>WiFi&#x2F;BLE&#x2F;IrDA<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td>
</tr>
<tr>
<td align="center">程序升級<br>是否需要<br>拆裝芯片</td>
<td align="center">不需要<br>拆裝芯片</td>
<td align="center">不需要<br>拆裝芯片</td>
<td align="center">不需要<br>拆裝芯片</td>
</tr>
<tr>
<td align="center">程序升級<br>是否需要<br>拆裝外殼</td>
<td align="center">需要<br>拆開設備外殼</td>
<td align="center">通信接口完備的情況下<br>不需要<br>拆開設備外殼<br>485&#x2F;CAN&#x2F;USB</td>
<td align="center">通信接口完備的情況下<br>不需要<br>拆開設備外殼<br>485&#x2F;CAN&#x2F;USB&#x2F;WiFi&#x2F;BLE&#x2F;IrDA</td>
</tr>
<tr>
<td align="center">程序升級<br>是否需要<br>前往現場</td>
<td align="center">需要<br>前往設備安裝現場</td>
<td align="center">需要<br>前往設備安裝現場</td>
<td align="center">遠程通信功能完備的情況下<br>不需要<br>前往設備安裝現場<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td>
</tr>
</tbody></table>
<div class="note info no-icon"><p>ICP 主要是在開發階段使用，其燒錄速度是 ISP 和 IAP 所無法比擬的。</p>
</div>

<div class="note info no-icon"><p>IAP 與 ISP 類似，都有 bootloader 引導程序，因此無需使用燒錄器。二者的區別在於，ISP 的引導程序由芯片廠家編寫，比較簡單，無法實現用戶的定製化需求；而 IAP 的引導程序是由用戶自己實現，可以根據需求自行修改。另外 ISP 進入 boot 程序的方式是通過更改 BOOT 引腳的電平；而 IAP 則是從用戶程序中通過軟件復位或者跳轉的方式直接進入 bootloader 程序，因此相較於 ISP 來說會更加靈活。</p>
</div>

<div class="note info no-icon"><p>通過 WiFi&#x2F;BLE&#x2F;4G&#x2F;5G&#x2F;NBIoT 等無線通信技術實現 IAP 功能的方案也被稱作 OTA 空中下載技術。</p>
</div>

<table>
<thead>
<tr>
<th align="center">BOOT1</th>
<th align="center">BOOT0</th>
<th align="center">BOOT MODE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">0</td>
<td align="center">boot from 0x08000000 : main memory</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">boot from 0x1FFF0000 : boot memory</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">boot from 0x20000000 : sram memory</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#03）流程設計</title>
    <url>/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html</url>
    <content><![CDATA[<pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A1(引導程序之流程)--&gt;B1(......)--&gt;C1(跳轉至應用程序)
A2(應用程序之流程)--&gt;B2(......)--&gt;C2(跳轉至引導程序)
</pre>

<span id="more"></span>

<h2 id="引導程序流程"><a href="#引導程序流程" class="headerlink" title="引導程序流程"></a>引導程序流程</h2><p>引導程序的設計方案我知道有兩種：</p>
<ul>
<li>立即跳轉方案</li>
<li>延時跳轉方案</li>
</ul>
<p>立即跳轉方案在判斷出應用程序有效之後會立即執行跳轉操作，該方案適用於對啓動時間要求比較高的產品。延時跳轉方案則是先在引導程序中等待一段時間，在這段時間內如果沒有任何請求則時間到了之後會自動跳轉至應用程序，否則將停留在引導程序中。</p>
<h3 id="立即跳轉方案"><a href="#立即跳轉方案" class="headerlink" title="立即跳轉方案"></a>立即跳轉方案</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
PowerReset(設備上電覆位)--&gt;IapStart(引導程序開始)--&gt;IapCheckApp[檢查應用程序有效標識]--&gt;IapIsAppValid{是否有效}
IapIsAppValid--是--&gt;IapJumpToApp[跳轉進入應用程序]--&gt;IapOver(引導程序結束)
IapIsAppValid--否--&gt;IapRemap[重定向中斷向量表]--&gt;IapInit[配置相關外設]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升級數據}
IapIsHaveUpdateData--否--&gt;IapBeforeJump
IapIsHaveUpdateData--是--&gt;IapDoUpdate[執行升級操作]---&gt;IapEraseUpdateData[擦除升級數據]--&gt;IapIsUpdateSucc{升級成功}
IapIsUpdateSucc--是---&gt;IapSetAppValid[修改應用程序有效標識：有效]--&gt;IapBeforeJump[關閉外設和中斷]--&gt;IapJumpToApp
IapIsUpdateSucc--否--&gt;IapIsAppErased{應用程序已損毀}
IapIsAppErased--否--&gt;IapBeforeJump
IapIsAppErased--是&lt;br&gt;留在引導程序中--&gt;IapComm[執行通信任務]--&gt;IapIsRecvDone{收到升級數據}
IapIsRecvDone--否--&gt;IapComm
IapIsRecvDone--是--&gt;IapDoUpdate
</pre>

<h3 id="延時跳轉方案"><a href="#延時跳轉方案" class="headerlink" title="延時跳轉方案"></a>延時跳轉方案</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
PowerReset(設備上電覆位)--&gt;IapStart(引導程序開始)--&gt;IapCheckApp[檢查應用程序有效標識]--&gt;IapIsAppValid{是否有效}
IapIsAppValid--是--&gt;IapWait{計數超時&lt;br&gt;（延時跳轉）}
IapWait--否--&gt;IapWait
IapWait--是----------&gt;IapJumpToApp[跳轉進入應用程序]--&gt;IapOver(引導程序結束)
IapIsAppValid--否--&gt;IapRemap[重定向中斷向量表]--&gt;IapInit[配置相關外設]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升級數據}
IapIsHaveUpdateData--否--&gt;IapBeforeJump
IapIsHaveUpdateData--是--&gt;IapDoUpdate[執行升級操作]---&gt;IapEraseUpdateData[擦除升級數據]--&gt;IapIsUpdateSucc{升級成功}
IapIsUpdateSucc--是---&gt;IapSetAppValid[修改應用程序有效標識：有效]--&gt;IapBeforeJump[關閉外設和中斷]--&gt;IapJumpToApp
IapIsUpdateSucc--否--&gt;IapIsAppErased{應用程序已損毀}
IapIsAppErased--否--&gt;IapBeforeJump
IapIsAppErased--是&lt;br&gt;留在引導程序中--&gt;IapComm[執行通信任務]--&gt;IapIsRecvDone{收到升級數據}
IapIsRecvDone--否--&gt;IapComm
IapIsRecvDone--是--&gt;IapDoUpdate
</pre>

<h2 id="應用程序流程"><a href="#應用程序流程" class="headerlink" title="應用程序流程"></a>應用程序流程</h2><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
AppStart(應用程序開始)--&gt;AppRemap[重定向中斷向量表]--&gt;AppInit[配置相關外設]--&gt;AppTask[執行應用功能]--&gt;AppComm[執行通信任務]--&gt;AppIsRecvDone{收到升級數據}
AppIsRecvDone--否--&gt;AppTask
AppIsRecvDone--是--&gt;AppSetAppInvalid[修改應用程序有效標識：無效]--&gt;AppBeforeJump[關閉外設和中斷]--&gt;AppJumpToIap[重啓進入引導程序｜跳轉進入引導程序]--&gt;AppOver(應用程序結束)
</pre>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#05）增量升級</title>
    <url>/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html</url>
    <content><![CDATA[<p>全量升級由於要傳輸新版程序的完整鏡像，因此升級時間通常較長，升級失敗的概率也更大。那麼能不能只傳送差異數據呢？答案是可以。這種技術被稱作增量升級&#x2F;差量升級&#x2F;差分升級。</p>
<p>常見的方案有：</p>
<ul>
<li>bsdiff&#x2F;bspatch + quicklz</li>
<li>hdifflite&#x2F;hpatchlite + tinyuz</li>
</ul>
<div class="note info no-icon"><p>不過 bsdiff + quicklz 方案的內存開銷太大，因此不建議使用。</p>
</div>

<h2 id="全量升級-amp-增量升級"><a href="#全量升級-amp-增量升級" class="headerlink" title="全量升級 &amp; 增量升級"></a>全量升級 &amp; 增量升級</h2><p>增量升級確實降低了傳輸過程中的數據量，但也帶來了版本管理複雜的問題，所以說不能因爲有了增量升級，全量升級就不用了。</p>
<p>以往我們做全量升級的時候沒有引入壓縮技術，在移植 hdiff&#x2F;hpatchlite 的時候我發現，hdiff 生成的差異文件不比原文件小多少，但是其可壓縮性非常高，這樣就得把解壓算法也移植進來。既然解壓算法都已經有了，不把增量升級也壓縮一下，那豈不是很浪費？</p>
<table>
<tbody>
<tr>
    <td align="center" rowspan="2">全量升級</td>
    <td align="center">未經壓縮的新版程序</td>
    <td align="center">（✘）</td>
</tr>
<tr>
    <td align="center">經過壓縮的新版程序</td>
    <td align="center">（✔）</td>
</tr>
<tr>
    <td align="center" rowspan="2">增量升級</td>
    <td align="center">未經壓縮的差異文件</td>
    <td align="center">（✘）</td>
</tr>
<tr>
    <td align="center">經過壓縮的差異文件</td>
    <td align="center">（✔）</td>
</tr>
</tbody>
</table>

<span id="more"></span>

<h2 id="升級包頭"><a href="#升級包頭" class="headerlink" title="升級包頭"></a>升級包頭</h2><p>在線升級無非就是把新程序或者更新補丁發送給設備，設備收到後進行升級的過程。</p>
<p>爲了保證升級能夠順利進行，除了新程序或者更新補丁外，我們還要向設備發送一些附加信息，這些附加信息通常被添加至升級文件的頭部。</p>
<table>
<tbody>
<tr>
    <td align="center">魔術數字</td>
    <td align="center">04B</td>
    <td align="center">全量升級 ('Q','L','S','J')<br>增量升級 ('Z','L','S','J')</td>
</tr>
<tr>
    <td align="center">包頭長度</td>
    <td align="center">04B</td>
    <td align="center">支持變長包頭 *</td>
</tr>
<tr>
    <td align="center">文件摘要</td>
    <td align="center">04B</td>
    <td align="center">從「文件長度」之後開始計算</td>
</tr>
<tr>
    <td align="center">文件長度</td>
    <td align="center">04B</td>
    <td align="center">從「文件長度」之後開始計算</td>
</tr>
<tr>
    <td align="center">　</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
<tr>
    <td align="center">產品型號</td>
    <td align="center">08B</td>
    <td align="center">產品一型 ('P','N','-','A','0','0','0','1')<br>產品二型 ('P','N','-','A','0','0','0','2')</td>
</tr>
<tr>
    <td align="center">設備地址</td>
    <td align="center">08B</td>
    <td align="center">通配地址 (0xFFFFFFFFFFFFFFFF)<br>單點地址 (0x1111111111111111)</td>
</tr>
<tr>
    <td align="center">　</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
<tr>
    <td align="center">新程序 LEN 值</td>
    <td align="center">04B</td>
    <td align="center" rowspan="6">對舊程序進行摘要值校驗<br>或者<br>對舊程序進行差分還原時<br><br>某些可變字段必須以默認值進行處理</td>
</tr>
<tr>
    <td align="center">舊程序 LEN 值</td>
    <td align="center">04B</td>
</tr>
<tr>
    <td align="center">新程序 CRC 值</td>
    <td align="center">04B</td>
</tr>
<tr>
    <td align="center">舊程序 CRC 值</td>
    <td align="center">04B</td>
</tr>
<tr>
    <td align="center">新程序 MD5 值</td>
    <td align="center">16B</td>
</tr>
<tr>
    <td align="center">舊程序 MD5 值</td>
    <td align="center">16B</td>
</tr>
<tr>
    <td align="center">......</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
<tr>
    <td align="center">可以按需增加</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
</tbody>
</table>

<p><strong>變長包頭的優勢</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.head.scalable.png"></p>
<div class="note info no-icon"><p>升級包頭我建議做成變長的，萬一哪天包頭長度不夠用了，擴展後也能兼容現場的老設備。</p>
</div>

<h2 id="升級文件"><a href="#升級文件" class="headerlink" title="升級文件"></a>升級文件</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.1.raw.full.png" alt="未經壓縮的全量升級文件結構"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.2.zip.full.png" alt="經過壓縮的全量升級文件結構"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.4.zip.diff.png" alt="經過壓縮的增量升級文件結構"></div></div></div>

<h2 id="升級方案"><a href="#升級方案" class="headerlink" title="升級方案"></a>升級方案</h2><h3 id="未經壓縮的全量升級-經過壓縮的增量升級"><a href="#未經壓縮的全量升級-經過壓縮的增量升級" class="headerlink" title="未經壓縮的全量升級 + 經過壓縮的增量升級"></a>未經壓縮的全量升級 + 經過壓縮的增量升級</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.1.raw.full+zip.diff.png"></p>
<h3 id="經過壓縮的全量升級-經過壓縮的增量升級"><a href="#經過壓縮的全量升級-經過壓縮的增量升級" class="headerlink" title="經過壓縮的全量升級 + 經過壓縮的增量升級"></a>經過壓縮的全量升級 + 經過壓縮的增量升級</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.2.zip.full+zip.diff.png"></p>
<h2 id="升級流程"><a href="#升級流程" class="headerlink" title="升級流程"></a>升級流程</h2><h3 id="接收升級數據"><a href="#接收升級數據" class="headerlink" title="接收升級數據"></a>接收升級數據</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
Start(接收升級數據&lt;br&gt;開始)--&gt;DoRecv[接收數據]--&gt;IsHeadRecvDone{文件頭接收完畢}
IsHeadRecvDone--否&#x2F;繼續接收--&gt;DoRecv
IsHeadRecvDone--是--&gt;IsHeadParsed{文件頭已被處理}
IsHeadParsed--是----&gt;DoWrite[將接收到的數據寫入外存&lt;br&gt;如果爲「壓縮增量升級」則將數據寫入〈升級數據存儲區〉&lt;br&gt;如果爲「壓縮全量升級」則將數據寫入〈升級數據存儲區〉&lt;br&gt;如果爲「原版全量升級」則將數據寫入〈新版程序存儲區〉&lt;br&gt;（如果小程序爲舊版本則寫入時偏移75字節）]--&gt;IsFileRecvOver{文件傳輸完畢}
IsFileRecvOver--否&#x2F;繼續接收--&gt;DoRecv2[繼續接收數據]
IsFileRecvOver--是--&gt;DoCheck[校驗接收到的升級文件&lt;br&gt;如果爲「壓縮增量升級」則從〈升級數據存儲區〉中讀出數據並計算CRC值&lt;br&gt;如果爲「壓縮全量升級」則從〈升級數據存儲區〉中讀出數據並計算CRC值&lt;br&gt;如果爲「原版全量升級」則從〈新版程序存儲區〉中讀出數據並計算CRC值&lt;br&gt;（如果小程序爲舊版本則讀取時偏移75字節）]--&gt;IsCheckOK{校驗是否通過}
IsCheckOK--否--&gt;Over3(結束)
IsCheckOK--是--&gt;DoWriteHead[將文件頭中的某些數據寫入外存的第一個扇區&lt;br&gt;（如果小程序爲舊版本則將“新程序大小”加75字節）]--&gt;DoWriteHeadFlag[將該扇區中的升級標識從0xFFFFFFFF改成0xAABBFFFF]--&gt;IsA{增量升級}
IsA--是--&gt;DoSetA[發起增量升級任務]--&gt;Over4(結束)
IsA--否--&gt;IsB{有壓縮的&lt;br&gt;全量升級}
IsB--是--&gt;DoSetB[發起全量升級任務]--&gt;Over4(結束)
IsB--否--&gt;IsC{無壓縮的&lt;br&gt;全量升級}
IsC--是--&gt;DoSetC[發起全量升級任務]--&gt;Over4(結束)
IsC--否--&gt;Over5(結束)
IsHeadParsed--否--&gt;IsHeadOK{文件頭格式正確}
IsHeadOK--否--&gt;Over1(結束)
IsHeadOK--是--&gt;IsDiffUpdate{是否爲增量升級}
IsDiffUpdate--否&#x2F;繼續接收--&gt;DoRecv
IsDiffUpdate--是--&gt;IsCRCOK{文件頭中的舊程序CRC與&lt;br&gt;當前程序的CRC是否一致}
IsCRCOK--（當前程序中的可變字段以默認值進行處理）&lt;br&gt;&lt;br&gt;不一致--&gt;Over2(結束)
IsCRCOK--是&#x2F;繼續接收--&gt;DoRecv
</pre>

<h3 id="執行升級任務"><a href="#執行升級任務" class="headerlink" title="執行升級任務"></a>執行升級任務</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
Start(執行升級任務&lt;br&gt;開始)--&gt;IsUpdateFlag{升級文件接收完畢}
IsUpdateFlag--否--&gt;IsUpdateFlag
IsUpdateFlag--是--&gt;DoReadHead[從外存的第一個扇區中讀取升級信息]--&gt;IsReadSucc{讀取成功}
IsReadSucc--否--&gt;Over1(結束)
IsReadSucc--是--&gt;IsUpdateFlagIsDownload{升級標識&#x3D;&#x3D;0xAABBFFFF}
IsUpdateFlagIsDownload--否--&gt;Over2(結束)
IsUpdateFlagIsDownload--是--&gt;IsUpdateTypeIsZipDiff{是否爲壓縮增量升級}
IsUpdateTypeIsZipDiff--是--&gt;DoUnDiff[執行差分還原操作]--如果小程序爲舊版本&lt;br&gt;則寫入時偏移75字節&lt;br&gt;當前程序中的可變字段以默認值進行處理---&gt;DoCheckNewAppCRC
IsUpdateTypeIsZipDiff--否--&gt;IsUpdateTypeIsZipFull{是否爲壓縮全量升級}
IsUpdateTypeIsZipFull--是--&gt;DoUnZip[執行文件解壓操作]--如果小程序爲舊版本&lt;br&gt;則寫入時偏移75字節---&gt;DoCheckNewAppCRC
IsUpdateTypeIsZipFull--否--&gt;IsUpdateTypeIsRawFull{是否爲原版全量升級}
IsUpdateTypeIsRawFull--是--&gt;DoNothing[無需執行任何操作]---&gt;DoCheckNewAppCRC[校驗新程序&lt;br&gt;對比文件頭中的新程序CRC與&lt;br&gt;新程序存儲區中的數據的CRC]
IsUpdateTypeIsRawFull--否--&gt;Over3(結束)
DoCheckNewAppCRC--如果小程序爲舊版本&lt;br&gt;則讀取時偏移75字節---&gt;IsCRCCheckOK{CRC是否一致}
IsCRCCheckOK--否--&gt;Over4(結束)
IsCRCCheckOK--是--&gt;DoChangeUpdateFlag[將外存中的升級標識從0xAABBFFFF改爲0xAABBCCDD]--&gt;IsChangeSucc{修改是否成功}
IsChangeSucc--否--&gt;Over5(結束)
IsChangeSucc--是--&gt;DoChangeInternalFlashUpdateFlag[將內部flash中的0xAABBCCDD改成0x0000CCDD]--&gt;DoReset[一秒後重啓進入引導程序]--&gt;OverX(結束)
</pre>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#06）差分還原 haptchlite 移植</title>
    <url>/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html</url>
    <content><![CDATA[<p>最近發現了一個優秀的差分還原算法：hdiff &amp; hpatch，它通過數據流的思想把 O(n) 的空間複雜度轉嫁給了硬盤，使得內存的開銷極低，非常適合應用於嵌入式領域。</p>
<p><img src="/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff-tools-compare.png"></p>
<span id="more"></span>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="hpatchlite"><a href="#hpatchlite" class="headerlink" title="hpatchlite"></a>hpatchlite</h3><p>時間複雜度：O(oldSize+newSize)<br>空間複雜度：O(1)<br>　　還原代碼開銷｜ROM &#x3D; 876 字節 (compiled by armcc v5.06 update4 build 422)<br>　　還原內存開銷｜RAM &#x3D; 還原緩衝大小 + 解壓內存開銷</p>
<p>注：還原緩衝大小在還原時指定，至少3個字節，還原緩衝越小還原得越慢。</p>
<h3 id="tinyuz"><a href="#tinyuz" class="headerlink" title="tinyuz"></a>tinyuz</h3><p>時間複雜度：O(oldSize+newSize)<br>空間複雜度：O(1)<br>　　解壓代碼開銷｜流模式｜ROM &#x3D; 1142 字節 (compiled by armcc v5.06 update4 build 422)<br>　　解壓內存開銷｜流模式｜RAM &#x3D; 壓縮字典大小 + 解壓緩衝大小</p>
<p>注：壓縮字典大小在壓縮時指定，至少1個字節，壓縮字典越小壓縮率越低。<br>注：解壓緩衝大小在解壓時指定，至少2個字節，解壓緩衝越小解壓縮越慢。</p>
<h3 id="appendix"><a href="#appendix" class="headerlink" title="appendix"></a>appendix</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 876          0          0          0          0      10783   hpatch_lite.o</span><br><span class="line">1142          0          0          0          0      13541   tuz_dec.o</span><br><span class="line"></span><br><span class="line"> 626         80          0         12          0      12256   hpatch_user.o</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">244           0          0          0          0       2146   bspatch.o</span><br><span class="line">586           6         64          0          0       6749   quicklz.o</span><br><span class="line"></span><br><span class="line">102           4          8          0          0       2821   bspatch_user.o</span><br><span class="line"> 52           0          0          0          0       2096   quicklz_user.o</span><br></pre></td></tr></table></figure>

<h2 id="移植說明"><a href="#移植說明" class="headerlink" title="移植說明"></a>移植說明</h2><p>將 hdiffpatch.hpatchlite &amp; tinyuz 移植至單片機 bare metal 裸機系統（based on hdiffpatch v4）</p>
<h3 id="拿來"><a href="#拿來" class="headerlink" title="拿來"></a>拿來</h3><p>將 tinyuz&#x2F;decompress 目錄拷貝至目標工程中。</p>
<p>將 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatch 目錄拷貝至目標工程中。</p>
<p>將 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatchLite 目錄拷貝至目標工程中。</p>
<p>將 HPatchLite&#x2F;decompresser_demo.h 文件拷貝至目標工程中。</p>
<h3 id="畫瓢"><a href="#畫瓢" class="headerlink" title="畫瓢"></a>畫瓢</h3><p>依 HPatchLite&#x2F;hpatchi.c&#x2F;hpatchi() 函數畫瓢：移植還原功能</p>
<p>依 tinyuz&#x2F;tinyuz_demo.cpp&#x2F;_tuz_decompress_stream() 函數畫瓢：移植解壓功能</p>
<p>done!</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿來依葫蘆畫瓢，說得簡單，做起來着實還是費了點功夫，這幾年搞嵌入式搞得有些侷限了，面對句(gōu)柄這種用法竟感覺無從下手。😅</p>
<p>作者提供了以下兩個接口函數：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpatch_lite_open()</span><br><span class="line"></span><br><span class="line">hpatch_lite_patch()</span><br></pre></td></tr></table></figure>

<p>看着挺簡單的吧，然而他實際上是這樣的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hpatch_lite by stream: hpatch_lite_open()+hpatch_lite_patch() compiled by Mbed Studio is 662 bytes</span></span><br><span class="line"><span class="comment">//   hdiffpatch v4.2.3, other patcher compiled by Mbed Studio:</span></span><br><span class="line"><span class="comment">//      patch_single_stream() 2356 bytes (hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"><span class="comment">//      patch_decompress_with_cache() 2846 bytes (_IS_NEED_CACHE_OLD_BY_COVERS=0,hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//diff_data must created by create_lite_diff()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span>&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    <span class="comment">//must read data_size data to out_data, from read_from_pos of stream; if read error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    <span class="comment">//must write data_size data to sequence stream; if write error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hpatch_lite open</span></span><br><span class="line"><span class="comment">// read lite headinfo from diff_data</span></span><br><span class="line"><span class="comment">// if diff_data uncompress(*out_compress_type==hpi_compressType_no), *out_uncompressSize==0;</span></span><br><span class="line"><span class="comment">// if (*out_compress_type!=hpi_compressType_no), you need open compressed data by decompresser</span></span><br><span class="line"><span class="comment">//      (see https://github.com/sisong/HPatchLite/decompresser_demo.h &amp; https://github.com/sisong/HPatchLite/hpatchi.c)</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,</span></span><br><span class="line"><span class="params">                          hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br><span class="line"><span class="comment">//hpatch_lite patch</span></span><br><span class="line"><span class="comment">//	used temp_cache_size memory + &#123;decompress buffer*1&#125;</span></span><br><span class="line"><span class="comment">//  note: temp_cache_size&gt;=hpi_kMinCacheSize</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,</span></span><br><span class="line"><span class="params">                           hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure>

<p>試着分析一下：</p>
<p><strong>差分包頭信息讀取接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分包頭信息讀取接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStreamHandle        diff_data           注意此處入參：差分數據流句柄（個人理解：如果不需要該句柄的話可以將其定義爲空指針）</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStream_read         read_diff           注意此處入參：差分數據流讀取函數（用戶實現：以數據流的方式讀取外部存儲中差分數據分區的數據）</span></span><br><span class="line"><span class="comment"> * @param hpi_compressType             *out_compress_type   差分包頭信息：差分包壓縮類型</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_newSize         差分包頭信息：還原數據的長度</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_uncompressSize  差分包頭信息：解壓之後的長度（如果差分包未被壓縮則*out_uncompressSize輸出0）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>差分包頭定義</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_kHeadSize (2+1+1) <span class="comment">//&quot;hI&quot; + hpi_compressType + (versionCode + newSize_Bytes + uncompressSize_Bytes) &#123; + newSize + uncompressSize&#125; &#123; + dictSize&#125;</span></span></span><br><span class="line">差分包頭[<span class="number">0</span>] : 魔術數字 <span class="number">68</span> <span class="string">&#x27;h&#x27;</span></span><br><span class="line">差分包頭[<span class="number">1</span>] : 魔術數字 <span class="number">49</span> <span class="string">&#x27;I&#x27;</span></span><br><span class="line">差分包頭[<span class="number">2</span>] : 壓縮類型</span><br><span class="line">差分包頭[<span class="number">3</span>] : 版本代碼[<span class="number">7</span>:<span class="number">6</span>]+解壓數據長度所佔的字節數u[<span class="number">5</span>:<span class="number">3</span>]+還原數據長度所佔的字節數n[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">差分包頭[<span class="number">4</span> ~ <span class="number">4</span>+n] : 還原數據長度</span><br><span class="line">差分包頭[? ~ ?+u] : 解壓數據長度</span><br><span class="line"></span><br><span class="line">壓縮包頭[? ~ ?+<span class="number">4</span>] : 壓縮字典大小</span><br></pre></td></tr></table></figure>

<p><strong>差分還原接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分還原接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpatchi_listener_t            listener            詳見 hpatchi_listener_t 分析</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                     newSize             還原數據的長度</span></span><br><span class="line"><span class="comment"> * @param hpi_byte                     *temp_cache          還原緩衝的地址</span></span><br><span class="line"><span class="comment"> * @param hpi_size_t                    temp_cache_size     還原緩衝的大小（&gt;=2）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>hpatchi_listener_t</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong>hpatchi_listener_t 實例（差分包未經壓縮）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 差分數據流句柄,</span><br><span class="line">    .read_diff = 差分數據流讀取函數,    由用戶去實現（從外部存儲的差分數據分區讀取）（函數一）</span><br><span class="line"></span><br><span class="line">    .read_old  = 舊版數據流讀取函數,    由用戶去實現（從內部存儲的舊版程序分區讀取）（函數二）</span><br><span class="line">    .write_new = 還原數據流寫入函數,    由用戶去實現（寫入到外部存儲的還原程序分區）（函數三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>hpatchi_listener_t 實例（差分包經過壓縮）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tuz_TStream _tuz_stream = <span class="comment">/* 壓縮數據流句柄 */</span></span><br><span class="line">&#123;</span><br><span class="line">    .in_Stream = 差分數據流句柄,</span><br><span class="line">    .read_code = 差分數據流讀取函數,    由用戶去實現（從外部存儲的差分數據分區讀取）（函數一）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 壓縮數據流句柄,        _tuz_stream</span><br><span class="line">    .read_diff = 壓縮數據流解壓函數,    _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line"></span><br><span class="line">    .read_old  = 舊版數據流讀取函數,    由用戶去實現（從內部存儲的舊版程序分區讀取）（函數二）</span><br><span class="line">    .write_new = 還原數據流寫入函數,    由用戶去實現（寫入到外部存儲的還原程序分區）（函數三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最後需要特別注意的一點是：差分包必須由 create_lite_diff() 函數創建。宏觀上來說就是差分包必須要通過 hdiffi.exe 程序生成，不能使用 hdiffz.exe 生成。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpi_BOOL 差分數據流讀取函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 舊版數據流讀取函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 還原數據流寫入函數()</span><br><span class="line">&#123;</span><br><span class="line">    由用戶實現</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根據 hpatch_lite_open() + hpatch_lite_patch() 編寫的還原程序</span></span><br><span class="line"><span class="type">hpi_patch_result_t</span> <span class="title function_">hpi_patch</span><span class="params">(接收到的差分包大小, “還原緩衝大小”, “解壓緩衝大小”)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 差分數據流句柄：如果不需要該句柄的話可以將其定義爲空指針</span></span><br><span class="line">    hpatch_lite_open(“差分數據流句柄”, “差分數據流讀取函數”, 輸出“差分包信息”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    解壓緩衝地址 = <span class="built_in">malloc</span>();</span><br><span class="line">    解壓字典大小 = _tuz_TStream_getReservedMemSize(“差分數據流句柄”, “差分數據流讀取函數”);</span><br><span class="line">    tuz_TStream_open(_tuz_stream, “差分數據流句柄”, “差分數據流讀取函數”, “解壓緩衝地址”, “解壓字典大小”, “解壓緩衝大小”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    patch_listener</span><br><span class="line">        .diff_data = _tuz_stream</span><br><span class="line">        .read_diff = _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line">        .read_old  = 舊版數據流讀取函數()</span><br><span class="line">        .write_new = 還原數據流寫入函數()</span><br><span class="line"></span><br><span class="line">    還原緩衝地址 = <span class="built_in">malloc</span>();</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(“patch_listener”, “還原數據期望長度”, “還原緩衝地址”, “還原緩衝大小”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源碼"><a href="#源碼" class="headerlink" title="源碼"></a>源碼</h3><figure class="highlight c"><figcaption><span>hpatch_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __hpatch_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __hpatch_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span>; <span class="comment">// (差分文件的大小, 差分緩衝大小, 解壓緩衝大小)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __hpatch_port_h__ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>hpatch_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_lite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decompresser_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從外部flash中以數據流的形式讀取差分數據（由用戶記錄數據流的位置：讀到哪兒了）（數據流結束時需要將 *data_size 置爲當前所讀數據的實際長度）（*data_size == decompress_cache_size）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_diff(hpi_TInputStreamHandle input_stream, hpi_byte *data, <span class="type">hpi_size_t</span> *data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="keyword">if</span> ((patch_file_rxd_pos + *data_size) &gt; patch_file_len)</span><br><span class="line">    &#123;</span><br><span class="line">        *data_size = patch_file_len - patch_file_rxd_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, offset+patch_file_rxd_pos, data, *data_size);</span><br><span class="line">    patch_file_rxd_pos += *data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從內部flash中以數據流的形式讀取舊版程序</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_old(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">hpi_pos_t</span> read_pos, hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_older&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, read_pos, data, data_size);</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將還原數據以數據流的形式寫入外部flash中（由用戶記錄數據流的位置：寫到哪兒了）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_write_new(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">const</span> hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, newer_file_txd_pos, data, data_size);</span><br><span class="line">    newer_file_txd_pos += data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* pmem = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* patch_cache;</span><br><span class="line"></span><br><span class="line">    patch_file_len = diff_file_size;</span><br><span class="line">    patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line">    newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hpi_TInputStreamHandle  void_stream_handle = <span class="literal">NULL</span>;</span><br><span class="line">    hpi_TInputStream_read   diff_stream_read = _do_read_diff;</span><br><span class="line">    hpi_compressType        compress_type;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               new_size;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               uncompress_size;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_open(void_stream_handle, diff_stream_read, &amp;compress_type, &amp;new_size, &amp;uncompress_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">hpatchi_listener_t</span> listener;</span><br><span class="line">    listener.read_old  = _do_read_old;</span><br><span class="line">    listener.write_new = _do_write_new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (compress_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_no:  <span class="comment">// memory size: patch_cache_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(patch_cache_size);</span><br><span class="line">            patch_cache = pmem;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = void_stream_handle;</span><br><span class="line">            listener.read_diff = diff_stream_read;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _CompressPlugin_tuz</span></span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_tuz:  <span class="comment">// requirements memory size: patch_cache_size + decompress_cache_size + decompress_dict_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            tuz_TStream tuz_stream_handle;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> decompress_dict_size  = _tuz_TStream_getReservedMemSize(void_stream_handle, diff_stream_read);</span><br><span class="line"></span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(decompress_dict_size + decompress_cache_size + patch_cache_size);</span><br><span class="line"></span><br><span class="line">            tuz_TStream_open(&amp;tuz_stream_handle, void_stream_handle, diff_stream_read, pmem, (<span class="type">tuz_size_t</span>)decompress_dict_size, (<span class="type">tuz_size_t</span>)decompress_cache_size);</span><br><span class="line"></span><br><span class="line">            patch_cache = pmem + decompress_dict_size + decompress_cache_size;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = &amp;tuz_stream_handle;</span><br><span class="line">            listener.read_diff = _tuz_TStream_decompress;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> clear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(&amp;listener, new_size, patch_cache, (<span class="type">hpi_size_t</span>)patch_cache_size);</span><br><span class="line"></span><br><span class="line">clear:</span><br><span class="line">    <span class="keyword">if</span> (pmem) &#123; hpi_free(pmem); pmem=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info no-icon"><p>爲了使代碼看起來更加簡潔，因此例程中沒有進行任何異常處理。</p>
</div>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
        <tag>差分還原算法</tag>
        <tag>增量升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#07）壓縮解壓 tinyuz 移植</title>
    <url>/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html</url>
    <content><![CDATA[<p>與上文類似，對 tinyuz 也進行二次封裝以便上層調用：</p>
<figure class="highlight c"><figcaption><span>tinyuz_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __tinyuz_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __tinyuz_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUZ_DECOMPRESS_SPACE_SIZE       512*1024            <span class="comment">// 外部存儲中〈差分文件區〉的空間大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TTinyuzResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TINYUZ_SUCCESS=<span class="number">0</span>,</span><br><span class="line">    TINYUZ_OPTIONS_ERROR,</span><br><span class="line">    TINYUZ_OPENREAD_ERROR,</span><br><span class="line">    TINYUZ_OPENWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILEREAD_ERROR,</span><br><span class="line">    TINYUZ_FILEWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILECLOSE_ERROR,</span><br><span class="line">    TINYUZ_MEM_ERROR,</span><br><span class="line">    TINYUZ_COMPRESS_ERROR,</span><br><span class="line">    TINYUZ_DECOMPRESS_ERROR,</span><br><span class="line">&#125; TTinyuzResult;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __tinyuz_port_h__ */</span></span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight c"><figcaption><span>tinyuz_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tinyuz_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuz_dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TTuzListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> hpatch_TStreamInput*  input_file_stream_handle;</span><br><span class="line">    hpatch_StreamPos_t          readPos;</span><br><span class="line">    tuz_TInputStream_read       _do_read_encompress_file;</span><br><span class="line">&#125;TTuzListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從外部flash中以數據流的形式讀取壓縮數據</span></span><br><span class="line">hpatch_BOOL _do_read_encompress_file(<span class="type">const</span> hpatch_TStreamInput* stream, hpatch_StreamPos_t readFromPos, <span class="type">unsigned</span> <span class="type">char</span>* out_data, <span class="type">unsigned</span> <span class="type">char</span>* out_data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> readLen = (<span class="type">size_t</span>)(out_data_end - out_data);</span><br><span class="line">    <span class="keyword">if</span> (readLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> compressed_stream_size = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((readLen &gt; compressed_stream_size) || (readFromPos &gt; compressed_stream_size - readLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, readFromPos, out_data, readLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將解壓數據以數據流的形式寫入外部flash中</span></span><br><span class="line">hpatch_BOOL _do_write_decompress_file(<span class="type">const</span> hpatch_TStreamOutput* stream, hpatch_StreamPos_t writeToPos, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> writeLen = (<span class="type">size_t</span>)(data_end - data);</span><br><span class="line">    <span class="keyword">if</span> (writeLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> write_max_space = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((writeLen &gt; write_max_space)||(writeToPos &gt; write_max_space - writeLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用戶實現</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, offset+writeToPos, data, writeLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> tuz_BOOL <span class="title function_">input_file_stream_read_function</span><span class="params">(<span class="type">void</span> *listener, tuz_byte *decompressed_file_stream, <span class="type">tuz_size_t</span> *code_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    TTuzListener *self = (TTuzListener*)listener;</span><br><span class="line">    <span class="type">tuz_size_t</span> r_len = *code_size;</span><br><span class="line">    hpatch_StreamPos_t curReadPos = self-&gt;readPos;</span><br><span class="line">    hpatch_StreamPos_t s_size = self-&gt;input_file_stream_handle-&gt;streamSize - curReadPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_len &gt; s_size)&#123;</span><br><span class="line">        r_len = (<span class="type">tuz_size_t</span>)s_size;</span><br><span class="line">        *code_size = r_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;readPos += r_len;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;input_file_stream_handle-&gt;read(self-&gt;input_file_stream_handle, curReadPos, decompressed_file_stream, decompressed_file_stream + r_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    hpatch_TStreamOutput decompressed_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;decompressed_file_stream_handle,</span><br><span class="line">        .streamSize = TUZ_DECOMPRESS_SPACE_SIZE, <span class="comment">// 外部存儲中〈差分文件區〉的空間大小</span></span><br><span class="line">        .write = _do_write_decompress_file, <span class="comment">// stream write</span></span><br><span class="line">        .read_writed = <span class="literal">NULL</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hpatch_TStreamInput input_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;input_file_stream_handle,</span><br><span class="line">        .streamSize = compressed_file_size, <span class="comment">// 壓縮文件的實際大小</span></span><br><span class="line">        .read = _do_read_encompress_file, <span class="comment">// stream read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TTuzListener listener = &#123;&amp;input_file_stream_handle, <span class="number">0</span>, input_file_stream_read_function&#125;;</span><br><span class="line">    tuz_TStream tuz;</span><br><span class="line">    tuz_TResult result = tuz_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 壓縮的時候會以指定的字典大小進行壓縮｜因此解壓的時候要從壓縮包頭中讀取字典大小</span></span><br><span class="line">    <span class="type">tuz_size_t</span> dictSize = tuz_TStream_read_dict_size(&amp;listener, listener._do_read_encompress_file);</span><br><span class="line"></span><br><span class="line">    tuz_byte* decompress_buf = <span class="number">0</span>;</span><br><span class="line">    cache_size &gt;&gt;= <span class="number">1</span>; <span class="comment">// 除二操作</span></span><br><span class="line">    decompress_buf = (tuz_byte*)tuz_malloc(dictSize + cache_size*<span class="number">2</span>); <span class="comment">// 解壓過程中要用到的臨時空間大小 = 字典大小 + 解壓緩衝區大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decompress_buf == <span class="number">0</span>) <span class="keyword">return</span> TINYUZ_MEM_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tuz_TStream_open 僅僅是用來初始化 tuz 這個勾柄的（tuz後面的參數都是給tuz賦值用的）</span></span><br><span class="line">    result = tuz_TStream_open(&amp;tuz, &amp;listener, listener._do_read_encompress_file, decompress_buf + cache_size, (<span class="type">tuz_size_t</span>)dictSize, (<span class="type">tuz_size_t</span>)cache_size);</span><br><span class="line"></span><br><span class="line">    hpatch_StreamPos_t stream_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (result == tuz_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">tuz_size_t</span> decompress_len = (<span class="type">tuz_size_t</span>)cache_size; <span class="comment">// 給decompress_len賦一個初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解壓一包數據到 decompress_buf 中｜並得到該包長度 decompress_len</span></span><br><span class="line">        result = tuz_TStream_decompress_partial(&amp;tuz, decompress_buf, &amp;decompress_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt;= tuz_STREAM_END)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 將當前解壓的 decompress_buf 中的數據寫到 decompressed_file_stream_handle 數據流中</span></span><br><span class="line">            <span class="keyword">if</span> (decompressed_file_stream_handle.write(&amp;decompressed_file_stream_handle, stream_index, decompress_buf, decompress_buf + decompress_len))</span><br><span class="line">            &#123;</span><br><span class="line">                stream_index += decompress_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tuz_free(decompress_buf);</span><br><span class="line">                <span class="keyword">return</span> TINYUZ_OPENWRITE_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tuz_free(decompress_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>壓縮解壓算法</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升級功能（#08）引導程序 bootloader 升級</title>
    <url>/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>開發筆記</category>
      </categories>
      <tags>
        <tag>嵌入式軟件開發</tag>
        <tag>在線升級</tag>
      </tags>
  </entry>
</search>
