<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>囗－囗</title>
    <url>/sulfurandcu.io/clnyhr2mt003b10rq5snfeg6t.html</url>
    <content><![CDATA[<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center><br></center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>
<center>囗囗囗囗囗囗囗　囗囗囗囗囗囗囗</center>

<br>

<span id="more"></span>

<br>
]]></content>
  </entry>
  <entry>
    <title>黄金时代随风而逝</title>
    <url>/sulfurandcu.io/clnyhr2mh001p10rq8w62htd4.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnyhr2mh001p10rq8w62htd4/cast.away.illusions.jpg"></p>
<center><a href="https://dribbble.com/shots/16430646-CAST-AWAY-ILLUSIONS-PREPARE-FOR-STRUGGLE">囗囗囗囗　囗囗囗囗</a></center>

<br>

<center>
黄金时代<br>
1996 1997 1998 1999 2000<br>
2001 2002 2003 2004 2005<br>
2006 2007 2008 2009 2010<br>
2011 2012 2013 2014 2015<br>
2016 2017 2018 2019 2020<br>
</center>
<br>

<span id="more"></span>

<center>
白银时代<br>
2021 2022 2023 2024 2025<br>
2026 2027 2028 2029 2030<br>
2031 2032 2033 2034 2035<br>
2036 2037 2038 2039 2040<br>
</center>
<br>
<center>
青铜时代<br>
2041 2042 2043 2044 2045<br>
2046 2047 2048 2049 2050<br>
2051 2052 2053 2054 2055<br>
2056 2057 2058 2059 2060<br>
</center>
<br>
<center>
黑铁时代<br>
2061 2062 2063 2064 2065<br>
2066 2067 2068 2069 2070<br>
2071 2072 2073 2074 2075<br>
2076 2077 2078 2079 2080<br>
</center>
<br>
]]></content>
      <categories>
        <category>白银时代</category>
      </categories>
  </entry>
  <entry>
    <title>搭建一个文档系统</title>
    <url>/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/architecture.png"></p>
<center>・文档系统架构图・</center>

<span id="more"></span>

<br>

<div class="note info"><p><code>#web</code> <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a></p>
</div>

<div class="note info"><p><code>#ssh</code> localhost＠127.0.0.1 📢 Password:password</p>
</div>

<div class="note info"><p><code>#svn</code> <a href="http://svn.sulfurandcu.com/doc">http://svn.sulfurandcu.com/doc</a></p>
</div>


<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>该系统由「一个代码库」「若干开发者」和「一台服务器」组成。</p>
<h3 id="代码库"><a href="#代码库" class="headerlink" title="代码库"></a>代码库</h3><p>代码库（SVN）中有一份文档系统的源码，里面放着文档系统的配置文件和各个项目的文档文件。</p>
<h3 id="开发者"><a href="#开发者" class="headerlink" title="开发者"></a>开发者</h3><p>开发者可以将 SVN 中的文档系统源码 checkout 至本地进行编辑、预览。修改完毕后再提交回去。</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>服务器中也有一份从 SVN 中 checkout 出来的文档系统源码，这些内容被一个叫做文档网站生成器的软件动态转换成网页在 3000 端口以 HTTP 的形式对外提供访问。这样我们就可以通过浏览器以输入 IP 地址加端口的形式访问该文档系统。另外该服务器上还运行着一个周期任务，这个任务每隔 15 分钟（准确地说是在00分、15分、30分、45分的时候）<strong>从 SVN 服务器中</strong>更新一次文档系统源码。这样就实现了文档系统的自动更新。</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="第一步：搭建环境"><a href="#第一步：搭建环境" class="headerlink" title="第一步：搭建环境"></a>第一步：搭建环境</h3><p>➀ 安装「node.js」（一个基于 Chrome V8 引擎 的 JavaScript 运行时环境）</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/nodejs.png"></p>
<center>
<a href="https://nodejs.org/" target="_blank">https://nodejs.org/</a>
</center><br>

<p>➁ 安装「docsify」（一个使用 JavaScript 编写的文档网站生成器）</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/docsify.png"></p>
<center>
<a href="https://docsify.js.org/" target="_blank">https://docsify.js.org/</a>
</center><br>

<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/docsify.install.png"></p>
<center>
npm i -g docsify-cli
</center>

<h3 id="第二步：建立文档"><a href="#第二步：建立文档" class="headerlink" title="第二步：建立文档"></a>第二步：建立文档</h3><p>建立文档框架并提交至代码仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://svn.sulfurandcu.com/doc</span><br></pre></td></tr></table></figure>

<h3 id="第三步：预览效果"><a href="#第三步：预览效果" class="headerlink" title="第三步：预览效果"></a>第三步：预览效果</h3><p>将上述文档框架下载到本地，在其根目录下执行 docsify serve 命令启动一个本地服务器，就可以在本地预览效果。</p>
<p><img src="/sulfurandcu.io/clnybw9vu001xbkrq6tmo3euo/docsify.server.png"></p>
<center>
docsify s
</center>

<div class="note warning"><p>点击 <a href="http://localhost:3000/">http://localhost:3000</a> 即可预览</p>
</div>

<h3 id="第四步：进入正轨（编辑文档、本地预览、提交变更）"><a href="#第四步：进入正轨（编辑文档、本地预览、提交变更）" class="headerlink" title="第四步：进入正轨（编辑文档、本地预览、提交变更）"></a>第四步：进入正轨（编辑文档、本地预览、提交变更）</h3><p>搭建好开发环境、将〈＃项目文档〉下载到本地且知道怎么预览以后，就可以开始编辑、预览、提交了，跟代码的编辑、调试、提交没什么两样！</p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>这部分内容是文档系统搭建的一些具体细节，在这里记录一下以供后续维护人员参考。需要说明的一点是，当前所使用的服务器运行的是 Windows 操作系统，因此以下操作均基于该操作系统。</p>
<h3 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h3><p>在 Windows 系统中，使用系统自带的任务计划程序实现：在〈计算机管理・任务计划程序〉中创建一个周期任务，每隔一段时间执行一次以下脚本。</p>
<figure class="highlight py"><figcaption><span>doc.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;svn up \&quot;e:/＃文档系统\&quot; --non-interactive&quot;</span></span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure>

<div class="note info"><p>任务计划程序配置好之后重启电脑不影响其运行</p>
</div>

<h3 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h3><p>改动提交之后想立即更新至文档服务器应该怎么做呢？</p>
<p>远程连接到服务器，手动执行一下 doc.py 即可。</p>
<h3 id="手动启动-docsify-服务"><a href="#手动启动-docsify-服务" class="headerlink" title="手动启动 docsify 服务"></a>手动启动 docsify 服务</h3><p>电脑关机后 docsify 服务也会随之停止，因此每次开机后都要手动启动 docsify 服务。我尝试过启动后自动运行，但是经常会执行失败。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="服务器重启后网页无法访问！"><a href="#服务器重启后网页无法访问！" class="headerlink" title="服务器重启后网页无法访问！"></a>服务器重启后网页无法访问！</h3><p>检查 docsify 服务是否已经启动。</p>
<h3 id="修改提交之后内容没有更新！"><a href="#修改提交之后内容没有更新！" class="headerlink" title="修改提交之后内容没有更新！"></a>修改提交之后内容没有更新！</h3><p>首先看周期更新任务是否正常执行。</p>
<p>如果周期更新任务没有问题，那么有可能是管理员同志的公司帐号密码修改过，而文档服务器中 svn 的访问密码没有同步修改导致的。</p>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>docsify</tag>
      </tags>
  </entry>
  <entry>
    <title>思源字体使用指南</title>
    <url>/sulfurandcu.io/clnyhr2mj002010rq1hzhgzb2.html</url>
    <content><![CDATA[<p>思源字体是 adobe 的开源字体项目，属于泛中日韩字体，即支持中文、日文、韩文三种文字，其中中文又分为大陆字形、香港字形和台湾字形。</p>
<table>
<thead>
<tr>
<th align="center">语言</th>
<th align="center">文字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">中文（大陆）</td>
<td align="center">大陆独占的汉字－简体<br>大陆特色的汉字－繁体</td>
</tr>
<tr>
<td align="center">中文（香港）</td>
<td align="center">香港特色的汉字－繁体</td>
</tr>
<tr>
<td align="center">中文（台湾）</td>
<td align="center">台湾特色的汉字－繁体</td>
</tr>
<tr>
<td align="center">日文（日本）</td>
<td align="center">日本特色的汉字＋假名</td>
</tr>
<tr>
<td align="center">韩文（朝韩）</td>
<td align="center">朝韩特色的汉字＋谚文</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="思源宋体"><a href="#思源宋体" class="headerlink" title="思源宋体"></a>思源宋体</h1><p><strong>OTF 语言</strong><br>ZIP : 日语・七个 otf 文件对应七个字重・Language Specific OTFs J・Source Han Serif<br>ZIP : 韩语・七个 otf 文件对应七个字重・Language Specific OTFs K・Source Han Serif K<br>ZIP : 简中・七个 otf 文件对应七个字重・Language Specific OTFs S・Source Han Serif SC<br>ZIP : 台中・七个 otf 文件对应七个字重・Language Specific OTFs T・Source Han Serif TC<br>ZIP : 港中・七个 otf 文件对应七个字重・Language Specific OTFs T・Source Han Serif HC</p>
<p><strong>OTF 地区</strong><br>ZIP : 日本・七个 otf 文件对应七个字重・Region Specific Subset OTFs JP・Source Han Serif JP<br>ZIP : 韩国・七个 otf 文件对应七个字重・Region Specific Subset OTFs KR・Source Han Serif KR<br>ZIP : 大陆・七个 otf 文件对应七个字重・Region Specific Subset OTFs CN・Source Han Serif CN<br>ZIP : 台湾・七个 otf 文件对应七个字重・Region Specific Subset OTFs TW・Source Han Serif TW<br>ZIP : 香港・七个 otf 文件对应七个字重・Region Specific Subset OTFs HK・Source Han Serif HK</p>
<p><strong>OTF 语言</strong>（上述文件的归档包）<br>ZIP : All Static Language Specific OTFs</p>
<p><strong>OTF 地区</strong>（上述文件的归档包）<br>ZIP : All Static Region Specific Subset OTFs</p>
<p><strong>OTC 版本</strong><br>ZIP : 全部・七个 ttc 文件对应七个字重・All Static Language Specific OTCs・Source Han Serif</p>
<p><strong>SuperOTC 版本</strong><br>ZIP : 全部・一个 ttc 文件包含所有字重・Static Super OTC・Source Han Serif</p>
<p><strong>All Variable Fonts</strong> (OTF, TTF, OTC, WOFF2)</p>
<ul>
<li>OTF<ul>
<li>OTF 语言（五个 otf 文件对应五种字形）</li>
<li>OTF 地区（五个 otf 文件对应五种字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 语言（五个 ttf 文件对应五种字形）</li>
<li>TTF 地区（五个 ttf 文件对应五种字形）</li>
</ul>
</li>
<li>OTC<ul>
<li>一个 otf.ttc 文件（上面 OTF 语言的合集）</li>
<li>一个 ttf.ttc 文件（上面 TTF 语言的合集）</li>
</ul>
</li>
<li>WOFF2<ul>
<li>OTF<ul>
<li>OTF 语言（五个 otf.woff2 文件对应五种字形）</li>
<li>OTF 地区（五个 otf.woff2 文件对应五种字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 语言（五个 ttf.woff2 文件对应五种字形）</li>
<li>TTF 地区（五个 ttf.woff2 文件对应五种字形）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>思源宋体的七个字重：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 - extralight</span><br><span class="line">300 - light</span><br><span class="line">400 - regular</span><br><span class="line">500 - medium</span><br><span class="line">600 - semibold</span><br><span class="line">700 - bold</span><br><span class="line">900 - heavy</span><br></pre></td></tr></table></figure>


<h1 id="思源黑体"><a href="#思源黑体" class="headerlink" title="思源黑体"></a>思源黑体</h1><p><strong>OTF 语言</strong><br>ZIP : 日语・七个 otf 文件对应七个字重・Language Specific OTFs J・Source Han Sans<br>ZIP : 韩语・七个 otf 文件对应七个字重・Language Specific OTFs K・Source Han Sans K<br>ZIP : 简中・七个 otf 文件对应七个字重・Language Specific OTFs S・Source Han Sans SC<br>ZIP : 台中・七个 otf 文件对应七个字重・Language Specific OTFs T・Source Han Sans TC<br>ZIP : 港中・七个 otf 文件对应七个字重・Language Specific OTFs T・Source Han Sans HC</p>
<p><strong>OTF 语言</strong>（HW）<br>ZIP : 日语・七个 otf 文件对应七个字重・Language Specific OTFs J HW・Source Han Sans HW<br>ZIP : 韩语・七个 otf 文件对应七个字重・Language Specific OTFs K HW・Source Han Sans K HW<br>ZIP : 简中・七个 otf 文件对应七个字重・Language Specific OTFs S HW・Source Han Sans SC HW<br>ZIP : 台中・七个 otf 文件对应七个字重・Language Specific OTFs T HW・Source Han Sans TC HW<br>ZIP : 港中・七个 otf 文件对应七个字重・Language Specific OTFs T HW・Source Han Sans HC HW</p>
<p><strong>OTF 地区</strong><br>ZIP : 日本・七个 otf 文件对应七个字重・Region Specific Subset OTFs JP・Source Han Sans JP<br>ZIP : 韩国・七个 otf 文件对应七个字重・Region Specific Subset OTFs KR・Source Han Sans KR<br>ZIP : 大陆・七个 otf 文件对应七个字重・Region Specific Subset OTFs CN・Source Han Sans CN<br>ZIP : 台湾・七个 otf 文件对应七个字重・Region Specific Subset OTFs TW・Source Han Sans TW<br>ZIP : 香港・七个 otf 文件对应七个字重・Region Specific Subset OTFs HK・Source Han Sans HK</p>
<p><strong>OTF 语言</strong>（上述文件的归档包）<br>ZIP : All Static Language Specific OTFs</p>
<p><strong>OTF 地区</strong>（上述文件的归档包）<br>ZIP : All Static Region Specific Subset OTFs</p>
<p><strong>OTC 版本</strong><br>ZIP : 全部・七个 ttc 文件对应七个字重・All Static Language Specific OTCs・Source Han Sans</p>
<p><strong>SuperOTC 版本</strong><br>ZIP : 全部・一个 ttc 文件包含所有字重・Static Super OTC・Source Han Sans</p>
<p><strong>All Variable Fonts</strong> (OTF, TTF, OTC, WOFF2)</p>
<ul>
<li>OTF<ul>
<li>OTF 语言（五个 otf 文件对应五种字形）</li>
<li>OTF 地区（五个 otf 文件对应五种字形）</li>
<li>OTF 等宽（五个 otf 文件对应五种字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 语言（五个 ttf 文件对应五种字形）</li>
<li>TTF 地区（五个 ttf 文件对应五种字形）</li>
<li>TTF 等宽（五个 ttf 文件对应五种字形）</li>
</ul>
</li>
<li>OTC<ul>
<li>一个 otf.ttc 文件（上面 OTF 语言的合集）</li>
<li>一个 ttf.ttc 文件（上面 TTF 语言的合集）</li>
<li>一个 otf.ttc 文件（上面 OTF 等宽的合集）</li>
<li>一个 ttf.ttc 文件（上面 TTF 等宽的合集）</li>
</ul>
</li>
<li>WOFF2<ul>
<li>OTF<ul>
<li>OTF 语言（五个 otf.woff2 文件对应五种字形）</li>
<li>OTF 地区（五个 otf.woff2 文件对应五种字形）</li>
<li>OTF 等宽（五个 otf.woff2 文件对应五种字形）</li>
</ul>
</li>
<li>TTF<ul>
<li>TTF 语言（五个 ttf.woff2 文件对应五种字形）</li>
<li>TTF 地区（五个 ttf.woff2 文件对应五种字形）</li>
<li>TTF 等宽（五个 ttf.woff2 文件对应五种字形）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>思源黑体的七个字重：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 - extralight</span><br><span class="line">300 - light</span><br><span class="line">    - normal</span><br><span class="line">400 - regular</span><br><span class="line">500 - medium</span><br><span class="line">700 - bold</span><br><span class="line">900 - heavy</span><br></pre></td></tr></table></figure>


<h1 id="标准字重"><a href="#标准字重" class="headerlink" title="标准字重"></a>标准字重</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 - Thin</span><br><span class="line">200 - Extra Light</span><br><span class="line">300 - Light</span><br><span class="line">400 - Semi Light (Normal)</span><br><span class="line">500 - Medium</span><br><span class="line">600 - Semi Bold</span><br><span class="line">700 - Bold</span><br><span class="line">800 - Extra Bold</span><br><span class="line">900 - Heavy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言文字</category>
      </categories>
      <tags>
        <tag>思源字体</tag>
      </tags>
  </entry>
  <entry>
    <title>网页字体使用指南</title>
    <url>/sulfurandcu.io/clnyhr2mj002210rq74hmcdni.html</url>
    <content><![CDATA[<p>在被 fontmin 和 font-spider 虐得体无完肤后，我决定试试<a href="https://hsingko.github.io/post/compress_webfont/">这篇文章</a>中提到的另一个字体压缩工具：</p>
<p><strong><center>“<a href="https://github.com/fonttools/fonttools">fonttools</a>”</center></strong></p>
<span id="more"></span>

<h3 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h3><ol start="0">
<li>使用安全字体</li>
<li>使用压缩字体</li>
<li>谷歌字体接口（google fonts api）</li>
</ol>
<p>大多数网站的中文字体使用的都是安全字体，也就是机器中原生携带的字体，这样的好处是无需通过网络传输字体文件，也就不存在加载过慢的问题。安全字体好用是好用，但是架不住它丑啊，否则我也不会捯饬字体压缩了不是！置于谷歌字体接口嘛，你懂的。</p>
<h3 id="为啥压缩"><a href="#为啥压缩" class="headerlink" title="为啥压缩"></a>为啥压缩</h3><p>这里的字体指的是汉字（泛中日韩）字体，拉丁字符或者西里尔字符这种字符数量较少的字体的体积通常比较小，没有压缩的必要。汉字字体通常收录几千上万个字符，大小能达到几十兆字节，而常用的汉字不过两三千，聚焦至单篇文章中可能连一千都不到。倘若每次加载网页时都要将完整的字体文件下载下来，其加载时间是往往是难以忍受的，这样我们就要想法子缩减字体文件的体积。巧的是，字体压缩就是干这个的。</p>
<h3 id="静态压缩"><a href="#静态压缩" class="headerlink" title="静态压缩"></a>静态压缩</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyftsubset font.ttf --text=$(cat hanzi.txt) --no-hinting</span><br></pre></td></tr></table></figure>

<p>静态压缩：无法保证文章中不会用到常用字表以外的字。</p>
<h3 id="动态压缩"><a href="#动态压缩" class="headerlink" title="动态压缩"></a>动态压缩</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyftsubset ../font/SourceHanSerifSC-Regular.otf --text=$(rg -e &#x27;[\u&#123;0100&#125;-\u&#123;10ffff&#125;]&#x27; -oN --no-filename|sort|uniq|tr -d &#x27;\n&#x27;) --no-hinting</span><br></pre></td></tr></table></figure>

<p>动态压缩：每次更新文章后都要执行一次字体压缩流程。</p>
]]></content>
      <categories>
        <category>语言文字</category>
      </categories>
      <tags>
        <tag>网页字体</tag>
      </tags>
  </entry>
  <entry>
    <title>张三同志姓名字号</title>
    <url>/sulfurandcu.io/clnyhr2mi001u10rq4248hyf0.html</url>
    <content><![CDATA[<center>张三，姓张名弎，字斯岸，号弋山道人，早年曾任刑部侍郎，人称司案先生。</center>
<br>
]]></content>
      <categories>
        <category>白银时代</category>
      </categories>
  </entry>
  <entry>
    <title>二〇二一拼音漫游</title>
    <url>/sulfurandcu.io/clnyhr2mh001m10rq3qr434d7.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clnyhr2mh001m10rq3qr434d7/2021.A.bopomofo.Odyssey.png"></p>
]]></content>
      <categories>
        <category>语言文字</category>
      </categories>
      <tags>
        <tag>汉语拼音</tag>
        <tag>注音符号</tag>
      </tags>
  </entry>
  <entry>
    <title>dƷvorak</title>
    <url>/sulfurandcu.io/clnyhr2mk002410rq6z6893sz.html</url>
    <content><![CDATA[<p><strong><center>The <a href="https://github.com/sulfurandcu/d3vorak">dƷvorak</a> keyboard layout has been released !</center></strong></p>
<br>

<p style="font-family:courier new">
　　　　　　　　1　　2　　3　　4　　5　　6　　7　　8　　9　　0　　[　　]　　 　　　　　　　<br>
　　　　　　　　;　　,　　.　　y　　w　　r　　k　　d　　l　　c　　/　　=　　\　　　　　　　<br>
　　　　　　　　a　　o　　e　　i　　u　　g　　h　　t　　n　　s　　-　　 　　 　　　　　　　<br>
　　　　　　　　'　　q　　x　　j　　v　　b　　f　　m　　p　　z　　 　　 　　 　　　　　　　<br>
</p>

<span id="more"></span>

<br>
]]></content>
      <categories>
        <category>输入方案</category>
      </categories>
      <tags>
        <tag>键位布局</tag>
        <tag>qwerty</tag>
        <tag>dvorak</tag>
        <tag>dƷvorak</tag>
      </tags>
  </entry>
  <entry>
    <title>没事儿也来做做题</title>
    <url>/sulfurandcu.io/clnyhr2mo002m10rq48l66wah.html</url>
    <content><![CDATA[<center><a href="http://sdoi.programming-rabbit.com/">http://sdoi.programming-rabbit.com/</a></center>

<span id="more"></span>

<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>张三和李四在玩一种游戏。</p>
<p>首先，张三从 A 与 B 之间（包括A和B）选择一个整数，告诉李四。</p>
<p>其次，李四从 C 与 D 之间（包括C和D）选择一个整数。</p>
<p>两个整数之和，如果是素数，张三赢，否则李四赢。</p>
<p>当两个人都是最佳发挥时，谁会赢？</p>
<p><strong>输入格式：</strong><br>一行四个正整数 A B C D 以空格隔开。</p>
<p><strong>输入格式：</strong><br>如果张三赢了，输出 X，否则输出 Y。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool IsPrimeNumber(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if (n &lt; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int SquareRoot = 1;</span><br><span class="line"></span><br><span class="line">	while (SquareRoot * SquareRoot &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		SquareRoot++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 2; i &lt;= SquareRoot; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (n % i == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int a = 0;</span><br><span class="line">	int b = 0;</span><br><span class="line">	int c = 0;</span><br><span class="line">	int d = 0;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j = 0;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	int x_win = 0;</span><br><span class="line">	int y_win = 0;</span><br><span class="line">	bool PrimeExist = false;</span><br><span class="line"></span><br><span class="line">	int usec_bgn;</span><br><span class="line">	int usec_end;</span><br><span class="line">	int usec_sub;</span><br><span class="line">	struct timeval tv;</span><br><span class="line"></span><br><span class="line">	/* 等待输入 */</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">	// a = 1; b = 100; c = 2; d = 3;</span><br><span class="line"></span><br><span class="line">	/* 参数判断 */</span><br><span class="line">	if (a &lt;= 0 || a &gt; 100 || b &lt;= 0 || b &gt; 100 || c &lt;= 0 || c &gt; 100 || d &lt;= 0 || d &gt; 100)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error input! a, b, c, d should be greater than zero and less than or equal to 100! \r\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 参数判断 */</span><br><span class="line">	if (a &gt; b || c &gt; d)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error input! b is bigger than a!\r\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 参数判断 */</span><br><span class="line">	if (c &gt; d)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error input! d is bigger than c!\r\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// printf(&quot;%d,%d,%d,%d\r\n&quot;, a, b, c, d);</span><br><span class="line"></span><br><span class="line">	/* 起始时间 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_bgn = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;bgn time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 胜负推演 */</span><br><span class="line">	for (i = a; i &lt;= b; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		PrimeExist = false;</span><br><span class="line"></span><br><span class="line">		for (j = c; j &lt;= d; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = i + j;</span><br><span class="line"></span><br><span class="line">			if (IsPrimeNumber(sum))</span><br><span class="line">			&#123;</span><br><span class="line">				PrimeExist = true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (PrimeExist)</span><br><span class="line">		&#123;</span><br><span class="line">			y_win++;</span><br><span class="line"></span><br><span class="line">			#if 1 /* 如果不想显示中间过程，可以屏蔽下行（将 #if 1 改为 #if 0） */</span><br><span class="line">			printf(&quot;X = %d\tY = %d\tSUM  = %d \tY WIN !\r\n&quot;, i, j, sum);</span><br><span class="line">			#endif</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			x_win++;</span><br><span class="line"></span><br><span class="line">			#if 1 /* 如果不想显示中间过程，可以屏蔽下行（将 #if 1 改为 #if 0） */</span><br><span class="line">			printf(&quot;X = %d\tY =  \tSUM != Prime \tX WIN !\r\n&quot;, i);</span><br><span class="line">			#endif</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 比较小X和小Y总的胜负次数 */</span><br><span class="line">	if (x_win &gt; y_win)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;X WIN TIMES = %d, Y WIN TIMES = %d, SO X WINS FINALLY !\r\n&quot;, x_win, y_win);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	if (x_win &lt; y_win)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;X WIN TIMES = %d, Y WIN TIMES = %d, SO Y WINS FINALLY !\r\n&quot;, x_win, y_win);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;X WIN TIMES = %d, Y WIN TIMES = %d, DRAWN GAME !\r\n&quot;, x_win, y_win);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 结束时间 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_end = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;end time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 计算耗时 */</span><br><span class="line">	if (usec_end &gt;= usec_bgn)</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = usec_end - usec_bgn;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = 1000000 - (usec_bgn - usec_end);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;time cost :%d us\r\n&quot;, usec_sub);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试记录"><a href="#测试记录" class="headerlink" title="测试记录"></a>测试记录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编译环境 windows subsystem for linux (wsl) &amp; gcc/g++ v9.3.0</span><br><span class="line"></span><br><span class="line">user@localhost:/mnt/e/gcc$ g++ main.cpp -o main.cppout</span><br><span class="line">user@localhost:/mnt/e/gcc$ ./main.cppout</span><br><span class="line">1 100 2 3</span><br><span class="line"></span><br><span class="line">bgn time (second, micro-second): 1656168565s, 669332us</span><br><span class="line"></span><br><span class="line">X = 1   Y = 2   SUM  = 3        Y WIN !</span><br><span class="line">X = 2   Y = 3   SUM  = 5        Y WIN !</span><br><span class="line">X = 3   Y = 2   SUM  = 5        Y WIN !</span><br><span class="line">X = 4   Y = 3   SUM  = 7        Y WIN !</span><br><span class="line">X = 5   Y = 2   SUM  = 7        Y WIN !</span><br><span class="line">X = 6   Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 7   Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 8   Y = 3   SUM  = 11       Y WIN !</span><br><span class="line">X = 9   Y = 2   SUM  = 11       Y WIN !</span><br><span class="line">X = 10  Y = 3   SUM  = 13       Y WIN !</span><br><span class="line">X = 11  Y = 2   SUM  = 13       Y WIN !</span><br><span class="line">X = 12  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 13  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 14  Y = 3   SUM  = 17       Y WIN !</span><br><span class="line">X = 15  Y = 2   SUM  = 17       Y WIN !</span><br><span class="line">X = 16  Y = 3   SUM  = 19       Y WIN !</span><br><span class="line">X = 17  Y = 2   SUM  = 19       Y WIN !</span><br><span class="line">X = 18  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 19  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 20  Y = 3   SUM  = 23       Y WIN !</span><br><span class="line">X = 21  Y = 2   SUM  = 23       Y WIN !</span><br><span class="line">X = 22  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 23  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 24  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 25  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 26  Y = 3   SUM  = 29       Y WIN !</span><br><span class="line">X = 27  Y = 2   SUM  = 29       Y WIN !</span><br><span class="line">X = 28  Y = 3   SUM  = 31       Y WIN !</span><br><span class="line">X = 29  Y = 2   SUM  = 31       Y WIN !</span><br><span class="line">X = 30  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 31  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 32  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 33  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 34  Y = 3   SUM  = 37       Y WIN !</span><br><span class="line">X = 35  Y = 2   SUM  = 37       Y WIN !</span><br><span class="line">X = 36  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 37  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 38  Y = 3   SUM  = 41       Y WIN !</span><br><span class="line">X = 39  Y = 2   SUM  = 41       Y WIN !</span><br><span class="line">X = 40  Y = 3   SUM  = 43       Y WIN !</span><br><span class="line">X = 41  Y = 2   SUM  = 43       Y WIN !</span><br><span class="line">X = 42  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 43  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 44  Y = 3   SUM  = 47       Y WIN !</span><br><span class="line">X = 45  Y = 2   SUM  = 47       Y WIN !</span><br><span class="line">X = 46  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 47  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 48  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 49  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 50  Y = 3   SUM  = 53       Y WIN !</span><br><span class="line">X = 51  Y = 2   SUM  = 53       Y WIN !</span><br><span class="line">X = 52  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 53  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 54  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 55  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 56  Y = 3   SUM  = 59       Y WIN !</span><br><span class="line">X = 57  Y = 2   SUM  = 59       Y WIN !</span><br><span class="line">X = 58  Y = 3   SUM  = 61       Y WIN !</span><br><span class="line">X = 59  Y = 2   SUM  = 61       Y WIN !</span><br><span class="line">X = 60  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 61  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 62  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 63  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 64  Y = 3   SUM  = 67       Y WIN !</span><br><span class="line">X = 65  Y = 2   SUM  = 67       Y WIN !</span><br><span class="line">X = 66  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 67  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 68  Y = 3   SUM  = 71       Y WIN !</span><br><span class="line">X = 69  Y = 2   SUM  = 71       Y WIN !</span><br><span class="line">X = 70  Y = 3   SUM  = 73       Y WIN !</span><br><span class="line">X = 71  Y = 2   SUM  = 73       Y WIN !</span><br><span class="line">X = 72  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 73  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 74  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 75  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 76  Y = 3   SUM  = 79       Y WIN !</span><br><span class="line">X = 77  Y = 2   SUM  = 79       Y WIN !</span><br><span class="line">X = 78  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 79  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 80  Y = 3   SUM  = 83       Y WIN !</span><br><span class="line">X = 81  Y = 2   SUM  = 83       Y WIN !</span><br><span class="line">X = 82  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 83  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 84  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 85  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 86  Y = 3   SUM  = 89       Y WIN !</span><br><span class="line">X = 87  Y = 2   SUM  = 89       Y WIN !</span><br><span class="line">X = 88  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 89  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 90  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 91  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 92  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 93  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 94  Y = 3   SUM  = 97       Y WIN !</span><br><span class="line">X = 95  Y = 2   SUM  = 97       Y WIN !</span><br><span class="line">X = 96  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 97  Y =     SUM != Prime    X WIN !</span><br><span class="line">X = 98  Y = 3   SUM  = 101      Y WIN !</span><br><span class="line">X = 99  Y = 2   SUM  = 101      Y WIN !</span><br><span class="line">X = 100 Y = 3   SUM  = 103      Y WIN !</span><br><span class="line"></span><br><span class="line">X WIN TIMES = 50, Y WIN TIMES = 50, DRAWN GAME !</span><br><span class="line"></span><br><span class="line">end time (second, micro-second): 1656168565s, 670078us</span><br><span class="line"></span><br><span class="line">time cost :746 us</span><br><span class="line"></span><br><span class="line">user@localhost:/mnt/e/gcc$</span><br></pre></td></tr></table></figure>

<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>张三成为了一家餐厅的采购员。作为一个采购员要有良好的职业素养。必须保证每次采购的物资不超过自己车辆的容量，然后在此条件下使得餐厅赚取的收益最大。</p>
<p>商场中共有 n 种物资，编号为 1 到 n 。每种物资都有两个参数 v 和 w，分别表示这种物资的体积和采购这种物资可以给餐厅带来的收益。注意每种物资每天至多只能采购一件。</p>
<p>张三有一辆容量为 V 的采购车，每天张三只去采购一次，采购的物资体积之和不能超过车辆的容量。</p>
<p>对于每天采购的物资，餐厅老板还有特殊的要求，第 i 天老板要求张三不能采购编号大于等于 Li 并且小于等于 Ri 的物资（即不能采购编号在 [Li,Ri] 之间的物资）。特别的，当 Li&gt;Ri 时表示这天没有不可采购的物资。</p>
<p>对于接下来的 m 天，你需要告诉张三他每天分别最多可以给餐厅赚取多少的收益。</p>
<p><strong>输入格式：</strong><br>输入第一行两个个整数 n, V 表示共有 n 种物资，张三的车子容量是 V。<br>接下来 n 行，每行两个整数。<br>第 i+1 行输入vi, wi 表示第 i 种物资的体积和收益。<br>接下来一行输入一个整数 m ，表示需要采购的天数。<br>接下来 m 行，每行输入两个整数 Li, Ri 表示第 i 天不能采购编号位于 Li 到 Ri 之间的物资。</p>
<p><strong>输出格式：</strong><br>输出共 m 行，每行一个整数表示张三第 i 天可以给餐厅带来的收益。</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6   290     物资种类，容量</span><br><span class="line">85  97      1号体积，收益</span><br><span class="line">80  81      2号体积，收益</span><br><span class="line">83  1       3号体积，收益</span><br><span class="line">79  81      4号体积，收益</span><br><span class="line">89  1       5号体积，收益</span><br><span class="line">92  97      6号体积，收益</span><br><span class="line">5           天数</span><br><span class="line">3   5       Li-Ri</span><br><span class="line">1   1</span><br><span class="line">1   3</span><br><span class="line">5   2</span><br><span class="line">3   1</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">275</span><br><span class="line">259</span><br><span class="line">179</span><br><span class="line">275</span><br><span class="line">275</span><br></pre></td></tr></table></figure>

<p><strong>补充说明：</strong><br>前 20% 的数据满足: 1&lt;&#x3D;n&lt;&#x3D;10,1&lt;&#x3D;m&lt;&#x3D;1000.<br>前 50% 的数据满足: 1&lt;&#x3D;n, m, V&lt;&#x3D;300.<br>对于 100% 的数据满足: 1&lt;&#x3D;n, m, V&lt;&#x3D;3000; 1&lt;&#x3D;vi&lt;&#x3D;3000; 1&lt;&#x3D;Li, Ri&lt;&#x3D;n; 1&lt;&#x3D;wi&lt;&#x3D;10^6.</p>
<p><strong>时间限制：</strong>1s</p>
<p><strong>空间限制：</strong>512M</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int daytotal;                       // 天数</span><br><span class="line">	int category;                       // 种类</span><br><span class="line">	int capacity;                       // 容量</span><br><span class="line">	int capacity_left;                  // 容量（剩余）</span><br><span class="line">	int edge[3001][2];                  // 边界条件</span><br><span class="line">	int menu[3001][2];                  // 货单</span><br><span class="line">	int menu_sort[3001][3];             // 货单（根据每件货物的收益率排序）</span><br><span class="line">	int idx = 0;</span><br><span class="line">	int sum = 0;                        // 收益</span><br><span class="line">	double rate_max = 0;                // 收益率</span><br><span class="line">	double rate_tmp = 0;                // 收益率</span><br><span class="line"></span><br><span class="line">	int usec_bgn;</span><br><span class="line">	int usec_end;</span><br><span class="line">	int usec_sub;</span><br><span class="line">	struct timeval tv;</span><br><span class="line"></span><br><span class="line">	#if 0</span><br><span class="line">	cin&gt;&gt;category&gt;&gt;capacity;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; category; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;menu[i][0]&gt;&gt;menu[i][1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;daytotal;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; daytotal; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;edge[i][0]&gt;&gt;edge[i][1];</span><br><span class="line">	&#125;</span><br><span class="line">	#else</span><br><span class="line">	category = 10;</span><br><span class="line">	capacity = 300;</span><br><span class="line">	menu[0][0] = 85; menu[0][1] = 97;</span><br><span class="line">	menu[1][0] = 80; menu[1][1] = 81;</span><br><span class="line">	menu[2][0] = 83; menu[2][1] = 1;</span><br><span class="line">	menu[3][0] = 79; menu[3][1] = 81;</span><br><span class="line">	menu[4][0] = 89; menu[4][1] = 1;</span><br><span class="line">	menu[5][0] = 92; menu[5][1] = 97;</span><br><span class="line">	daytotal = 10;</span><br><span class="line">	edge[0][0] = 3; edge[0][1] = 5;</span><br><span class="line">	edge[1][0] = 1; edge[1][1] = 1;</span><br><span class="line">	edge[2][0] = 1; edge[2][1] = 3;</span><br><span class="line">	edge[3][0] = 5; edge[3][1] = 2;</span><br><span class="line">	edge[4][0] = 3; edge[4][1] = 1;</span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">	/* 起始时间 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_bgn = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;bgn time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	for (int j = 0; j &lt; category; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		idx = 0;</span><br><span class="line">		rate_max = 0;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; category; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			if (menu[i][0] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rate_tmp = (double)menu[i][1] / (double)menu[i][0];</span><br><span class="line"></span><br><span class="line">			if (rate_tmp &gt; rate_max)</span><br><span class="line">			&#123;</span><br><span class="line">				rate_max = rate_tmp;</span><br><span class="line">				idx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		menu_sort[j][0] = menu[idx][0];</span><br><span class="line">		menu_sort[j][1] = menu[idx][1];</span><br><span class="line">		menu_sort[j][2] = idx;</span><br><span class="line">		menu[idx][0] = 0;</span><br><span class="line">		menu[idx][1] = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int day_idx = 0; day_idx &lt; daytotal; ++day_idx) /* 第n天 */</span><br><span class="line">	&#123;</span><br><span class="line">		sum = 0;</span><br><span class="line">		capacity_left = capacity;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; category; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			if ((menu_sort[i][2]+1) &gt;= edge[day_idx][0] &amp;&amp; (menu_sort[i][2]+1) &lt;= edge[day_idx][1])</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (capacity_left &gt;= menu_sort[i][0])</span><br><span class="line">			&#123;</span><br><span class="line">				capacity_left -= menu_sort[i][0];</span><br><span class="line">				sum += menu_sort[i][1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\r\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 结束时间 */</span><br><span class="line">	gettimeofday(&amp;tv, NULL);</span><br><span class="line">	usec_end = (int)tv.tv_usec;</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line">	printf(&quot;end time (second, micro-second): %ds, %dus\r\n&quot;, (int)tv.tv_sec, (int)tv.tv_usec);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	/* 计算耗时 */</span><br><span class="line">	if (usec_end &gt;= usec_bgn)</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = usec_end - usec_bgn;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		usec_sub = 1000000 - (usec_bgn - usec_end);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;time cost :%d us\r\n&quot;, usec_sub);</span><br><span class="line">	printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试记录-1"><a href="#测试记录-1" class="headerlink" title="测试记录"></a>测试记录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@localhost:/mnt/e/gcc$ g++ main.cpp -o main.cppout</span><br><span class="line">user@localhost:/mnt/e/gcc$ ./main.cppout</span><br><span class="line"></span><br><span class="line">bgn time (second, micro-second): 1656593986s, 560594us</span><br><span class="line"></span><br><span class="line">275</span><br><span class="line">259</span><br><span class="line">179</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line">275</span><br><span class="line"></span><br><span class="line">end time (second, micro-second): 1656593986s, 560641us</span><br><span class="line"></span><br><span class="line">time cost :47 us</span><br><span class="line"></span><br><span class="line">user@localhost:/mnt/e/gcc$</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>dƷvorak&#39;s impl.</title>
    <url>/sulfurandcu.io/cm03lc8mx006fdgrq688r2y8i.html</url>
    <content><![CDATA[<p style="font-family:courier new">
　　　　　　　　!　　@　　#　　$　　%　　^　　&　　*　　(　　)　　{　　}　　 　　　　　　　<br>
　　　　　　　　:　　<　　>　　W　　Y　　K　　R　　D　　L　　C　　?　　+　　|　　　　　　　<br>
　　　　　　　　A　　O　　E　　I　　U　　G　　H　　T　　N　　S　　_　　 　　 　　　　　　　<br>
　　　　　　　　"　　Q　　X　　J　　B　　F　　M　　P　　V　　Z　　 　　 　　 　　　　　　　<br>
</p>

<span id="more"></span>

<h4 id="布局由来"><a href="#布局由来" class="headerlink" title="布局由来"></a>布局由来</h4><p>不论是 dvorak 还是 colemak 布局，都是为拉丁字母设计的，中文输入大家见仁见智。我自己是用了俩月就基本放弃了，后来索性自己设计了一个，还起了个高仿的名字，唤作「dƷvorak」。当时设计该布局的初衷是为了提高拼音输入的舒适度，而不是输入速度，毕竟我们大多都不是靠打字速度谋生的。设计之初难免有考虑不周之处，各位看官如有好的想法，欢迎补充。<a href="https://github.com/sulfurandcu/d3vorak">😎</a></p>
<h4 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h4><p>由于穷的缘故，起初我是用软件方式实现的。映射工具从最初的 remapkey 到 msklc 再到 ahk，每一种都或多或少存在着不足之处，不过组合起来倒也还能凑合着用，虽然使用起来仍有诸多不便，不过这也是当时我能找到的最好的方法了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 使用 remapkey.exe 对控制键进行映射。</span><br><span class="line">- 使用 msklc.exe 制作键盘布局。（这里的键盘指的是 windows 系统中输入法的键盘）</span><br><span class="line">- 使用 AutoHotkey 定义快捷键。</span><br></pre></td></tr></table></figure>
<p>我愉快地使用了一段时间，直到开始接触 linux 操作系统和虚拟机，繁琐的配置令我难以忍受，也就是在那时，我开始寻求新的解决方案。补充：软件层面的映射在部分游戏中不起作用。</p>
<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>更换平台会带来一系列问题，继续使用软件映射的方式很有可能会把我逼疯，为了避免这种事情发生，最终我决定自己做一个机械键盘出来。</p>
<p><strong>我的需求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 能够在多个布局之间无缝切换，因为玩游戏时还是得用 qwerty 布局。😅</span><br><span class="line">- 快捷键方便使用。这一点至关重要，快捷键问题得不到有效解决是众多 dvorak 使用者放弃的主要原因。</span><br></pre></td></tr></table></figure>

<p><strong>最终效果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 全键可编程（所有键位可以任意排序）</span><br><span class="line">- 共八层逻辑（每层均可放置一个布局）</span><br><span class="line">- 组合快捷键（可以自定义组合快捷键）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 第０层：自定义布局（包括一个瞬时开启第１层的按键：FN1）</span><br><span class="line">- 第１层：快捷功能层（包括一个瞬时开启第２层的按键：FN2）</span><br><span class="line">- 第２层：中间管理层（包括一组固定开启第３/４/５/６/７层的按键：FN21/FN22/FN23/FN30/FN31）</span><br><span class="line">- 第３层：自定义布局</span><br><span class="line">- 第４层：自定义布局</span><br><span class="line">- 第５层：自定义布局</span><br><span class="line">- 第６层：自定义布局</span><br><span class="line">- 第７层：自定义布局</span><br></pre></td></tr></table></figure>

<p><strong>制作工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键盘配列制作 : http://www.keyboard-layout-editor.com/</span><br><span class="line">键表文件生成 : https://tkg.io/</span><br><span class="line">程序在线烧录 : https://tkg.io/</span><br><span class="line">程序离线烧录 : https://github.com/kairyu/tkg-toolkit</span><br></pre></td></tr></table></figure>

<p>使用 keyboard-layout-editor 设计键位布局并制作键盘配列（最多八层），然后将各层的 raw data 拷贝到 tkg.io 中，在 tkg.io 中设置层快捷键和组合快捷键，设置快捷键的前提是要在键盘配列中先设计一个功能键（该功能可选），最后将数据烧录至键盘，可以使用 chrome 浏览器插件在线烧录，也可以生成源码后用 tkg-toolkit 离线烧录。</p>
<h4 id="利弊分析"><a href="#利弊分析" class="headerlink" title="利弊分析"></a>利弊分析</h4><p>软件方式的经济成本很低，时间成本较高，每换一台计算机就需要重新配置。<br>硬件方式的经济成本较高，时间成本较低，做好之后即插即用但是不便携带。</p>
]]></content>
      <categories>
        <category>输入方案</category>
      </categories>
      <tags>
        <tag>键位布局</tag>
        <tag>qwerty</tag>
        <tag>dvorak</tag>
        <tag>dƷvorak</tag>
        <tag>机械键盘</tag>
      </tags>
  </entry>
  <entry>
    <title>常用通信协议总结</title>
    <url>/sulfurandcu.io/cls9pzmt800gg5srq5pxrhjvk.html</url>
    <content><![CDATA[<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><blockquote>
<p>there is no spec for spi, so some of this definition is a little bit loose.</p>
<p>quote from <a href="https://www.youtube.com/watch?v=MCi7dCBhVpQ">spi: the serial peripheral interface</a> by <a href="https://eater.net/">ben eater</a></p>
</blockquote>
<p><img src="/sulfurandcu.io/cls9pzmt800gg5srq5pxrhjvk/spi_cpol=n_cpha=n.svg"></p>
<center>↑　cpol = x　cpha = x</center><br>

<p><img src="/sulfurandcu.io/cls9pzmt800gg5srq5pxrhjvk/spi_cpol=0_cpha=0.svg"></p>
<center>↑　cpol = 0　cpha = 0</center><br>

<p><img src="/sulfurandcu.io/cls9pzmt800gg5srq5pxrhjvk/spi_cpol=0_cpha=1.svg"></p>
<center>↑　cpol = 0　cpha = 1</center><br>

<p><img src="/sulfurandcu.io/cls9pzmt800gg5srq5pxrhjvk/spi_cpol=1_cpha=0.svg"></p>
<center>↑　cpol = 1　cpha = 0</center><br>

<p><img src="/sulfurandcu.io/cls9pzmt800gg5srq5pxrhjvk/spi_cpol=1_cpha=1.svg"></p>
<center>↑　cpol = 1　cpha = 1</center><br>

<!--
cpol = 0
cpha = 0

{ signal:
  [
    {name: 'csb',  wave: '10................1'},
    {},
    {name: 'sck',  wave: 'l.HlHlHlHlHlHlHlHl.'},
    {},
    {name: 'mosi', wave: 'x2.2.2.2.2.2.2.2.x.'},
    {},
    {name: 'miso', wave: 'x2.2.2.2.2.2.2.2.x.'},
  ],
}

cpol = 0
cpha = 1

{ signal:
  [
    {name: 'csb',  wave: '10................1'},
    {},
    {name: 'sck',  wave: 'l.hLhLhLhLhLhLhLhL.'},
    {},
    {name: 'mosi', wave: 'xx2.2.2.2.2.2.2.2.x'},
    {},
    {name: 'miso', wave: 'xx2.2.2.2.2.2.2.2.x'},
  ],
}

cpol = 1
cpha = 0

{ signal:
  [
    {name: 'csb',  wave: '10................1'},
    {},
    {name: 'sck',  wave: 'h.LhLhLhLhLhLhLhLh.'},
    {},
    {name: 'mosi', wave: 'x2.2.2.2.2.2.2.2.x.'},
    {},
    {name: 'miso', wave: 'x2.2.2.2.2.2.2.2.x.'},
  ],
}

cpol = 1
cpha = 1

{ signal:
  [
    {name: 'csb',  wave: '10................1'},
    {},
    {name: 'sck',  wave: 'h.lHlHlHlHlHlHlHlH.'},
    {},
    {name: 'mosi', wave: 'x.2.2.2.2.2.2.2.2.x'},
    {},
    {name: 'miso', wave: 'x.2.2.2.2.2.2.2.2.x'},
  ],
}

cpol = x
cpha = x

{ signal:
  [
    {name: 'csb', wave: '10................1'},

    {name: '', wave: '2.', data: 'cpol=0'},
    {name: 'sck', wave: 'l.hlhlhlhlhlhlhlhl.'},
    {name: 'sck', wave: 'h.lhlhlhlhlhlhlhlh.'},
    {name: '', wave: '2.', data: 'cpol=1'},

    {name: '', wave: 'x2...............x.', data: ['cpha=0']},

    {name: 'mosi', wave: 'x2.2.2.2.2.2.2.2.x.'},
    {name: 'miso', wave: 'x2.2.2.2.2.2.2.2.x.'},

    {},

    {name: '', wave: 'x.2...............x', data: ['cpha=1']},

    {name: 'mosi', wave: 'x.2.2.2.2.2.2.2.2.x'},
    {name: 'miso', wave: 'x.2.2.2.2.2.2.2.2.x'},
  ]
}
-->
]]></content>
  </entry>
  <entry>
    <title>亿枝红杏儿出墙来</title>
    <url>/sulfurandcu.io/clnyhr2mm002g10rqgzfk3qms.html</url>
    <content><![CDATA[<center><a href="https://www.v2ray.com/awesome/tools.html">神一样的工具们</a></center>
<center><a href="https://shadowsocks.org/en/index.html">https://shadowsocks.org/en/index.html</a></center>

<span id="more"></span>

<h3 id="真香定律"><a href="#真香定律" class="headerlink" title="真香定律"></a>真香定律</h3><p>更新（2021-05-05）</p>
<p>技术无时无刻不在发展，各种代理方案如雨后春笋般冒出来。新技术虽然一个比一个强大，但是配置起来也确实麻烦，咱毕竟不是专业玩家，日常使用更应注重方便快捷。</p>
<p>最近同事给推荐了一个代理软件 <a href="https://github.com/Fndroid/clash_for_windows_pkg">clash4windows</a> 还不错，搭配各路机场，比 <a href="https://github.com/2dust/v2rayN">V2rayN</a> 要好用不少。</p>
<p><a href="https://github.com/Dreamacro/clash/wiki/configuration">官方出品Clash配置文件</a><br><a href="https://v2raytech.com/deep-in-clash-config-file/">深入理解Clash配置文件</a></p>
<h3 id="后起之秀"><a href="#后起之秀" class="headerlink" title="后起之秀"></a>后起之秀</h3><p>更新（2020-03-15）</p>
<p>由于墙的封锁能力愈来愈强，本文之前所列举的方案已经不再适用，目前本人已弃用 shadowsocks 转投 v2ray 的怀抱。</p>
<p>技术文档：<a href="https://www.v2ray.com/">v2ray site</a><br>技术文档：<a href="https://toutyrater.github.io/">v2ray 白话文教程 - 原版</a><br>技术文档：<a href="https://guide.v2fly.org/">v2ray 白话文教程 - 新版</a></p>
<p><a href="https://guide.v2fly.org/basics/vmess.html#%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90">这里</a>介绍了 v2ray 的工作原理。</p>
<blockquote>
<p>v2ray 可同时开启多个协议支持，包括 http、socks、shadowsocks、vmess 等。每个协议可单独设置传输载体，比如 TCP、mKCP、http&#x2F;2、WebSocket 等。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vmess + TCP + TLS + Web</span><br><span class="line">Vmess + KCP + TLS + Web</span><br><span class="line">Vmess + HTTP/2 + TLS + Web</span><br><span class="line">Vmess + WebSocket + TLS + Web</span><br><span class="line">Vmess + WebSocket + TLS + Web + CDN</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(HTTP)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(shadowsocks)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(VMess)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br><span class="line"></span><br><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(VMess/TLS/TCP)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(VMess/TLS/KCP)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(VMess/h2/TLS/TCP)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br><span class="line">&#123;浏览器&#125; &lt;--(socks)--&gt; &#123;V2Ray 客户端 inbound &lt;-&gt; V2Ray 客户端 outbound&#125; &lt;--(VMess/ws/TLS/TCP)--&gt;  &#123;V2Ray 服务器 inbound &lt;-&gt; V2Ray 服务器 outbound&#125; &lt;--(Freedom)--&gt; &#123;目标网站&#125;</span><br></pre></td></tr></table></figure>

<p>上面所陈列的若干技术文档对实现原理进行了详细说明，不过真要根据上述理论做出一套现实可行的代理方案出来，对于我这种半瓶水玩家来说还是有点难度的，还是老老实实按别人的教程来吧：<a href="http://iqotom.com/?p=1327">Vmess + WebSocket + TLS(domain) + Web(Caddy) + CDN(Cloudflare) 方案复活</a>。</p>
<h3 id="懵懂时期"><a href="#懵懂时期" class="headerlink" title="懵懂时期"></a>懵懂时期</h3><p>以下方案在 2018 年前后尚能对付着用，现在（2020）基本上是一封一个准儿，墙愈来愈高，吾辈还是要跟上时代的步伐呀！</p>
<h4 id="使用-bbr-加速"><a href="#使用-bbr-加速" class="headerlink" title="使用 bbr 加速"></a>使用 bbr 加速</h4><p><strong>安装、设置、重启</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"></span><br><span class="line">sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum --enablerepo=elrepo-kernel install kernel-ml -y</span><br><span class="line"></span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line"></span><br><span class="line">sudo egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \&#x27;</span><br><span class="line"></span><br><span class="line">sudo grub2-set-default 0</span><br><span class="line"></span><br><span class="line">sudo shutdown -r now</span><br></pre></td></tr></table></figure>

<p><strong>重启过后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"></span><br><span class="line">echo &#x27;net.core.default_qdisc=fq&#x27; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">echo &#x27;net.ipv4.tcp_congestion_control=bbr&#x27; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br><span class="line"></span><br><span class="line">sudo sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class="line"></span><br><span class="line">sudo sysctl -n net.ipv4.tcp_congestion_control</span><br><span class="line"></span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p><strong>测试工具｜可选</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install httpd -y</span><br><span class="line">sudo systemctl start httpd.service</span><br><span class="line">sudo firewall-cmd --zone=public --permanent --add-service=http</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line">cd /var/www/html</span><br><span class="line">sudo dd if=/dev/zero of=500mb.zip bs=1024k count=500</span><br><span class="line"></span><br><span class="line">http://[your-server-IP]/500mb.zip</span><br></pre></td></tr></table></figure>

<h4 id="服务端工具之-shadowsocks"><a href="#服务端工具之-shadowsocks" class="headerlink" title="服务端工具之 shadowsocks"></a>服务端工具之 shadowsocks</h4><p><strong>程序安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python get-pip.py</span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line">pip install shadowsocks</span><br><span class="line">pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U</span><br></pre></td></tr></table></figure>

<p><strong>编辑配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置一：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">  &quot;server_port&quot;: 10235,</span><br><span class="line">  &quot;password&quot;: &quot;Pass3ord&quot;,</span><br><span class="line">  &quot;timeout&quot;: 300,</span><br><span class="line">  &quot;method&quot;: &quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置二：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;port_password&quot;: &#123;</span><br><span class="line">        &quot;10236&quot;: &quot;password&quot;,</span><br><span class="line">        &quot;10237&quot;: &quot;password&quot;</span><br><span class="line">        &quot;10238&quot;: &quot;password&quot;</span><br><span class="line">        &quot;10239&quot;: &quot;password&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;: 300,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure>

<h4 id="服务端工具之-shadowsocksR"><a href="#服务端工具之-shadowsocksR" class="headerlink" title="服务端工具之 shadowsocksR"></a>服务端工具之 shadowsocksR</h4><h4 id="服务端工具之-v2ray"><a href="#服务端工具之-v2ray" class="headerlink" title="服务端工具之 v2ray"></a>服务端工具之 v2ray</h4><p><strong>程序安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">yum -y install zip unzip</span><br><span class="line">wget https://install.direct/go.sh</span><br><span class="line">bash go.sh</span><br></pre></td></tr></table></figure>

<p><strong>编辑配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/v2ray/config.json</span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start v2ray</span><br></pre></td></tr></table></figure>

<h4 id="服务端防火墙-firewalld"><a href="#服务端防火墙-firewalld" class="headerlink" title="服务端防火墙 firewalld"></a>服务端防火墙 firewalld</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install firewalld</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=80/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=443/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=10235/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=10245/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<h4 id="客户端工具之-shadowrocket"><a href="#客户端工具之-shadowrocket" class="headerlink" title="客户端工具之 shadowrocket"></a>客户端工具之 shadowrocket</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">略.</span><br></pre></td></tr></table></figure>

<h4 id="客户端工具之-outline"><a href="#客户端工具之-outline" class="headerlink" title="客户端工具之 outline"></a>客户端工具之 outline</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss://base64(method:password)@server-address:port</span><br><span class="line">ss://YWVzLTI1Ni1jZmI6UGFzc3dvcmQ=@xxx.xxx.xxx.xxx:xxxxx</span><br></pre></td></tr></table></figure>

<h3 id="上古时代"><a href="#上古时代" class="headerlink" title="上古时代"></a>上古时代</h3><p>诸位还记得通过修改 host 文件来科学上网的方式吗，好怀念呀！</p>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>clash</tag>
        <tag>v2ray</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>crc-lib</title>
    <url>/sulfurandcu.io/clnyhr2mq002z10rqddw83ul7.html</url>
    <content><![CDATA[<center><a href="https://github.com/sulfurandcu/crc-lib">https://github.com/sulfurandcu/crc-lib</a></center><br>

<span id="more"></span>

<p><strong>目前支持的 crc 种类有：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum crc_16_type_t</span><br><span class="line">&#123;</span><br><span class="line">    #if crc_16_poly_8005_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0xbb3d residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16, CRC-16/ARC, CRC-16/IBM, CRC-16/LHA</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_1_1_0000, // check=0xbb3d</span><br><span class="line">    CRC_16_ARC,</span><br><span class="line">    CRC_16_IBM,</span><br><span class="line">    CRC_16_LHA,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xfee8 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/UMTS, CRC-16/BUYPASS, CRC-16/VERIFONE</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_0_0_0000, // check=0xfee8</span><br><span class="line">    CRC_16_UMTS,</span><br><span class="line">    CRC_16_BUYPASS,</span><br><span class="line">    CRC_16_VERIFONE,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x0000 refin=1 refout=1 xorout=0xFFFF check=0x44c2 residue=0xb001</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MAXIM, CRC-16/MAXIM-DOW</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_0000_1_1_FFFF, // check=0x44c2</span><br><span class="line">    CRC_16_MAXIM,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=1 refout=1 xorout=0x0000 check=0x4b37 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MODBUS</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_1_1_0000, // check=0x4b37</span><br><span class="line">    CRC_16_MODBUS,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0x800D refin=0 refout=0 xorout=0x0000 check=0x9ecf residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DDS-110</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_800D_0_0_0000, // check=0x9ecf</span><br><span class="line">    CRC_16_DDS110,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=1 refout=1 xorout=0xFFFF check=0xb4c8 residue=0xb001</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/USB</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_1_1_FFFF, // check=0xb4c8</span><br><span class="line">    CRC_16_USB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8005 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0xaee7 residue=0x0000</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/CMS</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8005_FFFF_0_0_0000, // check=0xaee7</span><br><span class="line">    CRC_16_CMS,</span><br><span class="line">    #endif</span><br><span class="line">    #if crc_16_poly_1021_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=0 refout=0 xorout=0xFFFF check=0xd64e residue=0x1d0f</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/GENIBUS, CRC-16/DARC, CRC-16/EPC, CRC-16/EPC-C1G2, CRC-16/I-CODE</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_0_0_FFFF, // check=0xd64e</span><br><span class="line">    CRC_16_GENIBUS,</span><br><span class="line">    CRC_16_DARC,</span><br><span class="line">    CRC_16_EPC,</span><br><span class="line">    CRC_16_EPC_C1G2,</span><br><span class="line">    CRC_16_ICODE,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=0 refout=0 xorout=0xFFFF check=0xce3c residue=0x1d0f</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/GSM</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_0_0_FFFF, // check=0xce3c</span><br><span class="line">    CRC_16_GSM,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0x29b1 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/CCITT-FALSE, CRC-16/IBM-3740, CRC-16/AUTOSAR</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_0_0_0000, // check=0x29b1</span><br><span class="line">    CRC_16_CCITT_FALSE,</span><br><span class="line">    CRC_16_IBM_3740,</span><br><span class="line">    CRC_16_AUTOSAR,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=1 refout=1 xorout=0xFFFF check=0x906e residue=0xf0b8</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/X-25, CRC-16/IBM-SDLC, CRC-16/ISO-HDLC, CRC-16/ISO-IEC-14443-3-B, CRC-B</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_1_1_FFFF, // check=0x906e</span><br><span class="line">    CRC_16_X25,</span><br><span class="line">    CRC_16_IBM_SDLC,</span><br><span class="line">    CRC_16_ISO_HDLC,</span><br><span class="line">    CRC_16_ISO_IEC_14443_3_B,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xC6C6 refin=1 refout=1 xorout=0x0000 check=0xbf05 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/ISO-IEC-14443-3-A, CRC-A</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_C6C6_1_1_0000, // check=0xbf05</span><br><span class="line">    CRC_16_ISO_IEC_14443_3_A,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=1 refout=1 xorout=0x0000 check=0x2189 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/CCITT, CRC-16/CCITT-TRUE, CRC-16/KERMIT, CRC-16/BLUETOOTH, CRC-16/V-41-LSB</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_1_1_0000, // check=0x2189</span><br><span class="line">    CRC_16_CCITT,</span><br><span class="line">    CRC_16_CCITT_TRUE,</span><br><span class="line">    CRC_16_KERMIT,</span><br><span class="line">    CRC_16_BLUETOOTH,</span><br><span class="line">    CRC_16_V_41_LSB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xFFFF refin=1 refout=1 xorout=0x0000 check=0x6f91 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/MCRF4XX</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_FFFF_1_1_0000, // check=0x6f91</span><br><span class="line">    CRC_16_MCRF4XX,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0xB2AA refin=1 refout=1 xorout=0x0000 check=0x63d0 residue=0x0000</span><br><span class="line">     * class: third-party</span><br><span class="line">     * alias: CRC-16/RIELLO</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_B2AA_1_1_0000, // check=0x63d0</span><br><span class="line">    CRC_16_RIELLO,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x1D0F refin=0 refout=0 xorout=0x0000 check=0xe5cc residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/AUG-CCITT, CRC-16/SPI-FUJITSU</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_1D0F_0_0_0000, // check=0xe5cc</span><br><span class="line">    CRC_16_AUG_CCITT,</span><br><span class="line">    CRC_16_SPI_FUJITSU,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x31c3 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/XMODEM, CRC-16/ACORN, CRC-16/LTE, CRC-16/V-41-MSB, XMODEM, YMODEM, ZMODEM</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_0000_0_0_0000, // check=0x31c3</span><br><span class="line">    CRC_16_XMODEM,</span><br><span class="line">    CRC_16_YMODEM,</span><br><span class="line">    CRC_16_ZMODEM,</span><br><span class="line">    CRC_16_ACORN,</span><br><span class="line">    CRC_16_LTE,</span><br><span class="line">    CRC_16_V_41_MSB,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x1021 init=0x89EC refin=1 refout=1 xorout=0x0000 check=0x26b1 residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/TMS37157</span><br><span class="line">     */</span><br><span class="line">    CRC_16_1021_89EC_1_1_0000, // check=0x26b1</span><br><span class="line">    CRC_16_TMS37157,</span><br><span class="line">    #endif</span><br><span class="line">    #if crc_16_poly_xxxx_enable</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x0589 init=0x0000 refin=0 refout=0 xorout=0x0001 check=0x007e residue=0x0589</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DECT-R, R-CRC-16</span><br><span class="line">     */</span><br><span class="line">    CRC_16_0589_0000_0_0_0001, // check=0x007e</span><br><span class="line">    CRC_16_DECT_R,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x0589 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x007f residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/DECT-X, X-CRC-16</span><br><span class="line">     */</span><br><span class="line">    CRC_16_0589_0000_0_0_0000, // check=0x007f</span><br><span class="line">    CRC_16_DECT_X,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x8bb7 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0xd0db residue=0x0000</span><br><span class="line">     * class: attested</span><br><span class="line">     * alias: CRC-16/T10-DIF</span><br><span class="line">     */</span><br><span class="line">    CRC_16_8BB7_0000_0_0_0000, // check=0xd0db</span><br><span class="line">    CRC_16_T10_DIF,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x3D65 init=0x0000 refin=1 refout=1 xorout=0xFFFF check=0xea82 residue=0x66c5</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/DNP</span><br><span class="line">     */</span><br><span class="line">    CRC_16_3D65_0000_1_1_FFFF, // check=0xea82</span><br><span class="line">    CRC_16_DNP,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0x3d65 init=0x0000 refin=0 refout=0 xorout=0xFFFF check=0xc2b7 residue=0xa366</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/EN-13757</span><br><span class="line">     */</span><br><span class="line">    CRC_16_3D65_0000_0_0_FFFF, // check=0xc2b7</span><br><span class="line">    CRC_16_EN_13757,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0xa097 init=0x0000 refin=0 refout=0 xorout=0x0000 check=0x0fb3 residue=0x0000</span><br><span class="line">     * class: confirmed</span><br><span class="line">     * alias: CRC-16/TELEDISK</span><br><span class="line">     */</span><br><span class="line">    CRC_16_A097_0000_0_0_0000, // check=0x0fb3</span><br><span class="line">    CRC_16_TELEDISK,</span><br><span class="line">    /**</span><br><span class="line">     * brief: width=16 poly=0xc867 init=0xFFFF refin=0 refout=0 xorout=0x0000 check=0x4c06 residue=0x0000</span><br><span class="line">     * class: academic</span><br><span class="line">     * alias: CRC-16/CDMA2000</span><br><span class="line">     */</span><br><span class="line">    CRC_16_C867_FFFF_0_0_0000, // check=0x4c06</span><br><span class="line">    CRC_16_CDMA2000,</span><br><span class="line">    #endif</span><br><span class="line">&#125; crc_16_type_t;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>错误控制</category>
      </categories>
      <tags>
        <tag>crc</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑结构分析算法</title>
    <url>/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu.html</url>
    <content><![CDATA[<p>2022年09月01日于武汉</p>
<pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合终端&lt;br&gt;SCU]
R0---&gt;N1[断路器&lt;br&gt;9]
R0---&gt;N2[断路器&lt;br&gt;16]
N1---&gt;N1.1[断路器&lt;br&gt;7]
N1---&gt;N1.2[断路器&lt;br&gt;6]
N1---&gt;N1.3[断路器&lt;br&gt;10]
N1---&gt;N1.4[断路器&lt;br&gt;12]
N2---&gt;N2.1[断路器&lt;br&gt;18]
N2---&gt;N2.2[断路器&lt;br&gt;19]
N2---&gt;N2.3[断路器&lt;br&gt;14]
N1.1---&gt;N1.1.1[断路器&lt;br&gt;3]
N1.1---&gt;N1.1.2[断路器&lt;br&gt;4]
N1.1---&gt;N1.1.3[断路器&lt;br&gt;5]
N1.2---&gt;N1.2.1[断路器&lt;br&gt;8]
N1.2---&gt;N1.2.2[断路器&lt;br&gt;11]
N1.3---&gt;N1.3.1[断路器&lt;br&gt;2]
N2.2---&gt;N2.2.1[断路器&lt;br&gt;13]
N2.2---&gt;N2.2.2[断路器&lt;br&gt;17]
N1.1.1---&gt;N1.1.1.1[断路器&lt;br&gt;0]
N1.2.2---&gt;N1.2.2.1[断路器&lt;br&gt;1]
N2.2.2---&gt;N2.2.2.1[断路器&lt;br&gt;15]
</pre>

<span id="more"></span>

<h2 id="拓扑识别"><a href="#拓扑识别" class="headerlink" title="拓扑识别"></a>拓扑识别</h2><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.standard.1.png"></p>
<p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.standard.2.png"></p>
<p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.standard.3.png"></p>
<div class="note danger no-icon"><p>本文所述的拓扑分析算法针对的是有时间戳的拓扑识别</p>
</div>

<h2 id="拓扑流程"><a href="#拓扑流程" class="headerlink" title="拓扑流程"></a>拓扑流程</h2><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合终端&lt;br&gt;SCU]--&gt;A2[&quot; &quot;]
R0--&gt;A1[断路器&lt;br&gt;1]
A1--&gt;B2[&quot; &quot;]
A1--&gt;B1[断路器&lt;br&gt;2]
B1--&gt;C2[&quot; &quot;]
B1--&gt;C1[断路器&lt;br&gt;3]
</pre>

<p>以上面这个简单的拓扑结构为例：</p>
<p>当 SCU 给一号断路器发送拓扑信号发生指令后一号断路器会存储一条发生记录。</p>
<p>当 SCU 给二号断路器发送拓扑信号发生指令后二号断路器会存储一条发生记录，此时一号断路器会识别到拓扑信号并存储一条识别记录，并且这两条记录中的时间基本一致。</p>
<p>当 SCU 给三号断路器发送拓扑信号发生指令后三号断路器会存储一条发生记录，此时一号断路器和二号断路器均会识别到拓扑信号并存储一条识别记录，并且这三条记录中的时间基本一致。</p>
<p>最终：</p>
<ul>
<li>一号断路器总计存储 3 条拓扑记录；</li>
<li>二号断路器总计存储 2 条拓扑记录；</li>
<li>三号断路器总计存储 1 条拓扑记录；</li>
</ul>
<p>拓扑信号发生流程结束后，智能融合终端会读取每台断路器中的拓扑记录，并将数据整理为以下格式：</p>
<p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.record.png"></p>
<p>然后智能融合终端便可通过本算法以及上述数据计算出所有断路器之间的拓扑关系。</p>
<div class="note info no-icon"><p>记录数量：每台断路器中拓扑记录的数量<br>记录内容：每条拓扑记录产生时的时间戳</p>
</div>

<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p><strong>核心思想：从末端节点开始，依次寻找每个节点的父节点，最终找到根节点。最后递归打印出拓扑关系。</strong></p>
<p>1. 遍历只有一条记录的节点（末端节点）遍历完之后将末端节点的记录数量置为零。</p>
<p>2. 遍历其他大于一条记录的节点</p>
<p>3. 判断该节点是否存在与末端节点时间相同的记录｜如果存在则表示该节点为末端节点的潜在父节点（并将该节点的记录数量减一）</p>
<p>4. 拓扑记录数量最少的那个节点即为当前末端节点的父节点</p>
<p>5. 更新拓扑网络（记录父节点）</p>
<p>6. 更新修改过的记录数量｜然后开始下一循环｜直至所有记录数量为零为止</p>
<p>7. 最后可以得到每个节点的父节点是谁（父节点为自身的即为根节点，可以存在多个根节点）</p>
<p>8. 将上述数据递归打印即可得到期望结果</p>
<h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>这里通过一个示例来描述该算法的逻辑。</p>
<h3 id="遍历之前的拓扑结构（示例）"><a href="#遍历之前的拓扑结构（示例）" class="headerlink" title="遍历之前的拓扑结构（示例）"></a>遍历之前的拓扑结构（示例）</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合终端&lt;br&gt;SCU]
R0---&gt;N1[断路器&lt;br&gt;9]
R0---&gt;N2[断路器&lt;br&gt;16]
N1---&gt;N1.1[断路器&lt;br&gt;7]
N1---&gt;N1.2[断路器&lt;br&gt;6]
N1---&gt;N1.3[断路器&lt;br&gt;10]
N1---&gt;N1.4[断路器&lt;br&gt;12]
N2---&gt;N2.1[断路器&lt;br&gt;18]
N2---&gt;N2.2[断路器&lt;br&gt;19]
N2---&gt;N2.3[断路器&lt;br&gt;14]
N1.1---&gt;N1.1.1[断路器&lt;br&gt;3]
N1.1---&gt;N1.1.2[断路器&lt;br&gt;4]
N1.1---&gt;N1.1.3[断路器&lt;br&gt;5]
N1.2---&gt;N1.2.1[断路器&lt;br&gt;8]
N1.2---&gt;N1.2.2[断路器&lt;br&gt;11]
N1.3---&gt;N1.3.1[断路器&lt;br&gt;2]
N2.2---&gt;N2.2.1[断路器&lt;br&gt;13]
N2.2---&gt;N2.2.2[断路器&lt;br&gt;17]
N1.1.1---&gt;N1.1.1.1[断路器&lt;br&gt;0]
N1.2.2---&gt;N1.2.2.1[断路器&lt;br&gt;1]
N2.2.2---&gt;N2.2.2.1[断路器&lt;br&gt;15]
</pre>

<h3 id="遍历之前的数据结构（示例）"><a href="#遍历之前的数据结构（示例）" class="headerlink" title="遍历之前的数据结构（示例）"></a>遍历之前的数据结构（示例）</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.0.svg"></p>
<h3 id="第一次遍历后的拓扑结构"><a href="#第一次遍历后的拓扑结构" class="headerlink" title="第一次遍历后的拓扑结构"></a>第一次遍历后的拓扑结构</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合终端&lt;br&gt;SCU]
R0---&gt;N1[断路器&lt;br&gt;9]
R0---&gt;N2[断路器&lt;br&gt;16]
N1---&gt;N1.1[断路器&lt;br&gt;7]
N1---&gt;N1.2[断路器&lt;br&gt;6]
N1---&gt;N1.3[断路器&lt;br&gt;10]
N1---&gt;N1.4[&quot; &quot;]
N2---&gt;N2.1[&quot; &quot;]
N2---&gt;N2.2[断路器&lt;br&gt;19]
N2---&gt;N2.3[&quot; &quot;]
N1.1---&gt;N1.1.1[断路器&lt;br&gt;3]
N1.1---&gt;N1.1.2[&quot; &quot;]
N1.1---&gt;N1.1.3[&quot; &quot;]
N1.2---&gt;N1.2.1[&quot; &quot;]
N1.2---&gt;N1.2.2[断路器&lt;br&gt;11]
N1.3---&gt;N1.3.1[&quot; &quot;]
N2.2---&gt;N2.2.1[&quot; &quot;]
N2.2---&gt;N2.2.2[断路器&lt;br&gt;17]
N1.1.1---&gt;N1.1.1.1[&quot; &quot;]
N1.2.2---&gt;N1.2.2.1[&quot; &quot;]
N2.2.2---&gt;N2.2.2.1[&quot; &quot;]
</pre>

<h3 id="第一次遍历后的数据结构"><a href="#第一次遍历后的数据结构" class="headerlink" title="第一次遍历后的数据结构"></a>第一次遍历后的数据结构</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.1.svg"></p>
<h3 id="第二次遍历后的拓扑结构"><a href="#第二次遍历后的拓扑结构" class="headerlink" title="第二次遍历后的拓扑结构"></a>第二次遍历后的拓扑结构</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合终端&lt;br&gt;SCU]
R0---&gt;N1[断路器&lt;br&gt;9]
R0---&gt;N2[断路器&lt;br&gt;16]
N1---&gt;N1.1[断路器&lt;br&gt;7]
N1---&gt;N1.2[断路器&lt;br&gt;6]
N1---&gt;N1.3[&quot; &quot;]
N1---&gt;N1.4[&quot; &quot;]
N2---&gt;N2.1[&quot; &quot;]
N2---&gt;N2.2[断路器&lt;br&gt;19]
N2---&gt;N2.3[&quot; &quot;]
N1.1---&gt;N1.1.1[&quot; &quot;]
N1.1---&gt;N1.1.2[&quot; &quot;]
N1.1---&gt;N1.1.3[&quot; &quot;]
N1.2---&gt;N1.2.1[&quot; &quot;]
N1.2---&gt;N1.2.2[&quot; &quot;]
N2.2---&gt;N2.2.1[&quot; &quot;]
N2.2---&gt;N2.2.2[&quot; &quot;]
</pre>

<h3 id="第二次遍历后的数据结构"><a href="#第二次遍历后的数据结构" class="headerlink" title="第二次遍历后的数据结构"></a>第二次遍历后的数据结构</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.2.svg"></p>
<h3 id="第三次遍历后的拓扑结构"><a href="#第三次遍历后的拓扑结构" class="headerlink" title="第三次遍历后的拓扑结构"></a>第三次遍历后的拓扑结构</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
R0[智能融合终端&lt;br&gt;SCU]
R0---&gt;N1[断路器&lt;br&gt;9]
R0---&gt;N2[断路器&lt;br&gt;16]
N1---&gt;N1.1[&quot; &quot;]
N1---&gt;N1.2[&quot; &quot;]
N1---&gt;N1.3[&quot; &quot;]
N1---&gt;N1.4[&quot; &quot;]
N2---&gt;N2.1[&quot; &quot;]
N2---&gt;N2.2[&quot; &quot;]
N2---&gt;N2.3[&quot; &quot;]
</pre>

<h3 id="第三次遍历后的数据结构"><a href="#第三次遍历后的数据结构" class="headerlink" title="第三次遍历后的数据结构"></a>第三次遍历后的数据结构</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.3.svg"></p>
<h3 id="遍历完成之后得到的数据"><a href="#遍历完成之后得到的数据" class="headerlink" title="遍历完成之后得到的数据"></a>遍历完成之后得到的数据</h3><p><img src="/sulfurandcu.io/clnyhr2mp002t10rqf5z089pu/topology.result.x.png"></p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 计算拓扑关系</span><br><span class="line">while (HaveData &amp;&amp; HaveDataOneRecord)</span><br><span class="line">&#123;</span><br><span class="line">    HaveData = false;</span><br><span class="line">    HaveDataOneRecord = false;</span><br><span class="line"></span><br><span class="line">    for (int idx = 0; idx &lt; TOPO_NODE_NUM; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned int MinNum = 0xFFFFFFFF;</span><br><span class="line">        unsigned int MinIdx = idx;</span><br><span class="line"></span><br><span class="line">        if (TopoNum[idx] &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            HaveData = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (TopoNum[idx] == 1) // 遍历只有一条记录的节点（末端节点）</span><br><span class="line">        &#123;</span><br><span class="line">            HaveDataOneRecord = true;</span><br><span class="line"></span><br><span class="line">            TopoNumMod[idx]--;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; TOPO_NODE_NUM; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                if (TopoNum[i] &lt;= 1) // 遍历其他大于一条记录的节点</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (int n = 1; n &lt;= TopoSrc[i][0]; ++n) // 判断该节点是否存在与末端节点时间相同的记录</span><br><span class="line">                &#123;</span><br><span class="line">                    if (TimeCompare(TopoSrc[idx][1], TopoSrc[i][n], TOPO_TIME_BIAS)) // 4example bias==3 (±3s)</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 如果存在则表示该节点为末端节点的潜在父节点（并将该节点的记录数量减一）</span><br><span class="line">                        TopoNumMod[i]--;</span><br><span class="line">                        if (TopoSrc[i][0] &lt; MinNum)</span><br><span class="line">                        &#123;</span><br><span class="line">                            MinNum = TopoSrc[i][0];</span><br><span class="line">                            MinIdx = i; // 查找拓扑记录数量最少的节点</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TopoNet[idx] = MinIdx; // 拓扑记录数量最少的那个节点即为当前末端节点的父节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 经过上述步骤，拓扑记录数量为一的节点的记录数量被清零，同时又重新生成了一批新的拓扑记录数量为一的节点。</span><br><span class="line">    // 这里更新中间变量，然后继续上述步骤：遍历新的只有一条记录的节点（新的末端节点），直至遍历完毕。</span><br><span class="line">    memcpy(TopoNum, TopoNumMod, sizeof(TopoNum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归打印"><a href="#递归打印" class="headerlink" title="递归打印"></a>递归打印</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void TopoPrint(unsigned int root, unsigned int *node, int node_num) // *node : 节点关系（所有节点的父节点信息）</span><br><span class="line">&#123;</span><br><span class="line">    static int depth = 1;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; node_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node[i] == root)</span><br><span class="line">        &#123;</span><br><span class="line">            fp = fopen(TOPO_FILE_PATH, &quot;a+&quot;);</span><br><span class="line"></span><br><span class="line">            // 根节点禁止递归</span><br><span class="line">            if (i == root)</span><br><span class="line">            &#123;</span><br><span class="line">                fclose(fp);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            printf(&quot;|---&quot;);</span><br><span class="line"></span><br><span class="line">            for (int d = 0; d &lt; depth; ++d)</span><br><span class="line">            &#123;</span><br><span class="line">                #if (ENABLE_PRINT)</span><br><span class="line">                printf(&quot;|---&quot;);</span><br><span class="line">                #endif</span><br><span class="line">                #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">                fprintf(fp, &quot;|---&quot;);</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 打印序号</span><br><span class="line">            #if (ENABLE_PRINT)</span><br><span class="line">            printf(&quot;%-8d&quot;, i);</span><br><span class="line">            printf(TOPO_ALIGN_STR);</span><br><span class="line">            #endif</span><br><span class="line">            #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">            fprintf(fp, &quot;%-8d&quot;, i);</span><br><span class="line">            fprintf(fp, TOPO_ALIGN_STR);</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            // 打印地址</span><br><span class="line">            for (int len = 0; len &lt; 6; ++len)</span><br><span class="line">            &#123;</span><br><span class="line">                #if (ENABLE_PRINT)</span><br><span class="line">                printf(&quot;%02X&quot;, TopoDev[i][len]);</span><br><span class="line">                #endif</span><br><span class="line">                #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">                fprintf(fp, &quot;%02X&quot;, TopoDev[i][len]);</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 打印换行</span><br><span class="line">            #if (ENABLE_PRINT)</span><br><span class="line">            printf(&quot;\r\n&quot;);</span><br><span class="line">            #endif</span><br><span class="line">            #if (ENABLE_PRINT_TO_FILE)</span><br><span class="line">            fprintf(fp, &quot;\n&quot;);</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            fclose(fp);</span><br><span class="line"></span><br><span class="line">            // 递归调用</span><br><span class="line">            depth++;</span><br><span class="line">            TopoPrint(i, node, node_num);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>拓扑识别</tag>
        <tag>拓扑分析</tag>
      </tags>
  </entry>
  <entry>
    <title>中断向量表偏移寄存器配置方式</title>
    <url>/sulfurandcu.io/clpga8j0y00i3dcrq5x5t1gkd.html</url>
    <content><![CDATA[<p>对于「引导程序＋应用程序」之类的方案，我们通常是在系统初始化函数（SystemInit()）中配置中断向量表偏移寄存器来实现中断向量表的重定向。但是这种直接修改官方库的方式往往会给后期的版本管理带来诸多不便。基于此，本文给出一个替代方案，供诸位参考。</p>
<figure class="highlight c"><figcaption><span>vtor.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xxx32xxxx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECTOR_TABLE_OFFSET             ((uint32_t)0x00018000) <span class="comment">/* % 0x200 == 0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROM_BASE                        ((uint32_t)0x08000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_BASE                        ((uint32_t)0x20000000)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemVTOR</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> EXECUTE_IN_RAM</span></span><br><span class="line">    SCB-&gt;VTOR = RAM_BASE | VECTOR_TABLE_OFFSET;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    SCB-&gt;VTOR = ROM_BASE | VECTOR_TABLE_OFFSET;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>startup_xxx32xxxx.s</span></figcaption><table><tr><td class="code"><pre><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler   [WEAK]</span><br><span class="line">                IMPORT  SystemVTOR</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                IMPORT  __main</span><br><span class="line"></span><br><span class="line">                LDR     R0, =SystemVTOR</span><br><span class="line">                BLX     R0</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0</span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发指北</category>
      </categories>
  </entry>
  <entry>
    <title>DailyGenerator</title>
    <url>/sulfurandcu.io/clnyhr2mp002w10rq4yxkans0.html</url>
    <content><![CDATA[<center>beep...领导要求每天写日报，但是我不太想写，于是就有了本段代码。</center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一键生成日报 V2.0.0</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import datetime</span><br><span class="line">from datetime import timedelta</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一键生成日报 V2.0.0</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import datetime</span><br><span class="line">from datetime import timedelta</span><br><span class="line"></span><br><span class="line"># 是否完成</span><br><span class="line">funccode = 0</span><br><span class="line"></span><br><span class="line"># 任务名称</span><br><span class="line">taskname = &quot;编码工作&quot;</span><br><span class="line"># 基准日期</span><br><span class="line">basedate = datetime.datetime.now() - timedelta(days=0)</span><br><span class="line"># 过去几天</span><br><span class="line">lastnday = 1</span><br><span class="line"># 查询深度</span><br><span class="line">userdeep = &quot;100&quot;</span><br><span class="line"># 用户名称</span><br><span class="line">username = &quot;liujitong&quot;</span><br><span class="line"># 用户路径</span><br><span class="line">userpath = &quot;http://svn.sulfurandcu.com&quot;</span><br><span class="line"></span><br><span class="line">TEXT = &quot;&quot;</span><br><span class="line">for i in range(0, lastnday):</span><br><span class="line">    svn_find = &quot;--search-and &quot; + username + &quot; --search-and &quot; + (basedate - timedelta(days=i)).strftime(&quot;%Y-%m-%d&quot;)</span><br><span class="line">    svn_deep = &quot;--limit &quot; + userdeep</span><br><span class="line">    cmd = &quot;svn log &quot; + svn_deep + &quot; &quot; + svn_find + &quot; &quot; + userpath + &quot; --non-interactive&quot;</span><br><span class="line">    with os.popen(cmd) as f:</span><br><span class="line">        text = f.read()</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\n------------------------------------------------------------------------&quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;r.* \| &quot; + username + &quot; \| &quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\) \| .*line\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;)&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\) \| .*lines\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;)&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;\n　　　　　&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;------------------------------------------------------------------------\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        text = text + &quot;EOF&quot;</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;　　　　　EOF&quot;)</span><br><span class="line">        text = rere.sub(&quot;&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot;\n　　　　　\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;\n&quot;, text)</span><br><span class="line"></span><br><span class="line">        rere = re.compile(&quot; \+0800.*\)\n&quot;)</span><br><span class="line">        text = rere.sub(&quot;\n&quot;, text)</span><br><span class="line"></span><br><span class="line">        if funccode == 1:</span><br><span class="line">            text = &quot;任务名称：&quot; + taskname + &quot;\n工作内容：\n&quot; + text</span><br><span class="line">            text = text + &quot;是否完成：是&quot;</span><br><span class="line"></span><br><span class="line">        if funccode == 0:</span><br><span class="line">            if (basedate.weekday() == 0):</span><br><span class="line">                deadline = basedate + timedelta(days=4)</span><br><span class="line">            if (basedate.weekday() == 1):</span><br><span class="line">                deadline = basedate + timedelta(days=3)</span><br><span class="line">            if (basedate.weekday() == 2):</span><br><span class="line">                deadline = basedate + timedelta(days=2)</span><br><span class="line">            if (basedate.weekday() == 3):</span><br><span class="line">                deadline = basedate + timedelta(days=1)</span><br><span class="line">            if (basedate.weekday() == 4):</span><br><span class="line">                deadline = basedate + timedelta(days=7)</span><br><span class="line">            if (basedate.weekday() == 5):</span><br><span class="line">                deadline = basedate + timedelta(days=6)</span><br><span class="line">            if (basedate.weekday() == 6):</span><br><span class="line">                deadline = basedate + timedelta(days=5)</span><br><span class="line"></span><br><span class="line">            deadline = deadline.strftime(&quot;%Y年%m月%d日&quot;)</span><br><span class="line"></span><br><span class="line">            text = &quot;任务名称：&quot; + taskname + &quot;\n工作内容：\n&quot; + text</span><br><span class="line">            text = text + &quot;是否完成：否（计划&quot; + deadline + &quot;完成）&quot;</span><br><span class="line"></span><br><span class="line">        TEXT = TEXT + text</span><br><span class="line"></span><br><span class="line">        if i &lt; lastnday-1:</span><br><span class="line">            TEXT = TEXT + &quot;\n\n&quot;</span><br><span class="line"></span><br><span class="line">filename = &quot;ooooooDailyGenerator.py.&quot; + username + &quot;.txt&quot;</span><br><span class="line">with open(filename, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(TEXT)</span><br><span class="line"></span><br><span class="line"># input()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>我的一套生产工具</title>
    <url>/sulfurandcu.io/clnyhr2mr003710rqgjtuhj11.html</url>
    <content><![CDATA[<p>分享一些提高工作效率的工具</p>
<span id="more"></span>

<h2 id="机械键盘"><a href="#机械键盘" class="headerlink" title="机械键盘"></a>机械键盘</h2><ul>
<li>使用 tmk, qmk 等工具烧录自定义固件</li>
</ul>
<h2 id="键位布局"><a href="#键位布局" class="headerlink" title="键位布局"></a>键位布局</h2><ul>
<li><a href="/sulfurandcu.io/clnor6mvz0015ocrq2jks39ew.html">dƷvorak</a></li>
</ul>
<h2 id="输入法儿"><a href="#输入法儿" class="headerlink" title="输入法儿"></a>输入法儿</h2><ul>
<li>昨夏双拼</li>
<li>小鹤双拼</li>
<li>朙月拼音</li>
<li>宫保拼音</li>
</ul>
<h2 id="输入引擎"><a href="#输入引擎" class="headerlink" title="输入引擎"></a>输入引擎</h2><ul>
<li>中州韵输入法引擎（rime, weasel, squirrel）</li>
</ul>
<h2 id="显示字体"><a href="#显示字体" class="headerlink" title="显示字体"></a>显示字体</h2><ul>
<li>思源宋体</li>
<li>思源黑体</li>
<li>更纱黑体</li>
<li>等宽字体（iosevka）</li>
<li>可变字体（Amstelvar）</li>
</ul>
<h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><ul>
<li>powertoys</li>
</ul>
<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><ul>
<li>clash.for.windows (<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a>)</li>
<li>xtls.space (<a href="https://xtlspace.20181024.xyz/#/register?code=bUox1yaB">https://xtlspace.20181024.xyz/#/register?code=bUox1yaB</a>)</li>
<li>tor.browser (<a href="https://www.torproject.org/download/">https://www.torproject.org/download/</a>)</li>
<li>tor.zlibrary (<a href="http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/">http://bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead.onion/</a>)</li>
</ul>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><ul>
<li>Aria2</li>
<li>ndm</li>
<li>qbittorrent</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul>
<li>localsend</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul>
<li>qdir</li>
<li>everything</li>
</ul>
<h2 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h2><ul>
<li>winmerge</li>
</ul>
<h2 id="远程终端"><a href="#远程终端" class="headerlink" title="远程终端"></a>远程终端</h2><ul>
<li>windterm</li>
</ul>
<h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><ul>
<li>windows.terminal</li>
<li>windows.sandboxs</li>
<li>wsl</li>
<li>docker</li>
<li>cygwin (posix.api&#x2F;cygwin1.dll, bin&#x3D;windows.pe)</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>mingw&#x2F;msys1 (shell) (posix.api&#x2F;msys-1.0.dll) (msys1~cmd.exe, mingw&#x2F;msys1~cygwin)</li>
<li>mingw&#x2F;msys2 (shell) (posix.api&#x2F;msys-2.0.dll) (msys2~cmd.exe, mingw&#x2F;msys2~cygwin)</li>
<li>scons</li>
<li>cmake.for.windows</li>
<li>ninja.for.windows</li>
<li>mingw.for.windows   (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li>
<li>mingw32 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li>
<li>mingw64 (mingw-w64) (win32.api, bin&#x3D;windows.pe) ~ (visual studio)</li>
</ul>
<h2 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h2><ul>
<li>vscode</li>
<li>vs</li>
<li>eclipse</li>
<li>android.studio</li>
</ul>
<h2 id="软件开发（嵌入式）"><a href="#软件开发（嵌入式）" class="headerlink" title="软件开发（嵌入式）"></a>软件开发（嵌入式）</h2><ul>
<li>arm-none-eabi</li>
<li>jlink</li>
<li>openocd</li>
</ul>
<h2 id="硬件开发"><a href="#硬件开发" class="headerlink" title="硬件开发"></a>硬件开发</h2><ul>
<li>KiCAD</li>
</ul>
<h2 id="机械工业"><a href="#机械工业" class="headerlink" title="机械工业"></a>机械工业</h2><ul>
<li>AutoCAD</li>
<li>FreeCAD</li>
<li>Revit</li>
<li>Rhino</li>
<li>3dsMax</li>
<li>SketchUp</li>
<li>Render.Vray</li>
<li>Render.D5</li>
<li>Render.Enscape</li>
</ul>
<h2 id="图片文档"><a href="#图片文档" class="headerlink" title="图片文档"></a>图片文档</h2><ul>
<li>截屏工具<ul>
<li>fscapture</li>
<li>sharex</li>
</ul>
</li>
<li>图片查看<ul>
<li>honeyview</li>
</ul>
</li>
<li>图片编辑<ul>
<li>GIMP</li>
<li>inkscape</li>
<li>shift.n</li>
<li>ascii.generator</li>
</ul>
</li>
<li>文档查看<ul>
<li>PDF.24</li>
</ul>
</li>
<li>文档编辑<ul>
<li>draw.io</li>
<li>wave.drom.editor</li>
</ul>
</li>
</ul>
<h2 id="视频音频"><a href="#视频音频" class="headerlink" title="视频音频"></a>视频音频</h2><ul>
<li>录屏工具<ul>
<li>obs.studio</li>
<li>lonelyscreen (ios screen display)</li>
</ul>
</li>
<li>视频播放<ul>
<li>MPC-HC</li>
<li>VLC</li>
<li>PotPlayer</li>
</ul>
</li>
<li>视频剪辑<ul>
<li>shotcut</li>
<li>losslesscut</li>
</ul>
</li>
<li>视频转码<ul>
<li>handbrake</li>
</ul>
</li>
<li>音频播放<ul>
<li>foobar2000</li>
</ul>
</li>
<li>音频剪辑<ul>
<li>audacity</li>
<li>wavosaur</li>
</ul>
</li>
<li>音频转码<ul>
<li>略.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
      </categories>
      <tags>
        <tag>生产工具</tag>
      </tags>
  </entry>
  <entry>
    <title>freertos or rtthread ?</title>
    <url>/sulfurandcu.io/cm03lc8n5007fdgrqhk1m06ee.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">对比条目</th>
<th align="center">FreeRTOS</th>
<th align="center">RT-Thread</th>
</tr>
</thead>
<tbody><tr>
<td align="center">许可协议</td>
<td align="center">MIT</td>
<td align="center">Apache License 2.0</td>
</tr>
<tr>
<td align="center">内核开销</td>
<td align="center">ROM: 5KB<br>RAM: 2KB</td>
<td align="center">ROM: 3KB<br>RAM: 1KB</td>
</tr>
<tr>
<td align="center">实测开销</td>
<td align="center"></td>
<td align="center">ROM: 11KB<br>RAM: 1KB</td>
</tr>
<tr>
<td align="center">抢占调度</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">轮转调度</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">多任务</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">优先级</td>
<td align="center">32</td>
<td align="center">8&#x2F;32&#x2F;256</td>
</tr>
<tr>
<td align="center">信号量</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">互斥量</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事件集</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">邮箱</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">信号</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">消息队列</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">内存管理</td>
<td align="center">heap1 - heap5</td>
<td align="center">内存堆管理 | 内存池管理</td>
</tr>
<tr>
<td align="center"><br></td>
<td align="center"><br></td>
<td align="center"><br></td>
</tr>
<tr>
<td align="center">系统兼容</td>
<td align="center">×</td>
<td align="center">提供 FreeRTOS_Wrapper 兼容层</td>
</tr>
<tr>
<td align="center">posix</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">shell</td>
<td align="center">×</td>
<td align="center">MSH, FINSH</td>
</tr>
<tr>
<td align="center">网络系统</td>
<td align="center">×</td>
<td align="center">SAL + AT &#x2F; LwIP</td>
</tr>
<tr>
<td align="center">文件系统</td>
<td align="center">FATFS</td>
<td align="center">DFS + FATFS &#x2F; RomFS &#x2F; Yaffs2 &#x2F; Uffs2 &#x2F; DevFS</td>
</tr>
<tr>
<td align="center">spiflash</td>
<td align="center">×</td>
<td align="center">FlashDB + FAL + SFUD</td>
</tr>
<tr>
<td align="center">设备框架</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">电源管理</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">图形界面</td>
<td align="center">×</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 656         58          0         28       1024       8091   heap_4.o</span><br><span class="line"> 124          0          0          0          0       6561   list.o</span><br><span class="line"> 894         78          0         12          0      11256   port.o</span><br><span class="line">2212        270          0         64        240      31123   tasks.o</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 168         16          0          8          0       2064   clock.o</span><br><span class="line"> 186         30         16          0          0       5388   components.o</span><br><span class="line"> 252         28          0          0          0        780   context_rvds.o</span><br><span class="line"> 640        342          0         16          0       3954   cpuport.o</span><br><span class="line">  24          0          0          0          0        609   cstdlib.o</span><br><span class="line"> 270          0          0          0          0       2774   device.o</span><br><span class="line"> 300         34          0          8        416       6238   idle.o</span><br><span class="line">1680         24          0          0          0      16384   ipc.o</span><br><span class="line"> 132         26          0          9          0       2282   irq.o</span><br><span class="line">2316        240        154        140        172      14344   kservice.o</span><br><span class="line"> 676         68          0          0          0       4430   mem.o</span><br><span class="line"> 486         26          0        196          0      10134   object.o</span><br><span class="line">  56         12          0          0         68       1341   pin.o</span><br><span class="line"> 976        178          0         24        256       9528   scheduler_up.o</span><br><span class="line">  12          0          0          0          0        540   syscalls.o</span><br><span class="line">1170         28          0         12          0      14517   thread.o</span><br><span class="line"> 948         44          0         20          0       9237   timer.o</span><br><span class="line"> 346         28          4          4          0       6717   workqueue.o</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>LilyPond</title>
    <url>/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj.html</url>
    <content><![CDATA[<p>LilyPond 是什么？(<strong><a href="https://lilypond.org/">https://lilypond.org/</a></strong>)</p>
<blockquote>
<p>LilyPond (荷花池) 是一个音乐雕版软件，致力产生最高质量的乐谱。它把传统音乐雕版印刷的美学，呈现在计算机打印的乐谱上。LilyPond 是自由软件，也是 GNU Project 的一部分。</p>
</blockquote>
<p>计算机软件的内核是将接收到的数据进行计算并输出，LilyPond 也不例外。我们需要按照 LilyPond 开发者制定的规则编写乐谱源码，然后使用 LilyPond 将源代码转换为 PNG、PDF、SVG、MIDI 等格式的文件。</p>
<span id="more"></span>

<p><strong>荷花池（线谱）的运作流程如下：</strong></p>
<ol>
<li>按照 lilypond 开发者制定的规则编写「LilyPond 乐谱源码」。</li>
<li>使用 lilypond 程序将「LilyPond 乐谱源码」转换为我们期望的「乐谱」文件。</li>
</ol>
<div class="note info no-icon"><p>这里的 lilypond.exe 程序与我们日常使用的软件有所不同，需要通过命令行的方式来调用执行。</p>
</div>

<p>不过 LilyPond 主要用于生成五线谱，若想生成简谱我们还需要借助另外一个工具：</p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly.png"></p>
<p>与上面不同，我们不再按照 LilyPond 的规则编写「LilyPond 乐谱源码」而是按照 jianpuly 开发者制定的规则编写「Jianpuly 简谱源码」。</p>
<p><strong>荷花池（简谱）的运作流程如下：</strong></p>
<ol>
<li>按照 jianpuly 开发者制定的规则编写「Jianpuly 简谱源码」。</li>
<li>使用 jianpuly 脚本将「Jianpuly 简谱源码」转换为「LilyPond 乐谱源码」。</li>
<li>使用 lilypond 程序将「LilyPond 乐谱源码」转换为我们期望的「乐谱」文件。</li>
</ol>
<div class="note info no-icon"><p>与 lilypond 类似，jianpu-ly.py 需要通过命令行的方式经 python 调用执行。</p>
</div>

<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p><strong>1. 下载 lilypond 压缩包</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.download.png"></p>
<center><a href="https://lilypond.org/download.html">下载链接</a></center><br>

<p><strong>2. 下载 jianpu-ly.py 脚本文件</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/jianpuly.download.png"></p>
<center><a href="http://ssb22.user.srcf.net/mwrhome/jianpu-ly.html">下载链接</a></center><br>

<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p><strong>1. 将下载好的 lilypond 压缩包解压至任意位置</strong></p>
<p><strong>2. 将下载好的 jianpu-ly.py 剪切至 lilypond 解压目录下的 bin 文件夹中</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.install.unpack.png"></p>
<p><strong>3. 将 lilypond 安装目录下的 bin 文件夹添加至系统环境变量 PATH 中</strong></p>
<p><strong>第一步：搜索「环境变量」然后点击「编辑系统环境变量」</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.install.systempath1.png"></p>
<p><strong>第二步：点击「环境变量」按钮</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.install.systempath2.png"></p>
<p><strong>第三步：选中系统变量中的「PATH」然后点击下方的「编辑」按钮</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.install.systempath3.png"></p>
<p><strong>第四步：点击「新建」按钮然后输入之前解压的 lilypond 的完整路径</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.install.systempath4.png"></p>
<p><strong>4. 验证 lilypond 是否正常安装</strong></p>
<p><strong>第一步：按下「Win+R」键打开运行对话框然后输入 cmd 并运行</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.install.verify.cmd.png"></p>
<p><strong>第二步：输入「lilypond –help」然后按下回车键</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2mr003410rq5kcs69uj/lilypond.help.png"></p>
<p>如果你能看到上图中的信息，那么恭喜，安装完成！下面可以尝试制作一个简单的乐谱了！</p>
<br>

<h2 id="线谱制作"><a href="#线谱制作" class="headerlink" title="线谱制作"></a>线谱制作</h2><p>写到这里时发现了一篇非常不错的 lilypond 中文入门教程，既然如此，那我索性就偷个懒，各位看官请移步这里：</p>
<center><a href="https://www.yuque.com/qqbunny/lilypond">《LilyPond 入门教程》 by 兔子不咬人</a></center><br>

<h2 id="简谱制作"><a href="#简谱制作" class="headerlink" title="简谱制作"></a>简谱制作</h2><p><strong>1. 新建一个文件夹作为工作空间</strong></p>
<p><strong>2. 将 jianpu-ly.py 脚本文件拷贝至工作空间</strong></p>
<p><strong>3. 在工作空间中创建一个文本文档（例如：简谱代码.txt）然后写入以下内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% tempo: 4=60</span><br><span class="line">title=标题</span><br><span class="line">1=C</span><br><span class="line">2/4</span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6 7 1&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>4. 在工作空间中单击右键选择「在终端中打开」然后会弹出一个黑框框</strong></p>
<p><strong>5. 输入以下命令并然后按回车键执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jianpu-ly.py 简谱代码.txt &gt; 乐谱代码.ly</span><br></pre></td></tr></table></figure>

<p><strong>6. 输入以下命令并然后按回车键执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lilypond -o 乐谱文件 --format=pdf,png 乐谱代码.ly</span><br></pre></td></tr></table></figure>

<p><strong>7. 嫌麻烦的话也可以在工作空间中新建一个「自动脚本.bat」批处理文件并填入以下内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line"></span><br><span class="line">set jianpuly=&quot;D:\develop.r.1\lilypond-2.24.1\bin\jianpu-ly.py&quot;</span><br><span class="line"></span><br><span class="line">set source=&quot;简谱&quot;</span><br><span class="line">set output=&quot;曲谱&quot;</span><br><span class="line"></span><br><span class="line">set middle=&quot;荷花&quot;</span><br><span class="line"></span><br><span class="line">python %jianpuly% %source%.txt &gt; %middle%.ly</span><br><span class="line">lilypond -o %output% --format=pdf,png %middle%.ly</span><br><span class="line">lilypond -o %output% --format=svg %middle%.ly</span><br><span class="line"></span><br><span class="line">md %source%</span><br><span class="line"></span><br><span class="line">move .\%output%.* .\%source%</span><br><span class="line">move .\%middle%.* .\%source%</span><br></pre></td></tr></table></figure>

<p><strong>8. 以后只要双击该脚本即可自动生成</strong></p>
<div class="note info no-icon"><p>使用这种方式时，文件名就不能随便起了，必须与「source」字段保持一致。</p>
</div>

<h2 id="简谱规则"><a href="#简谱规则" class="headerlink" title="简谱规则"></a>简谱规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scale going up                                              1 2 3 4 5 6 7 1&#x27;</span><br><span class="line">Accidentals                                                 1 #1 2 b2 1</span><br><span class="line">Octaves                                                     1,, 1, 1 1&#x27; 1&#x27;&#x27;</span><br><span class="line">Shortcuts for 1’ and 2’                                     8 9</span><br><span class="line">Semiquaver, quaver, crotchet (16/8/4th notes)               s1 q1 1</span><br><span class="line">Dotted versions of the above (50% longer)                   s1. q1. 1.</span><br><span class="line">Demisemiquaver, hemidemisemiquaver (32/64th notes)          d1 h1</span><br><span class="line">Minims (half notes) use dashes                              1 -</span><br><span class="line">Dotted minim                                                1 - -</span><br><span class="line">Semibreve (whole note)                                      1 - - -</span><br><span class="line">Time signature                                              4/4</span><br><span class="line">Time signature with quaver anacrusis (8th-note pickup)      4/4,8</span><br><span class="line">Key signature (major)                                       1=Bb</span><br><span class="line">Key signature (minor)                                       6=F#</span><br><span class="line">Tempo                                                       4=85</span><br><span class="line">Lyrics                                                      L: here are the syl- la- bles (all on one line)</span><br><span class="line">Lyrics (verse 1)                                            L: 1. Here is verse one</span><br><span class="line">Lyrics (verse 2)                                            L: 2. Here is verse two</span><br><span class="line">Hanzi lyrics (auto space)                                   H: hanzi (with or without spaces)</span><br><span class="line">Lilypond headers                                            title=the title (on a line of its own)</span><br><span class="line">Multiple parts                                              NextPart</span><br><span class="line">Instrument of current part                                  instrument=Flute (on a line of its own)</span><br><span class="line">Multiple movements                                          NextScore</span><br><span class="line">Prohibit page breaks until end of this movement             OnePage</span><br><span class="line">Suppress bar numbers                                        NoBarNums</span><br><span class="line">Old-style time signature                                    SeparateTimesig 1=C 4/4</span><br><span class="line">Indonesian ‘not angka’ style                                angka</span><br><span class="line">Add a Western staff doubling the tune                       WithStaff</span><br><span class="line">Tuplets                                                     3[ q1 q1 q1 ]</span><br><span class="line">Grace notes before                                          g[#45] 1</span><br><span class="line">Grace notes after                                           1 [&#x27;1]g</span><br><span class="line">Simple chords                                               135 1 13 1</span><br><span class="line">Da capo                                                     1 1 Fine 1 1 1 1 1 1 DC</span><br><span class="line">Repeat (with alternate endings)                             R&#123; 1 1 1 &#125; A&#123; 2 | 3 &#125;</span><br><span class="line">Short repeats (percent)                                     R4&#123; 1 2 &#125;</span><br><span class="line">Ties (like Lilypond’s, if you don’t want dashes)            1 ~ 1</span><br><span class="line">Slurs (like Lilypond’s)                                     1 ( 2 )</span><br><span class="line">Erhu fingering (applies to previous note)                   Fr=0 Fr=4</span><br><span class="line">Erhu symbol (applies to previous note)                      souyin harmonic up down bend tilde</span><br><span class="line">Tremolo                                                     1/// - 1///5 -</span><br><span class="line">Rehearsal letters                                           letterA letterB</span><br><span class="line">Multibar rest                                               R*8</span><br><span class="line">Dynamics (applies to previous note)                         \p \mp \f</span><br><span class="line">Other 1-word Lilypond \ commands                            \fermata \&gt; \! \( \) etc</span><br><span class="line">Text                                                        ^&quot;above note&quot; _&quot;below note&quot;</span><br><span class="line">Other Lilypond code                                         LP: (block of code) :LP (each delimeter at start of its line)</span><br><span class="line">Ignored                                                     % a comment</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学点音乐</category>
      </categories>
      <tags>
        <tag>五线谱</tag>
        <tag>简谱</tag>
        <tag>lilypond</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境配置指南</title>
    <url>/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2.html</url>
    <content><![CDATA[<p>vscode + scons + arm-none-eabi-gcc + cortex-debug + jlink</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><h3 id="1-1-安装-vscode-软件"><a href="#1-1-安装-vscode-软件" class="headerlink" title="1.1 安装 vscode 软件"></a>1.1 安装 vscode 软件</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.vscode.png"></p>
<center><a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a></center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install vscode extentions: C/C++ &amp; C/C++ Extension Pack</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install vscode extentions: Cortex-Debug</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install vscode extentions: RTOS-Views, Memory-View, Peripheral-Viewer</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="1-2-安装-python-环境"><a href="#1-2-安装-python-环境" class="headerlink" title="1.2 安装 python 环境"></a>1.2 安装 python 环境</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.python.png"></p>
<center><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install python scripts: cmd &gt; pip install scons==3.1.2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install python scripts: cmd &gt; pip install pywin32</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><figcaption><span>使用文本编辑器打开 scons 文件（该文件在你 python 安装路径下的 Scripts 目录中）</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.dont_write_bytecode = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 在 `import sys` 的下一行添加 `sys.dont_write_bytecode = True` 语句（避免生成 __pycache__ 目录）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><h3 id="2-1-安装-arm-none-eabi-交叉编译工具链"><a href="#2-1-安装-arm-none-eabi-交叉编译工具链" class="headerlink" title="2.1 安装 arm-none-eabi 交叉编译工具链"></a>2.1 安装 arm-none-eabi 交叉编译工具链</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.armtoolchain.png"></p>
<center><a href="https://developer.arm.com/downloads/-/gnu-rm">gcc-arm-none-eabi-10.3-2021.10-win32.zip</a></center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将压缩文件解压至任意位置</span><br></pre></td></tr></table></figure>

<h3 id="2-2-新建-build-任务"><a href="#2-2-新建-build-任务" class="headerlink" title="2.2 新建 build 任务"></a>2.2 新建 build 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若任务存在则该步骤可跳过</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><figcaption><span>task.json</span><a href="https://code.visualstudio.com/docs/editor/tasks">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scons -j16&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scons -c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-测试-build-任务"><a href="#2-3-测试-build-任务" class="headerlink" title="2.3 测试 build 任务"></a>2.3 测试 build 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 vscode 打开测试工程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;build（首次执行时会报错并自动生成 rtconfig.ini 文件）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 rtconfig.ini 填入 arm-none-eabi 安装路径（i.e. d:\arm-none-eabi-10.3-2021.10\bin）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;build</span><br></pre></td></tr></table></figure>

<h2 id="3-烧录"><a href="#3-烧录" class="headerlink" title="3. 烧录"></a>3. 烧录</h2><h3 id="3-1-安装-JLink-工具"><a href="#3-1-安装-JLink-工具" class="headerlink" title="3.1 安装 JLink 工具"></a>3.1 安装 JLink 工具</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.jlink.png"></p>
<center><a href="https://www.segger.com/downloads/jlink/">JLink 7.22b</a></center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装 JLink 后要记得修改 JLinkDevices.xml 并拷贝相应的 device 文件</span><br></pre></td></tr></table></figure>

<h3 id="3-2-编写-write-脚本"><a href="#3-2-编写-write-脚本" class="headerlink" title="3.2 编写 write 脚本"></a>3.2 编写 write 脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若脚本存在则该步骤可跳过</span><br></pre></td></tr></table></figure>

<figure class="highlight bat"><figcaption><span>download.bat (build/gcc/bin/download.bat)</span></figcaption><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> config=download.ini</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span> <span class="variable">%config%</span> (</span><br><span class="line">    <span class="built_in">echo</span> error: <span class="variable">%config%</span> does <span class="keyword">not</span> <span class="keyword">exist</span>. but it should have been generated automatically, you need to fill <span class="keyword">in</span> some informations. ^(greetings from liujitong^)</span><br><span class="line">    <span class="built_in">echo</span> <span class="built_in">replace</span> this line with your jlink.exe <span class="built_in">path</span>. ^(i.e. D:\JLink\JLink.exe^) ^(<span class="keyword">do</span> <span class="keyword">not</span> commit this file to svn^) &gt; <span class="variable">%config%</span></span><br><span class="line">    <span class="keyword">goto</span> end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (<span class="variable">%config%</span>) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">set</span> <span class="built_in">path</span>=&quot;<span class="variable">%%i</span>&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="variable">%path%</span> -Device %<span class="number">1</span> -<span class="keyword">If</span> SWD -Speed <span class="number">12000</span> -AutoConnect <span class="number">1</span> -NoGui <span class="number">1</span> -CommandFile %~dp0\download.txt</span><br><span class="line"></span><br><span class="line">:end</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><figcaption><span>download.txt (build/gcc/bin/download.txt)</span></figcaption><table><tr><td class="code"><pre><span class="line">r</span><br><span class="line">h</span><br><span class="line">erase 0x00000000 0x00080000</span><br><span class="line">loadfile .\rtthread.bin 0x00000000</span><br><span class="line">r</span><br><span class="line">g</span><br><span class="line">q</span><br></pre></td></tr></table></figure>

<h3 id="3-3-新建-write-任务"><a href="#3-3-新建-write-任务" class="headerlink" title="3.3 新建 write 任务"></a>3.3 新建 write 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若任务存在则该步骤可跳过</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><figcaption><span>task.json</span><a href="https://code.visualstudio.com/docs/editor/tasks">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;write&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd ./build/gcc/bin/; ./download.bat STM32F103&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;batch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scons -j16; cd ./build/gcc/bin/; ./download.bat STM32F103&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-测试-write-任务"><a href="#3-4-测试-write-任务" class="headerlink" title="3.4 测试 write 任务"></a>3.4 测试 write 任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 vscode 打开测试工程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;build</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;write（首次执行时会报错并自动生成 build/gcc/bin/download.ini 文件）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 download.ini 填入 JLink.exe 所在路径（i.e. d:\JLink_V722b\JLink.exe）（注意 JLink.exe 不能省略）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;write</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 Terminal-&gt;RunTask-&gt;batch (batch == build + write)</span><br></pre></td></tr></table></figure>

<h2 id="4-调试"><a href="#4-调试" class="headerlink" title="4. 调试"></a>4. 调试</h2><h3 id="4-1-安装-vscode-插件"><a href="#4-1-安装-vscode-插件" class="headerlink" title="4.1 安装 vscode 插件"></a>4.1 安装 vscode 插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cortex-Debug</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RTOS-Views</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Memory-View</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peripheral-Viewer</span><br></pre></td></tr></table></figure>

<h3 id="4-2-配置-vscode-插件"><a href="#4-2-配置-vscode-插件" class="headerlink" title="4.2 配置 vscode 插件"></a>4.2 配置 vscode 插件</h3><figure class="highlight json"><figcaption><span>Cortex-Debug</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cortex-debug.ArmToolchainPath&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;i.e. d:\\arm-none-eabi-10.3-2021.10\\bin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;cortex-debug.JLinkGDBServerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i.e. d:\\JLink_V722b\\JLinkGDBServerCL.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-新建-launch-配置"><a href="#4-3-新建-launch-配置" class="headerlink" title="4.3 新建 launch 配置"></a>4.3 新建 launch 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若配置存在则该步骤可跳过</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><figcaption><span>launch.json</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug@JLinkGDBServerCL.exe/stm32f103&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cortex-debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;servertype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jlink&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;serverArgs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;interface&quot;</span><span class="punctuation">:</span> <span class="string">&quot;swd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./build/gcc/bin/rtthread.elf&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;STM32F103&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;svdFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./underlayer/cpu/st/arm/stm32f1xx_libraries/device/stm32f103.svd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;liveWatch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;samplesPerSecond&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-测试-launch-配置"><a href="#4-3-测试-launch-配置" class="headerlink" title="4.3 测试 launch 配置"></a>4.3 测试 launch 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 vscode 打开测试工程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 RunAndDebug 图标（左侧边栏）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择 launch 配置</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击 StartDebugging 按钮启动调试</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧 VARIABLES 窗口查看本地变量数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧 WATCH 窗口查看变量数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左侧 XPERIPHERALS 窗口查看寄存器数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 MEMORY 窗口查看内存数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开 DEBUG CONSOLE 窗口键入 x/nfu addr 查看内存数据</span><br><span class="line">https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html</span><br></pre></td></tr></table></figure>

<h2 id="5-跳转"><a href="#5-跳转" class="headerlink" title="5. 跳转"></a>5. 跳转</h2><h3 id="5-1-安装-mingw-环境"><a href="#5-1-安装-mingw-环境" class="headerlink" title="5.1 安装 mingw 环境"></a>5.1 安装 mingw 环境</h3><p><img src="/sulfurandcu.io/clrznawwf0001a4rq8nfh1qw2/download.mingw.png"></p>
<center><a href="https://www.mingw-w64.org/downloads/">MingW-W64: x86_64-x.x.x-release-win32-seh-ucrt-xxx.7z</a></center><br>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将压缩文件解压至任意位置</span><br></pre></td></tr></table></figure>

<h3 id="5-2-配置-C-x2F-C-插件"><a href="#5-2-配置-C-x2F-C-插件" class="headerlink" title="5.2 配置 C&#x2F;C++ 插件"></a>5.2 配置 C&#x2F;C++ 插件</h3><figure class="highlight json"><figcaption><span>C/C++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;C_Cpp.default.compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i.e. d:\\mingw-w64-builds\\x86_64-win32-seh-ucrt\\mingw64\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-配置-c-cpp-properties-json-文件"><a href="#5-3-配置-c-cpp-properties-json-文件" class="headerlink" title="5.3 配置 c_cpp_properties.json 文件"></a>5.3 配置 c_cpp_properties.json 文件</h3><figure class="highlight json"><figcaption><span>c_cpp_properties.json</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/application&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/board&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/rt-thread&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/underlayer&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__CC_ARM&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c99&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-测试-c-cpp-properties-json-文件"><a href="#5-4-测试-c-cpp-properties-json-文件" class="headerlink" title="5.4 测试 c_cpp_properties.json 文件"></a>5.4 测试 c_cpp_properties.json 文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重启 vscode 打开测试工程后不弹出警告即可</span><br></pre></td></tr></table></figure>

<h2 id="6-交互（shell）"><a href="#6-交互（shell）" class="headerlink" title="6. 交互（shell）"></a>6. 交互（shell）</h2><h3 id="6-1-安装-shell-工具"><a href="#6-1-安装-shell-工具" class="headerlink" title="6.1 安装 shell 工具"></a>6.1 安装 shell 工具</h3><ul>
<li><a href="https://github.com/kingToolbox/WindTerm/releases/download/2.6.0/WindTerm_2.6.0_Windows_Portable_x86_32.zip">WindTerm_2.6.0_Windows_Portable_x86_32.zip</a></li>
<li><a href="https://github.com/kingToolbox/WindTerm/releases/download/2.6.0/WindTerm_2.6.0_Windows_Portable_x86_64.zip">WindTerm_2.6.0_Windows_Portable_x86_64.zip</a></li>
</ul>
<h3 id="6-2-新建-shell-会话"><a href="#6-2-新建-shell-会话" class="headerlink" title="6.2 新建 shell 会话"></a>6.2 新建 shell 会话</h3><figure class="highlight txt"><figcaption><span>serial</span></figcaption><table><tr><td class="code"><pre><span class="line">- 会话</span><br><span class="line">  - 串口：COM3</span><br><span class="line">  - 数据：text</span><br><span class="line">- 串口</span><br><span class="line">  - 协议</span><br><span class="line">    - 波特率：115200</span><br><span class="line">    - 数据位：8</span><br><span class="line">    - 校验位：N</span><br><span class="line">    - 停止位：1</span><br><span class="line">    - 流控制：N</span><br></pre></td></tr></table></figure>

<h3 id="6-3-测试-shell-交互"><a href="#6-3-测试-shell-交互" class="headerlink" title="6.3 测试 shell 交互"></a>6.3 测试 shell 交互</h3><figure class="highlight txt"><figcaption><span>serial COM3</span></figcaption><table><tr><td class="code"><pre><span class="line">msh &gt;</span><br><span class="line">msh &gt;</span><br><span class="line">msh &gt;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>调试精灵使用说明</title>
    <url>/sulfurandcu.io/cly6m4gfj002qscrq77a5a7cn.html</url>
    <content><![CDATA[<center><a href="https://code.visualstudio.com/Download">「这是一个内置 DLT645 规则解析引擎的协议测试工具」</a></center>

<br>

<p><img src="/sulfurandcu.io/cly6m4gfj002qscrq77a5a7cn/toolkit.dlt645.png"></p>
<span id="more"></span>

<h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><p>按照数据类型可分为：</p>
<ul>
<li>time</li>
<li>bcd</li>
<li>hex</li>
<li>bit</li>
<li>string</li>
<li>block</li>
</ul>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>数据格式为 YY、MM、DD、WW、hh、mm、ss 的自由组合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;日期时间&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;time&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;YYMMDDWWhhmmss&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="bcd"><a href="#bcd" class="headerlink" title="bcd"></a>bcd</h3><p>第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;当前电压（Ａ相）（XXX.X）&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">    &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>第二种（数据块）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;当前电压（整块）（XXX.X）　&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &quot;XXX.X&quot;,</span><br><span class="line">        &quot;XXX.X&quot;,</span><br><span class="line">        &quot;XXX.X&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果数据块中的数据单位不一样，则建议使用 block 类型。</p>
</blockquote>
<h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><p>需要显示原数据的要使用 hex 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;通信地址&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;hex&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XXXXXXXXXXXX&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>一些没有数据域的控制指令也可以使用 hex 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;设备重启&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;hex&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>位解析配置如下：</p>
<ul>
<li>lsb：表示该位段的最低位</li>
<li>msb：表示该位段的最高位</li>
<li>XX.：表示该位段的枚举值（00 ~ FF）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;有功组合方式特征字&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bit&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XX&quot;,</span><br><span class="line">    &quot;bits&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;正向有功&quot;,</span><br><span class="line">            &quot;lsb&quot;: 0,</span><br><span class="line">            &quot;msb&quot;: 1,</span><br><span class="line">            &quot;00&quot;: &quot;不加不减&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;加&quot;,</span><br><span class="line">            &quot;02&quot;: &quot;减&quot;,</span><br><span class="line">            &quot;03&quot;: &quot;又加又减&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;反向有功&quot;,</span><br><span class="line">            &quot;lsb&quot;: 2,</span><br><span class="line">            &quot;msb&quot;: 3,</span><br><span class="line">            &quot;00&quot;: &quot;不加不减&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;加&quot;,</span><br><span class="line">            &quot;02&quot;: &quot;减&quot;,</span><br><span class="line">            &quot;03&quot;: &quot;又加又减&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>支持多字节的位解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;主动上报模式字&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bit&quot;,</span><br><span class="line">    &quot;data&quot;: &quot;XXXXXXXXXXXXXXXX&quot;,</span><br><span class="line">    &quot;bits&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-14: 分闸&quot;,</span><br><span class="line">            &quot;lsb&quot;: 14,</span><br><span class="line">            &quot;msb&quot;: 14,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-15: 合闸&quot;,</span><br><span class="line">            &quot;lsb&quot;: 15,</span><br><span class="line">            &quot;msb&quot;: 15,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-16: 失压&quot;,</span><br><span class="line">            &quot;lsb&quot;: 16,</span><br><span class="line">            &quot;msb&quot;: 16,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-17: 欠压&quot;,</span><br><span class="line">            &quot;lsb&quot;: 17,</span><br><span class="line">            &quot;msb&quot;: 17,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;bit-18: 过压&quot;,</span><br><span class="line">            &quot;lsb&quot;: 18,</span><br><span class="line">            &quot;msb&quot;: 18,</span><br><span class="line">            &quot;00&quot;: &quot;&quot;,</span><br><span class="line">            &quot;01&quot;: &quot;✔&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>目前「fillin」「fillat」「endian」暂不支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;资产编码（ASCII）&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;len&quot;: 32,</span><br><span class="line">    &quot;fillin&quot;: 0,</span><br><span class="line">    &quot;fillat&quot;: &quot;front&quot;,</span><br><span class="line">    &quot;endian&quot;: &quot;LE&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>block 类型中可以放置上述任意类型，支持在 block 中嵌套 block 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;电压整定参数块&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;过压整定值&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;欠压整定值&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;断相整定值&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;XXX.X&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;V&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: &quot;00000000&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;瞬时冻结（数据块）&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;冻结时间&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;time&quot;,</span><br><span class="line">            &quot;data&quot;: &quot;YYMMDDhhmm&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;正向有功电能（总）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kWh&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;反向有功电能（总）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kWh&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;组合无功电能（c1）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kvarh&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;组合无功电能（c2）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;bcd&quot;,</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;XXXXXX.XX&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;unit&quot;: &quot;kvarh&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>通信模块设计说明</title>
    <url>/sulfurandcu.io/clz2cld8l000q1orq40fzah1z.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/cover.png"></p>
<br>

<table>
<thead>
<tr>
<th align="center">特性概述</th>
<th align="center">详细说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">较强的接收容错能力</td>
<td align="center">自动从下一个起始符继续匹配</td>
</tr>
<tr>
<td align="center">丰富的协议解析能力</td>
<td align="center">同一个端口支持解析多种协议</td>
</tr>
<tr>
<td align="center">灵活的端口转发能力</td>
<td align="center">支持在任意端口之间相互转发（转发时支持协议转换）</td>
</tr>
<tr>
<td align="center">良好的协议扩展能力</td>
<td align="center">采用星形拓扑｜方便后期扩展</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="较强的接收容错能力"><a href="#较强的接收容错能力" class="headerlink" title="较强的接收容错能力"></a>较强的接收容错能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/receive.png"></p>
<p>接收并解析一个正常的数据帧是比较容易实现的，但是有时候我们往往会碰到一些变态的场景或者变态的用户需求，比如说在一堆乱码中混入一个正常帧，又或者是在一个半帧后面接一个正常帧，在这种情况下程序能否正常解析，就很考验程序设计的功力了。目前的方案是，从第一个起始符开始尝试与指定的协议进行匹配，如果匹配成功，则正常返回；如果匹配失败，则自动从下一个字节或者下一个起始符开始继续匹配，直到匹配成功。</p>
<h2 id="丰富的协议解析能力"><a href="#丰富的协议解析能力" class="headerlink" title="丰富的协议解析能力"></a>丰富的协议解析能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/protocol.png"></p>
<p>我个人认为一个端口只支持解析一种协议的设计是很鸡肋的，无法满足一些变态的用户需求。为此，本人设计了一套全新的通信系统，支持在同一个端口上解析多种协议。其原理为，从底层数据缓冲区中一个字节一个字节地读取数据，每拿取一个字节，就与协议库中的若干协议比对一次，直到比对成功。</p>
<h2 id="灵活的端口转发能力"><a href="#灵活的端口转发能力" class="headerlink" title="灵活的端口转发能力"></a>灵活的端口转发能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/transforward.png"></p>
<p>数据帧在单个端口内完成接收、解析、处理、响应的设计是比较简单的，而一旦涉及到转发，事情就变得复杂了。首先，要想在任意端口之间转发，就不能把端口分成上行、下行，左行、右行也不行，所有端口都应该是平等的，且遵循同一套规则。其次，两个端口所用的协议有很大可能是不同的，所以还需要支持协议转换。协议转换详见下一章节。</p>
<h2 id="良好的协议扩展能力"><a href="#良好的协议扩展能力" class="headerlink" title="良好的协议扩展能力"></a>良好的协议扩展能力</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/topology.png"></p>
<p>协议转换最容易想到的就是两两转换，不过两两转换在协议少的时候还好说，干就完了，但是后期若是要扩展第三个、第Ｎ个协议，两两转换的弊端就显现出来了，其工作量可是呈C₂ⁿ级增长的。而星形拓扑的设计则可以很好地解决这个问题。</p>
<table>
<thead>
<tr>
<th align="center">协议数量</th>
<th align="center">网状拓扑 O(C₂ⁿ)</th>
<th align="center">星形拓扑 O(n)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">10</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">15</td>
<td align="center">6</td>
</tr>
</tbody></table>
<h2 id="通信模块的转发原理"><a href="#通信模块的转发原理" class="headerlink" title="通信模块的转发原理"></a>通信模块的转发原理</h2><p><img src="/sulfurandcu.io/clz2cld8l000q1orq40fzah1z/implementation.png"></p>
]]></content>
  </entry>
  <entry>
    <title>集成开发环境－合集</title>
    <url>/sulfurandcu.io/clo3okqut006mi0rq9ecvb34e.html</url>
    <content><![CDATA[<hr>
<p>各个平台下的开发环境搭建教程</p>
<ul>
<li><a href="/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html">ARM.GCC</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.MDK (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.SES (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">ARM.ADS (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">RV5.GCC (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">RV5.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">RV5.SES (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">C51.MDK (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">C51.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">MSP.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">AVR.IAR (TODO)</a></li>
<li><a href="/sulfurandcu.io/404/index.html">PIC.XXX (TODO)</a></li>
</ul>
<hr>
<span id="more"></span>

<h2 id="搭建方案"><a href="#搭建方案" class="headerlink" title="搭建方案"></a>搭建方案</h2><ul>
<li><strong>VSC</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li>
<li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li>
<li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li>
<li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li>
<li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li>
</ul>
</li>
<li><strong>VS</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li>
<li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li>
</ul>
</li>
<li><strong>Eclipse</strong></li>
<li><strong>Eclipse Based</strong><ul>
<li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a></li>
<li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a></li>
<li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a></li>
</ul>
</li>
</ul>
<h2 id="通用方案"><a href="#通用方案" class="headerlink" title="通用方案"></a>通用方案</h2><ul>
<li><a href="https://www.keil.arm.com/">KeilStudioCloud</a></li>
<li><a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Development%20Studio">ADS</a><ul>
<li>ARM</li>
</ul>
</li>
<li><a href="https://www.keil.com/">MDK</a><ul>
<li>ARM <a href="https://www.keil.com/pr/article/1302.htm">(ARM 6 Will start shipping towards The End of 2023)</a></li>
<li>C51</li>
</ul>
</li>
<li><a href="https://www.iar.com/products/architectures/">IAR</a><ul>
<li>RV5</li>
<li>ARM</li>
<li>AVR</li>
<li>MSP</li>
<li>STM</li>
<li>C51</li>
</ul>
</li>
<li><a href="https://www.segger.com/products/development-tools/embedded-studio/">SES</a><ul>
<li>ARM</li>
<li>RV5</li>
</ul>
</li>
<li><a href="https://embeetle.com/#">EmbeetleIDE</a></li>
</ul>
<h2 id="专用方案"><a href="#专用方案" class="headerlink" title="专用方案"></a>专用方案</h2><ul>
<li><strong>Eclipse Based</strong><ul>
<li><a href="https://www.st.com/en/development-tools/sw4stm32.html">ST: SW4STM32 System Workbench for STM32</a></li>
<li><a href="https://www.st.com/en/development-tools/truestudio.html">ST: TrueStudio by Atollic before 2017</a></li>
<li><a href="">ST: STM32CubeIDE release in 2019 &#x3D; TrueStudio+STM32CubeMX</a></li>
<li><a href="https://www.renesas.com/us/en/software-tool/e-studio">Renesas: E2Studio</a></li>
</ul>
</li>
<li><strong>NetBeans Based</strong><ul>
<li><a href="https://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide">Microchip: MPLAB X IDE</a></li>
</ul>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://elmagnifico.tech/2022/03/14/Embeded-IDE/">https://elmagnifico.tech/2022/03/14/Embeded-IDE/</a><br><a href="https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/">https://elmagnifico.tech/2022/03/15/Embedded-Software-Development-VS-VSC/</a></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－DBG</title>
    <url>/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p>
<span id="more"></span>

<h2 id="专用的调试模块"><a href="#专用的调试模块" class="headerlink" title="专用的调试模块"></a>专用的调试模块</h2><p>常见的 IDE 内部都集成了一个专用的 GUI 调试器，且不能拎出来单独使用。</p>
<ul>
<li>ADS</li>
<li>IAR</li>
<li>MDK</li>
<li>Visual Studio</li>
</ul>
<h2 id="独立的调试工具"><a href="#独立的调试工具" class="headerlink" title="独立的调试工具"></a>独立的调试工具</h2><p>当然也有一些可以独立使用的调试器，例如：</p>
<ul>
<li>CLI: GDB, LLDB</li>
<li>GUI: x64dbg, WinDBG, OllyDBG</li>
</ul>
<h2 id="图形调试器"><a href="#图形调试器" class="headerlink" title="图形调试器"></a>图形调试器</h2><h2 id="适配器协议（DebugAdapterProtocol）"><a href="#适配器协议（DebugAdapterProtocol）" class="headerlink" title="适配器协议（DebugAdapterProtocol）"></a>适配器协议（DebugAdapterProtocol）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapterProtocol.png"></p>
<p>不论是专用的调试模块还是独立的调试工具，如果想支持调试多种语言，就必须要为每一种语言开发一套对应的调试程序，并且每个工具厂商都要独自去完成这些工作。为了减少不必要的重复劳动，微软制定了一套通用的调试协议，借助该协议各工具厂商只需要开发一套调试程序，向下再借助各种调试适配工具即可具备调试所有语言的能力。</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/DebugAdapterProtocol(DAP).png"></p>
<center><a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Adapter Protocol (DAP)</a></center><br>

<p>目前实现该调试协议的开发工具有（常用的）：</p>
<ul>
<li>VSC</li>
<li>VS</li>
<li>vim</li>
<li>emacs</li>
<li>EclipseIDE</li>
</ul>
<p>btw, 微软还制定了一套通用的语言服务器协议 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/LanguageServerProtocol(LSP).png"></p>
<center><a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a></center>

<h2 id="调试适配器（DebugAdapter）"><a href="#调试适配器（DebugAdapter）" class="headerlink" title="调试适配器（DebugAdapter）"></a>调试适配器（DebugAdapter）</h2><p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugAdapter.png"></p>
<p>调试适配器是对各类调试器的封装，遵循 DAP 协议对上提供统一的接口，以简化上层开发工具。常用的调试适配器有：</p>
<ul>
<li><a href="https://github.com/Microsoft/vscode-cpptools">cpptools (C&#x2F;C++ Debug Adapter)</a></li>
<li><a href="https://github.com/Marus/cortex-debug">cortex-debug (Embedded C&#x2F;C++ Debug Adapter)</a></li>
</ul>
<h2 id="命令调试器（Debugger）"><a href="#命令调试器（Debugger）" class="headerlink" title="命令调试器（Debugger）"></a>命令调试器（Debugger）</h2><ul>
<li><a href="https://sourceware.org/gdb/">GDB: The GNU Project Debugger</a><ul>
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">↑ GDB&#x2F;MI</a></li>
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html">↓ GDB Remote Serial Protocol</a></li>
</ul>
</li>
<li><a href="https://developer.arm.com/downloads/-/gnu-rm">arm-none-eabi-gdb: GNU Arm Embedded GDB</a></li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Debugger.png"></p>
<h2 id="调试服务器（DebugServer）"><a href="#调试服务器（DebugServer）" class="headerlink" title="调试服务器（DebugServer）"></a>调试服务器（DebugServer）</h2><ul>
<li>OpenOCD</li>
<li>PyOCD</li>
<li>JLinkGDBServer</li>
<li>……</li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.DebugServer.png"></p>
<h2 id="仿真器驱动（DongleDriver）"><a href="#仿真器驱动（DongleDriver）" class="headerlink" title="仿真器驱动（DongleDriver）"></a>仿真器驱动（DongleDriver）</h2><ul>
<li>SEGGER JLink USB Driver</li>
<li>SEGGER WinUSB USB Device Driver</li>
</ul>
<h2 id="仿真器设备（Dongle）"><a href="#仿真器设备（Dongle）" class="headerlink" title="仿真器设备（Dongle）"></a>仿真器设备（Dongle）</h2><ul>
<li>CMSIS-DAP</li>
<li>SEGGER JLink</li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Dongle.png"></p>
<h2 id="仿真器协议（DongleTransportProtocol）"><a href="#仿真器协议（DongleTransportProtocol）" class="headerlink" title="仿真器协议（DongleTransportProtocol）"></a>仿真器协议（DongleTransportProtocol）</h2><ul>
<li>JTAG <a href="https://www.corelis.com/education/tutorials/jtag-tutorial/">https://www.corelis.com/education/tutorials/jtag-tutorial/</a></li>
<li>SWD</li>
</ul>
<h2 id="目标板芯片（TargetBoard）"><a href="#目标板芯片（TargetBoard）" class="headerlink" title="目标板芯片（TargetBoard）"></a>目标板芯片（TargetBoard）</h2><ul>
<li>STM32F103CB</li>
<li>STM32F407VE</li>
</ul>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/Arch.Target.png"></p>
<h2 id="本地与远程调试"><a href="#本地与远程调试" class="headerlink" title="本地与远程调试"></a>本地与远程调试</h2><p>远程调试方案也有很多，这里只对以下几种方式作一简要介绍：</p>
<ul>
<li>OpenOCD</li>
<li>VSCode + JLinkGDBServer</li>
<li>JLink + JLinkRemoteServer</li>
<li>KeilMDK + JLinkRemoteServer</li>
</ul>
<h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>略.</p>
<h3 id="VSCode-JLinkGDBServer"><a href="#VSCode-JLinkGDBServer" class="headerlink" title="VSCode + JLinkGDBServer"></a>VSCode + JLinkGDBServer</h3><p>1. 在服务主机上配置开启 JLink 调试服务器（该服务器会监听 2331 端口）</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.0.png"></p>
<div class="note danger no-icon"><p>不要勾选 Localhost Only 选项！</p>
</div>

<p>2. 等待连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.1.png"></p>
<p>3. 在本地主机上配置 launch.json 文件并启动调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">    &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">    &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">    &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">    &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Marus/cortex-debug/issues/244">cortex-debug-issues#244 : remote debugging</a><br><a href="https://github.com/Marus/cortex-debug/wiki/External-gdb-server-configuration">cortex-debug-wiki : external gdb server configuration</a></p>
<div class="note info no-icon"><p>点击启动调试后 cortex-debug 便会帮助我们通过本地 xGDB 客户端连接远程 GDB 服务器。</p>
</div>

<p>4. 建立连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.2.png"></p>
<p>5. 远程调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此处省略一张在 vscode 中调试的图片</span><br></pre></td></tr></table></figure>

<p>6. 断开连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkGDBServer.LAN.Server.3.png"></p>
<h3 id="JLink-JLinkRemoteServer"><a href="#JLink-JLinkRemoteServer" class="headerlink" title="JLink + JLinkRemoteServer"></a>JLink + JLinkRemoteServer</h3><h4 id="内网连接"><a href="#内网连接" class="headerlink" title="内网连接"></a>内网连接</h4><p>1. 在服务主机上配置开启 JLink 远程服务器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p>
<p>2. 等待连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p>
<p>3. 在本地主机上配置连接 JLink 远程服务器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.png"></p>
<p>4. 建立连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p>
<p>5. 远程调试</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.1.png"></p>
<p>6. 断开连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p>
<h4 id="隧道连接"><a href="#隧道连接" class="headerlink" title="隧道连接"></a>隧道连接</h4><p>1. 在服务主机上配置开启 JLink 远程服务器（隧道方式）</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.0.png"></p>
<p>2. 等待连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.1.png"></p>
<p>3. 在本地主机上配置连接 JLink 远程服务器（隧道方式）</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.0.png"></p>
<p>4. 建立连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.2.png"></p>
<p>5. 远程调试</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Client.1.png"></p>
<p>6. 断开连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.Tunnel.Server.3.png"></p>
<h3 id="KeilMDK-JLinkRemoteServer"><a href="#KeilMDK-JLinkRemoteServer" class="headerlink" title="KeilMDK + JLinkRemoteServer"></a>KeilMDK + JLinkRemoteServer</h3><h4 id="内网连接-1"><a href="#内网连接-1" class="headerlink" title="内网连接"></a>内网连接</h4><p>1. 在服务主机上配置开启 JLink 远程服务器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.0.png"></p>
<p>2. 等待连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.1.png"></p>
<p>3. 在本地主机上配置连接 JLink 远程服务器</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Client.0.Keil.MDK.png"></p>
<p>4. 建立连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.2.png"></p>
<p>5. 远程调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此处省略一张在 Keil MDK 中调试的图片</span><br></pre></td></tr></table></figure>

<p>6. 断开连接</p>
<p><img src="/sulfurandcu.io/clockxig7001dj4rqc2n6542r/JLinkRMTServer.LAN.Server.3.png"></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－GCC.ARM（#01）环境搭建</title>
    <url>/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc.html</url>
    <content><![CDATA[<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png"></p>
<span id="more"></span>

<hr>
<h2 id="编辑器安装"><a href="#编辑器安装" class="headerlink" title="编辑器安装"></a>编辑器安装</h2><ul>
<li><strong>VSC</strong></li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VSC.png"></p>
<center><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></center>

<ul>
<li><strong>VS</strong></li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.VS.png"></p>
<center><a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a></center>

<ul>
<li><strong>Eclipse.Embedded</strong></li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc/Download.EclipseEmbedded.png"></p>
<center><a href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a></center>

<h2 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h2><ul>
<li><strong><a href="https://github.com/Marus/cortex-debug/wiki">vscode :: cortex-debug</a></strong></li>
<li><strong><a href="https://em-ide.com/zh-cn/">vscode :: eide</a></strong></li>
</ul>
<h2 id="编译器安装"><a href="#编译器安装" class="headerlink" title="编译器安装"></a>编译器安装</h2><ul>
<li><strong><a href="https://packages.msys2.org/base/mingw-w64-arm-none-eabi-gcc">Arm GNU Toolchain on MSYS2</a> (pacman -S mingw-w64-x86_64-arm-none-eabi-gcc)</strong></li>
<li><strong><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain (12.2.Rel1 based on GCC 12.2)</a></strong></li>
<li><strong><a href="https://developer.arm.com/downloads/-/gnu-a">Arm GNU Toolchain for the Cortex-A (10.3-2021.07 based on GCC 10.3)</a></strong></li>
<li><strong><a href="https://developer.arm.com/downloads/-/gnu-rm">Arm GNU Toolchain for the Cortex-R &amp; Cortex-M (10.3-2021.10 based on GCC 10.3)</a></strong></li>
<li><strong><a href="https://xpack.github.io/dev-tools/arm-none-eabi-gcc/releases/">xPack GNU Arm Embedded GCC toolchain</a></strong></li>
</ul>
<div class="note danger no-icon"><p>记得将安装目录添加至系统环境变量</p>
</div>

<h2 id="调试器安装"><a href="#调试器安装" class="headerlink" title="调试器安装"></a>调试器安装</h2><ul>
<li><strong><a href="https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack">JLink Installer</a></strong></li>
<li><strong><a href="https://packages.msys2.org/base/mingw-w64-openocd">OpenOCD on MSYS2</a> (pacman -S mingw-w64-x86_64-openocd)</strong></li>
<li><strong><a href="https://github.com/openocd-org/openocd/releases">OpenOCD prebuilt by OpenOCD.org</a></strong></li>
<li><strong><a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD prebuilt by Sysprogs</a></strong></li>
<li><strong><a href="https://xpack.github.io/dev-tools/openocd/releases/">OpenOCD prebuilt by xPackProject</a></strong></li>
</ul>
<div class="note danger no-icon"><p>记得将安装目录添加至系统环境变量</p>
</div>

<h2 id="构建器安装"><a href="#构建器安装" class="headerlink" title="构建器安装"></a>构建器安装</h2><ul>
<li><strong><a href="https://www.msys2.org/">mingw-make in msys2</a></strong></li>
<li><strong>cmake <a href="https://cmake.org/">download</a> (python -m pip install cmake) (winget install cmake)</strong></li>
<li><strong>ninja <a href="https://ninja-build.org/">download</a> (python -m pip install ninja) (winget install ninja)</strong></li>
<li><strong>scons <a href="https://scons.org/">download</a> (python -m pip install scons&#x3D;&#x3D;3.1.2)</strong></li>
</ul>
<div class="note info no-icon"><p>理论上安装完编辑器、编译器和调试器之后就能够进行开发了，安装上述工具是为了提高开发效率。</p>
</div>

<h2 id="必要的文件"><a href="#必要的文件" class="headerlink" title="必要的文件"></a>必要的文件</h2><ul>
<li><strong>*.h, *.c</strong><br>代码文件：在 makefile 中引用进行编译</li>
<li><strong>*.s</strong><br>启动文件：在 makefile 中引用进行编译</li>
<li><strong>*.ld</strong><br>链接文件：在 makefile 中引用进行链接</li>
<li><strong>*.svd</strong><br>描述文件：在 launch.json 中配置用于调试</li>
</ul>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－GCC.ARM（#00）目录索引</title>
    <url>/sulfurandcu.io/clo2c1l6m00de1wrqg1jcfbqd.html</url>
    <content><![CDATA[<hr>
<p><a href="/sulfurandcu.io/clo2c1l6o00dh1wrqd2o379jc.html">集成开发环境－GCC.ARM（#01）环境搭建</a><br><a href="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq.html">集成开发环境－GCC.ARM（#02）程序构建</a><br><a href="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html">集成开发环境－GCC.ARM（#03）程序烧录</a><br><a href="/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html">集成开发环境－GCC.ARM（#04）快捷任务</a><br><a href="/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html">集成开发环境－GCC.ARM（#05）程序调试</a><br><a href="/sulfurandcu.io/clockxig7001dj4rqc2n6542r.html">集成开发环境－DBG</a></p>
<hr>
<p>传统的集成开发环境（MDK、IAR）通常会提供包括编辑、编译、烧录、调试在内的一整套工具，开发者无需配置，简单易用，但 license 也不是一般的贵。</p>
<p>替代方案：</p>
<ul>
<li><strong>VSC</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Microsoft Embedded Tools</a></li>
<li><a href="https://github.com/Marus/cortex-debug/wiki">Cortex Debug</a></li>
<li><a href="https://em-ide.com/zh-cn/">Embedded IDE</a></li>
<li><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v4.3.1/esp32/index.html">vscode for espidf</a></li>
<li><a href="https://www.essemi.com/index/article/plist?cid=141">vscode for essemi</a></li>
</ul>
</li>
<li><strong>VS</strong><ul>
<li><a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Microsoft Embedded Software Development in Visual Studio</a></li>
<li><a href="https://visualgdb.com/">VisualGDB by SysPROGS</a></li>
</ul>
</li>
<li><strong>Eclipse</strong></li>
<li><strong>Eclipse Based</strong><ul>
<li><a href="https://www.rt-thread.io/studio.html">EclipseBased: RT-Thread Studio</a> (RV5 ARM JLink STLink DAP-Link QEMU)</li>
<li><a href="http://www.mounriver.com/">EclipseBased: MounRiver Studio</a> (RV5 ARM)</li>
<li><a href="https://www.rvmcu.com/nucleistudio.html">EclipseBased: NucleiIDE Studio</a> (RV5)</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>编辑（vscode）</li>
<li>编译（arm-none-eabi-xxx）</li>
<li>烧录（JLink）</li>
<li>调试（vscode-debug + cortex-debug + arm-none-eabi-gdb + JLinkGDBServerCL + JLinkDevice）</li>
</ol>
<ul>
<li><p><strong>vscode (task.json)</strong><br>文本编辑器，其实是一个伪装成文本编辑器的开发框架。</p>
</li>
<li><p><strong>arm-none-eabi-xxx</strong><br>交叉编译器，可以编译出在 Cortex-R&amp;M 平台上运行的可执行程序。</p>
</li>
<li><p><strong>JLink&#x2F;OpenOCD</strong><br>程序烧录器，负责将编译好的程序烧录到目标芯片中。</p>
</li>
<li><p><strong>vscode-debug (launch.json)</strong><br>图形调试器，内部集成的图形调试组件，提供一套图形调试界面，与调试适配器打交道。</p>
</li>
<li><p><strong>cortex-debug</strong><br>调试适配器，将图形调试器的操作翻译成命令调试器能够看得懂的命令。</p>
</li>
<li><p><strong>arm-none-eabi-gdb</strong><br>命令调试器，支持通过命令行的方式进行调试。</p>
</li>
<li><p><strong>JLinkGDBServerCL&#x2F;OpenOCD</strong><br>调试服务器，负责协助调试器识别并管理各种仿真设备和目标芯片。</p>
</li>
<li><p><strong>JLinkDriver</strong><br>仿真器驱动，负责驱动仿真器设备。</p>
</li>
<li><p><strong>JLinkDongle</strong><br>仿真器设备，通过 JTAG 或 SWD 协议与芯片打交道。</p>
</li>
</ul>
<blockquote>
<p>倘若宿主机使用 Windows 操作系统并且购买了 JLinkDongle 仿真器，则推荐使用 JLink 方案！</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_41328027/article/details/122969985">OpenOCD添加第三方设备支持:HT32F52352 Cortex-M0+</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/61519415">用VS Code开发STM32（一）</a><br><a href="https://zhuanlan.zhihu.com/p/61538230">用VS Code开发STM32（二）</a><br><a href="https://zhuanlan.zhihu.com/p/61541590">用VS Code开发STM32（三）</a><br><a href="https://zhuanlan.zhihu.com/p/163771273">用VS Code开发STM32（四）</a></p>
<p><a href="https://blog.csdn.net/weixin_42328389/article/details/128511370">矜辰所致 OpenOCD 不同仿真器使用操作总结记录</a><br><a href="https://blog.csdn.net/weixin_42328389/article/details/119823834">矜辰所致 在window下使用 VScode 搭建 ARM 开发环境—— 详细版</a><br><a href="https://blog.csdn.net/pyt1234567890/article/details/122522700">VsCode+OpenOCD 开发stm32系列</a><br><a href="https://blog.csdn.net/qq_49295302/article/details/124628016">vscode-armgcc-openocd搭建STM32开发调试环境</a><br><a href="https://blog.csdn.net/qq_45701067/article/details/121652228">用 vscode 搭建stm32 开发环境（详细）</a><br><a href="http://eda88.com/essay/firmware/vscode%E6%90%AD%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88%E8%BD%AC%EF%BC%89/">VSCode搭建STM32开发调试环境（转）</a><br><a href="https://blog.csdn.net/ben_black/article/details/109906781">VSCode搭建STM32开发环境（极简自我搭建&amp;懒人直接使用插件）</a><br><a href="https://blog.csdn.net/qq_40833810/article/details/106713462">Cortex-debug 调试器使用介绍</a><br><a href="https://mcuoneclipse.com/2021/05/01/visual-studio-code-for-c-c-with-arm-cortex-m-part-1/">Visual Studio Code for C&#x2F;C++ with ARM Cortex-M: Part 1 </a></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－GCC.ARM（#03）程序烧录</title>
    <url>/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b.html</url>
    <content><![CDATA[<p>编程&#x2F;下载&#x2F;烧录的方式有多种，本文重点介绍以下两种烧录方式：</p>
<ul>
<li>JLink</li>
<li>OpenOCD + JLink 仿真器</li>
</ul>
<p>其中 OpenOCD 可以搭配多种仿真器使用，这里以 JLink 仿真器为例进行说明。</p>
<span id="more"></span>

<h2 id="JLink"><a href="#JLink" class="headerlink" title="JLink"></a>JLink</h2><p>1. 确认是否购买了 JLink 仿真器并且已经安装了 JLink 程序。</p>
<p>2. 在 makefile 中添加 write 选项：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.png"></p>
<p>3. 在工程目录下新建 JLinkLoad.txt 文件并写入以下内容：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.code.png"></p>
<p>4. 执行 mingw32-make write 指令：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLinkLoad.succ.png"></p>
<div class="note danger no-icon"><p>再次提醒：需要使用 JLink 仿真器以及<strong>默认驱动</strong></p>
</div>

<div class="note danger no-icon"><p>如果你的电脑中有不止一个 “JLink” 程序，确保在 makefile 中通过绝对路径使用 JLink 命令。</p>
</div>

<p>下图是我安装了 JavaJDK 后系统中存在的 jlink 程序，只不过此 “jlink” 非彼 “JLink”！</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.JLink.JavaJDK.png"></p>
<h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>1. 确认是否购买了 JLink 仿真器并且已经安装了 OpenOCD 程序。</p>
<p>2. 在 makefile 中添加 write 选项：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.png"></p>
<p>3. 在工程目录下新建 openocd.cfg 文件并写入以下内容：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.code.png"></p>
<blockquote>
<p><a href="https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics">https://openocd.org/doc-release/html/OpenOCD-Project-Setup.html#Configuration-Basics</a></p>
</blockquote>
<p>4. 将 jlink.cfg 和 stm32f1x.cfg 拷贝至工程目录下。</p>
<p>5. 使用 zadig 或 USBDriverTool 将仿真器的驱动从 WinUSB 改为 libusb 驱动。</p>
<p>6. 执行 mingw32-make write 指令：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/make.write.OpenOCD.JLink.succ.png"></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="问题一：未找到-JLink-仿真器"><a href="#问题一：未找到-JLink-仿真器" class="headerlink" title="问题一：未找到 JLink 仿真器"></a>问题一：未找到 JLink 仿真器</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.1.png"></p>
<p>OpenOCD 对仿真器的支持是通过底层的访问控制实现的，不依赖仿真器自身的驱动，但是需要 libusb 驱动，因此我们需要使用 zadig 或 USBDriverTool 等工具将仿真器的默认驱动改为 libusb 驱动。</p>
<p>需要注意的是，将驱动改成 libusb 之后，原有的调试软件例如 JLink&#x2F;Keil 将无法再识别到仿真器。</p>
<p>如果你还想继续使用这些调试软件，则需要卸载掉当前的驱动程序并插拔一下仿真器：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA1.2.png"></p>
<h3 id="问题二：SWD-amp-JTAG"><a href="#问题二：SWD-amp-JTAG" class="headerlink" title="问题二：SWD &amp; JTAG"></a>问题二：SWD &amp; JTAG</h3><p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.1.png"></p>
<p>OpenOCD 提供的 jlink.cfg 脚本默认使用 JTAG 模式，而我们实际使用的是 SWD 模式。</p>
<p>解决方法：在 openocd.cfg 文件中添加一条语句：</p>
<p><img src="/sulfurandcu.io/clo2c1l6600ca1wrqbvuabt0b/QA2.2.png"></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－GCC.ARM（#02）程序构建</title>
    <url>/sulfurandcu.io/clo2c1l6400c71wrq3816hypq.html</url>
    <content><![CDATA[<p>倘若只有 main.h 和 main.c 两个文件，那么只需要执行少量的指令即可完成编译工作。但是实际上一个工程通常包含几十上百个文件，意味着要执行大量的编译指令才能得到目标文件，这是我们所无法接受的。因此需要借助 make、cmake、ninja、scons 等构建工具来提高开发效率。</p>
<span id="more"></span>

<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>在 windows 系统中推荐使用 MSYS2 提供的 mingw32-make 程序。</p>
<h3 id="生成脚本（makefile）"><a href="#生成脚本（makefile）" class="headerlink" title="生成脚本（makefile）"></a>生成脚本（makefile）</h3><p>相较于头开始写 makefile 脚本，先通过 STM32CubeMX 生成然后加以改造则要容易得多。</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.0.png"></p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.1.png"></p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/GenerateMakefileByCubeMX.2.png"></p>
<h3 id="修改脚本（makefile）"><a href="#修改脚本（makefile）" class="headerlink" title="修改脚本（makefile）"></a>修改脚本（makefile）</h3><ol>
<li>修改文件列表（*.c &amp; *.s）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_SOURCES = \</span><br><span class="line">../../../code/Application/src/main.c \</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASM_SOURCES = \</span><br><span class="line">startup_stm32f103xb.s \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>修改包含路径（*.h）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_INCLUDES = \</span><br><span class="line">-I../../../code/Application \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>修改全局定义（#define）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C_DEFS = \</span><br><span class="line">-DUSE_HAL_DRIVER \</span><br><span class="line">-DSTM32F103xB \</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>修改链接脚本（.ld）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDSCRIPT = STM32F103C8Tx_FLASH.ld</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h3><p>在 makefile 所在的路径下执行 make 指令开始编译</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.build.png"></p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.where.png"></p>
<div class="note danger no-icon"><p>在 windows 系统中请使用 .&#x2F;mingw32-make 命令而非 .&#x2F;make 命令！</p>
</div>

<h3 id="清除编译"><a href="#清除编译" class="headerlink" title="清除编译"></a>清除编译</h3><p>若要清除刚才编译的中间文件，则需要修改 makefile 文件，然后执行 mingw32-make clean 指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">#   -rm -fR $(BUILD_DIR)</span><br><span class="line">    -del /q $(BUILD_DIR)</span><br></pre></td></tr></table></figure>

<p>这时你大概率会遇到以下问题：</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.fail1.png"></p>
<p>有人说将 clean 下的 -rm -fR $(BUILD_DIR) 改成 -del &#x2F;q $(BUILD_DIR) 就好了，实测并不管用。</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.fail2.png"></p>
<p>只有显式地将 SHELL 指定为 cmd 才行（在 makefile 中添加一条语句）：</p>
<p><img src="/sulfurandcu.io/clo2c1l6400c71wrq3816hypq/make.clean.shell.png"></p>
<h2 id="scons"><a href="#scons" class="headerlink" title="scons"></a>scons</h2><ul>
<li>install <a href="https://www.python.org/downloads/">python</a></li>
<li>install pip (python get-pip.py)</li>
<li>install scons (python -m pip install scons&#x3D;&#x3D;3.1.2)</li>
<li>install pywin32 (support scons -j16) (python -m pip install pywin32)</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python/Scripts/scons.bat <span class="comment"># scons.bat is not necessary, just run scons directly.</span></span><br><span class="line">    python/Scripts/scons <span class="comment"># start</span></span><br><span class="line">        prepare</span><br><span class="line">        call SCons.Script.main() <span class="comment"># this does all the work, and calls sys.exit with the proper exit status when done.</span></span><br><span class="line">            scons: reading SConscript files.</span><br><span class="line">                &lt;rtconfig.py&gt;</span><br><span class="line">                &lt;rtconfig.py&gt;</span><br><span class="line">                &lt;sconstruct&gt;</span><br><span class="line">                    &lt;PrepareBuilding()&gt;</span><br><span class="line">                        <span class="comment"># bsp</span></span><br><span class="line">                        &lt;bsp.SConscript&gt; <span class="comment"># 逐级遍历当前路径下所有子目录中的 SConscript 脚本</span></span><br><span class="line">                            &lt;application.SConscript&gt;</span><br><span class="line">                            &lt;application.SConscript&gt;</span><br><span class="line">                            &lt;board.SConscript&gt;</span><br><span class="line">                            &lt;board.SConscript&gt;</span><br><span class="line">                            &lt;package.SConscript&gt;</span><br><span class="line">                            &lt;package.SConscript&gt;</span><br><span class="line">                            &lt;underlayer.SConscript&gt;</span><br><span class="line">                            &lt;underlayer.SConscript&gt;</span><br><span class="line">                        &lt;bsp.SConscript&gt;</span><br><span class="line">                        <span class="comment"># kernel</span></span><br><span class="line">                        &lt;rtt.src.SConscript&gt;</span><br><span class="line">                        &lt;rtt.src.SConscript&gt;</span><br><span class="line">                        <span class="comment"># libcpu</span></span><br><span class="line">                        &lt;rtt.libcpu.SConscript&gt;</span><br><span class="line">                        &lt;rtt.libcpu.SConscript&gt;</span><br><span class="line">                        <span class="comment"># components</span></span><br><span class="line">                        &lt;rtt.components.SConscript&gt;</span><br><span class="line">                        &lt;rtt.components.SConscript&gt;</span><br><span class="line">                    &lt;PrepareBuilding()&gt;</span><br><span class="line">                    &lt;SConscript(underlayer/chips/chip_drv)&gt;</span><br><span class="line">                    &lt;SConscript(underlayer/chips/chip_drv)&gt;</span><br><span class="line">                    &lt;SConscript(underlayer/chips/hal_drv)&gt;</span><br><span class="line">                    &lt;SConscript(underlayer/chips/hal_drv)&gt;</span><br><span class="line">                    &lt;SConscript(underlayer/chips/components)&gt;</span><br><span class="line">                    &lt;SConscript(underlayer/chips/components)&gt;</span><br><span class="line">                    &lt;DoBuilding()&gt;</span><br><span class="line">                &lt;sconstruct&gt;</span><br><span class="line">            scons: done reading SConscript files.</span><br><span class="line"></span><br><span class="line">            scons: Building targets</span><br><span class="line">            scons: building associated VariantDir targets: build/gcc/obj</span><br><span class="line">                LINK rtthread.elf</span><br><span class="line">                arm-none-eabi-objcopy -O ihex rtthread.elf ./build/gcc/<span class="built_in">bin</span>/rtthread.<span class="built_in">hex</span></span><br><span class="line">            scons: done building targets. call exit() somewhere.</span><br><span class="line">    python/Scripts/scons <span class="comment"># exit</span></span><br></pre></td></tr></table></figure>

<p>$ scons.bat<br>scons: Reading SConscript files …###############################<br>SConstruct enter !!!.#######################################<br>SDK_ROOT: E:\codespace\SPL1050\SPL1050V240112_vendor-Release_1.0.0.1_modified</p>
<p>SConstruct building start !!!</p>
<p>SConstruct exit !!!.#######################################<br>scons: done reading SConscript files.#######################################</p>
<p>scons: Building targets …<br>scons: building associated VariantDir targets: build\gcc\obj<br>LINK rtthread.elf<br>Memory region         Used Size  Region Size  %age Used<br>      FalPartRAM:        1504 B         4 KB     36.72%<br>             ROM:      384448 B       380 KB     98.80%<br>             RAM:      200456 B       256 KB     76.47%<br>        Heap_RAM:          0 GB       127 KB      0.00%<br>FalPartTableInFlash:        1504 B         4 KB     36.72%<br>       CopyTable:          20 B         1 KB      1.95%<br>     CodeInFlash:      492096 B       768 KB     62.57%<br>          phycfg:          0 GB         4 KB      0.00%<br>arm-none-eabi-size rtthread.elf<br>   text    data     bss     dec     hex filename<br> 878048    8540  191936 1078524  1074fc rtthread.elf<br>arm-none-eabi-objcopy -O ihex rtthread.elf .&#x2F;build&#x2F;gcc&#x2F;bin&#x2F;rtthread.hex<br>scons: done building targets.</p>
<h3 id="env-中突然不能编译的问题"><a href="#env-中突然不能编译的问题" class="headerlink" title="env 中突然不能编译的问题"></a>env 中突然不能编译的问题</h3><p>使用自己安装的 scons.bat 编译后，再用 env 中的 scons 编译有可能会报错，删除 <code>.sconsign.dblite</code> 后再编即可。</p>
<h3 id="交叉编译工具链的路径问题"><a href="#交叉编译工具链的路径问题" class="headerlink" title="交叉编译工具链的路径问题"></a>交叉编译工具链的路径问题</h3><p>多人开发时，每个人的交叉编译工具链的安装位置都不同，这样就不能把绝对路径写入到 rtconfig.py 中并提交至代码仓库。既然绝对路径不行，那相对路径可以吗？也行不通，使用相对路径意味着交叉编译工具链也要同步提交至代码仓库，而 arm-none-eabi 的体积是比较大的，所以说我们通常不会这么做，那应该怎样优雅地解决这个问题呢？请继续往下看：</p>
<p>只需要在 rtconfig.py 中添加以下代码即可解决！</p>
<figure class="highlight py"><figcaption><span>rtconfig.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line"><span class="comment"># toolchains path</span></span><br><span class="line">cfg_path = <span class="string">r&#x27;rtconfig.ini&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(cfg_path):</span><br><span class="line">    file = <span class="built_in">open</span>(cfg_path, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;# do not commit this file to the repository.\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;[COMPILER] # gcc, iar, mdk\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;COMPILER = gcc\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;GCC_PATH = do not commit this file to svn. replace with your arm-none-eabi-gcc path here in \&#x27;rtconfig.ini\&#x27;. (i.e. d:\\arm-none-eabi-10.3-2021.10\\bin)\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;IAR_PATH =\n&quot;</span>)</span><br><span class="line">    file.write(<span class="string">&quot;MDK_PATH =\n&quot;</span>)</span><br><span class="line">    file.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rtconfig.ini not exists! but now it should have been generated automatically, you need to fill in some informations. greetings from liujitong.&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line">cfg = configparser.ConfigParser()</span><br><span class="line">cfg.read(cfg_path)</span><br><span class="line">CROSS_TOOL = cfg[<span class="string">&quot;COMPILER&quot;</span>][<span class="string">&quot;COMPILER&quot;</span>]</span><br><span class="line">gcc_path = cfg[<span class="string">&quot;COMPILER&quot;</span>][<span class="string">&quot;GCC_PATH&quot;</span>]</span><br><span class="line">iar_path = cfg[<span class="string">&quot;COMPILER&quot;</span>][<span class="string">&quot;IAR_PATH&quot;</span>]</span><br><span class="line">mdk_path = cfg[<span class="string">&quot;COMPILER&quot;</span>][<span class="string">&quot;MDK_PATH&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>其逻辑为：</p>
<p>1. 检查 rtconfig.ini 是否存在。<br>2. 如果不存在则自动创建一个 rtconfig.ini 模板文件，并提醒开发人员进行修改。<br>3. 如果存在则从中提取交叉编译工具链的路径信息。</p>
<p>下面是自动生成的 rtconfig.ini 模板</p>
<figure class="highlight ini"><figcaption><span>rtconfig.ini</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># do not commit this file to the repository.</span></span><br><span class="line"><span class="section">[COMPILER]</span> <span class="comment"># gcc, iar, mdk</span></span><br><span class="line"><span class="attr">COMPILER</span> = gcc</span><br><span class="line"><span class="attr">GCC_PATH</span> = do not commit this file to svn. replace with your arm-none-eabi-gcc path here in <span class="string">&#x27;rtconfig.ini&#x27;</span>. (i.e. d:\\arm-none-eabi-<span class="number">10.3</span>-<span class="number">2021.10</span>\\bin)</span><br><span class="line"><span class="attr">IAR_PATH</span> =</span><br><span class="line">MDK_PATH =</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－GCC.ARM（#04）快捷任务</title>
    <url>/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz.html</url>
    <content><![CDATA[<hr>
<ul>
<li>tasks.json</li>
</ul>
<hr>
<span id="more"></span>

<p>通过 makefile 我们将海量的指令精简至一条 make+ 指令，但是我比较懒，一条指令都不想敲。😎</p>
<p>1. 在工程目录下的 .vscode 目录中新建 tasks.json 文件并填入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;编译（build）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;清除（clean）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make clean&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;烧录（write）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;烧录（write.openocd）&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cd project/GCC | mingw32-make write.openocd&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line"></span><br><span class="line">            ],</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info no-icon"><p>在 cmd 中使用 “|” 连接两条指令，在 powershell 中使用 “;” 连接两条指令。</p>
</div>

<p>2. 找到菜单栏依次点击 Terminal -&gt; RunTask 然后选择：</p>
<ul>
<li>编译（build）</li>
<li>清除（clean）</li>
<li>烧录（write）</li>
<li>烧录（write.openocd）</li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6700cd1wrqgjn53mgz/task.json.png"></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>集成开发环境－GCC.ARM（#05）程序调试</title>
    <url>/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey.html</url>
    <content><![CDATA[<hr>
<ul>
<li>laugch.json</li>
</ul>
<hr>
<span id="more"></span>

<p>1. 在工程目录下的 .vscode 目录中新建 laugch.json 文件并填入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@JLinkGDBServerCL.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;jlink&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;device&quot;: &quot;STM32F103CB&quot;,</span><br><span class="line">            &quot;interface&quot;: &quot;swd&quot;,</span><br><span class="line">            &quot;serverArgs&quot;: [</span><br><span class="line">                // &quot;-gui&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@OpenOCD.exe&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;openocd&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;showDevDebugOutput&quot;: &quot;none&quot;,</span><br><span class="line">            &quot;configFiles&quot;: [</span><br><span class="line">                &quot;openocd/jlink-swd.cfg&quot;,</span><br><span class="line">                &quot;openocd/stm32f1x.cfg&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug@RemoteServer(GDBServer/JLinkGDBServer)&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cortex-debug&quot;,</span><br><span class="line">            &quot;servertype&quot;: &quot;external&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">            &quot;cwd&quot;:&quot;$&#123;workspaceRoot&#125;/project/GCC&quot;,</span><br><span class="line">            &quot;executable&quot;: &quot;./build/main.elf&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbTarget&quot;: &quot;192.168.1.1:2331&quot;,</span><br><span class="line"></span><br><span class="line">            &quot;gdbPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin/arm-none-eabi-gdb.exe&quot;,</span><br><span class="line">            &quot;armToolchainPath&quot;: &quot;D:/develop.r.0/gcc-arm-none-eabi-10.3-2021.10/bin&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2. 进入侧边栏中的 RunAndDebug 然后选择</p>
<ul>
<li>Debug@JLinkGDBServerCL.exe</li>
<li>Debug@OpenOCD.exe</li>
<li>Debug@RemoteServer(GDBServer&#x2F;JLinkGDBServer)</li>
</ul>
<p><img src="/sulfurandcu.io/clo2c1l6600cb1wrqewhnb8ey/launch.json.png"></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>集成开发环境</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#00）目录索引</title>
    <url>/sulfurandcu.io/clnyhr2n2004t10rq7rdi2ftx.html</url>
    <content><![CDATA[<hr>
<p><a href="/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html">嵌入式 IAP 升级功能（#01）基础概念</a><br><a href="/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html">嵌入式 IAP 升级功能（#02）升级方案</a><br><a href="/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html">嵌入式 IAP 升级功能（#03）流程设计</a><br><a href="/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html">嵌入式 IAP 升级功能（#04）技术细节</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升级功能（#05）增量升级</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升级功能（#06）差分还原 hpatchlite 移植</a><br><a href="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html">嵌入式 IAP 升级功能（#07）压缩解压 tinyuztool 移植</a><br><a href="/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html">嵌入式 IAP 升级功能（#08）引导程序 bootloader 升级</a></p>
<hr>
<span id="more"></span>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://itexp.blog.csdn.net/article/details/83793309">https://itexp.blog.csdn.net/article/details/83793309</a></p>
<p><a href="https://blog.csdn.net/qq_24130227/article/details/123752964">https://blog.csdn.net/qq_24130227/article/details/123752964</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108379324">https://blog.csdn.net/qq_24130227/article/details/108379324</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/113003329">https://blog.csdn.net/qq_24130227/article/details/113003329</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/120061873">https://blog.csdn.net/qq_24130227/article/details/120061873</a><br><a href="https://blog.csdn.net/qq_24130227/article/details/108427842">https://blog.csdn.net/qq_24130227/article/details/108427842</a></p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>单片机</tag>
        <tag>iap</tag>
        <tag>bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#01）基础概念</title>
    <url>/sulfurandcu.io/clnyhr2n2004x10rq71zl3lqj.html</url>
    <content><![CDATA[<center>传统编程方式</center>

<pre class="mermaid">
flowchart LR
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A(先取下芯片)---&gt;B(再烧录程序)---&gt;C(后装回板卡)
</pre>

<center>现代编程方式</center>

<pre class="mermaid">
flowchart LR
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A(&quot;在电路编程&lt;br&gt;(ＩＣＰ)&quot;)---&gt;B(&quot;在系统编程&lt;br&gt;(ＩＳＰ)&quot;)---&gt;C(&quot;在应用编程&lt;br&gt;(ＩＡＰ)&quot;)
</pre>

<span id="more"></span>

<h2 id="传统编程方式"><a href="#传统编程方式" class="headerlink" title="传统编程方式"></a>传统编程方式</h2><p>传统编程方式是先将程序烧录至主控芯片中再焊接到电路板上。</p>
<p><strong>开发阶段</strong></p>
<ul>
<li>➀ 从电路板上取下芯片</li>
<li>➁ 使用烧录器烧写程序</li>
<li>➂ 将芯片装回至电路板</li>
</ul>
<p><strong>量产阶段</strong></p>
<ul>
<li>➀ 从 tray 盘取出芯片</li>
<li>➁ 使用烧录器烧写程序</li>
<li>➂ 将芯片放回 tray 盘</li>
</ul>
<p><strong>维护阶段</strong></p>
<ul>
<li>➀ 从电路板上拆下芯片</li>
<li>➁ 使用烧录器烧写程序</li>
<li>➂ 将芯片焊回至电路板</li>
</ul>
<h2 id="现代编程方式"><a href="#现代编程方式" class="headerlink" title="现代编程方式"></a>现代编程方式</h2><p>现代编程方式可以直接进行板上烧录，不用再取下芯片放到专用的烧录器上烧录，极大地提高了开发、生产以及维护效率。</p>
<p>现代编程方式又可分为：</p>
<ul>
<li>在电路编程 ICP (Circuit)</li>
<li>在系统编程 ISP (System)</li>
<li>在应用编程 IAP (Application)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编程方式</th>
<th align="center">在电路编程</th>
<th align="center">在系统编程</th>
<th align="center">在应用编程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">核心思想</td>
<td align="center">借助外部烧录器<br>通过JTAG&#x2F;SWD接口<br>实现在电路编程</td>
<td align="center">借助芯片内部<br>固化的引导程序和BOOT引脚<br>以及片上接口<br>实现在系统编程</td>
<td align="center">借助用户自己<br>编写的引导程序、应用程序<br>以及片上接口、板上接口<br>实现在应用编程</td>
</tr>
<tr>
<td align="center">引导程序</td>
<td align="center">不需要</td>
<td align="center">需要芯片厂家编写<br>并固化到某一地址空间</td>
<td align="center">需要用户自己编写<br>并烧录至内部flash存储器</td>
</tr>
<tr>
<td align="center">进入方式</td>
<td align="center">随时待命</td>
<td align="center">需要更改BOOT引脚的电平<br>然后硬件复位<br>进入内部固化的引导程序</td>
<td align="center">随时待命</td>
</tr>
<tr>
<td align="center">配套软件</td>
<td align="center">烧录软件</td>
<td align="center">芯片厂家提供的<br>上位机ISP编程软件</td>
<td align="center">用户自己开发的数据传输软件</td>
</tr>
<tr>
<td align="center">通信接口</td>
<td align="center">JTAG&#x2F;SWD</td>
<td align="center">取决于芯片中固化的引导程序<br>URT&#x2F;SPI&#x2F;IIC&#x2F;CAN&#x2F;USB</td>
<td align="center">理论上可以支持任意接口<br>URT&#x2F;SPI&#x2F;IIC<br>485&#x2F;CAN&#x2F;USB<br>WiFi&#x2F;BLE&#x2F;IrDA<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td>
</tr>
<tr>
<td align="center">程序升级<br>是否需要<br>拆装芯片</td>
<td align="center">不需要<br>拆装芯片</td>
<td align="center">不需要<br>拆装芯片</td>
<td align="center">不需要<br>拆装芯片</td>
</tr>
<tr>
<td align="center">程序升级<br>是否需要<br>拆装外壳</td>
<td align="center">需要<br>拆开设备外壳</td>
<td align="center">通信接口完备的情况下<br>不需要<br>拆开设备外壳<br>485&#x2F;CAN&#x2F;USB</td>
<td align="center">通信接口完备的情况下<br>不需要<br>拆开设备外壳<br>485&#x2F;CAN&#x2F;USB&#x2F;WiFi&#x2F;BLE&#x2F;IrDA</td>
</tr>
<tr>
<td align="center">程序升级<br>是否需要<br>前往现场</td>
<td align="center">需要<br>前往设备安装现场</td>
<td align="center">需要<br>前往设备安装现场</td>
<td align="center">远程通信功能完备的情况下<br>不需要<br>前往设备安装现场<br>PLC&#x2F;ETH&#x2F;4G&#x2F;5G&#x2F;NBIoT</td>
</tr>
</tbody></table>
<div class="note info no-icon"><p>ICP 主要是在开发阶段使用，其烧录速度是 ISP 和 IAP 所无法比拟的。</p>
</div>

<div class="note info no-icon"><p>IAP 与 ISP 类似，都有 bootloader 引导程序，因此无需使用烧录器。二者的区别在于，ISP 的引导程序由芯片厂家编写，比较简单，无法实现用户的定制化需求；而 IAP 的引导程序是由用户自己实现，可以根据需求自行修改。另外 ISP 进入 boot 程序的方式是通过更改 BOOT 引脚的电平；而 IAP 则是从用户程序中通过软件复位或者跳转的方式直接进入 bootloader 程序，因此相较于 ISP 来说会更加灵活。</p>
</div>

<div class="note info no-icon"><p>通过 WiFi&#x2F;BLE&#x2F;4G&#x2F;5G&#x2F;NBIoT 等无线通信技术实现 IAP 功能的方案也被称作 OTA 空中下载技术。</p>
</div>

<table>
<thead>
<tr>
<th align="center">BOOT1</th>
<th align="center">BOOT0</th>
<th align="center">BOOT MODE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">0</td>
<td align="center">boot from 0x08000000 : main memory</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">boot from 0x1FFF0000 : boot memory</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">boot from 0x20000000 : sram memory</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#02）升级方案</title>
    <url>/sulfurandcu.io/clnyhr2n3004y10rq322c66uu.html</url>
    <content><![CDATA[<center>which one is better?</center>
<br>

<pre class="mermaid">
flowchart LR
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A(在引导程序中集成通信协议栈与解压还原算法)~~~B(在应用程序中集成通信协议栈与解压还原算法)
</pre>

<span id="more"></span>

<h2 id="思路（-1）：引导程序主导"><a href="#思路（-1）：引导程序主导" class="headerlink" title="思路（#1）：引导程序主导"></a>思路（#1）：引导程序主导</h2><table>
<thead>
<tr>
<th align="center">具体分工</th>
<th align="center">引导程序</th>
<th align="center">应用程序</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">编程操作</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">通信协议</td>
<td align="center">完备的通信协议栈</td>
<td align="center">　　　　　　　　</td>
</tr>
<tr>
<td align="center">文件解压</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">差分还原</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<div class="note success no-icon"><p><strong>优点</strong>：设备中没有应用程序或应用程序异常时也可以进行 IAP 升级。</p>
</div>

<div class="note danger no-icon"><p><strong>缺点</strong>：在引导程序中集成通信协议栈、文件解压、差分还原等功能，会导致其代码量较大。</p>
</div>

<h2 id="思路（-2）：应用程序主导"><a href="#思路（-2）：应用程序主导" class="headerlink" title="思路（#2）：应用程序主导"></a>思路（#2）：应用程序主导</h2><table>
<thead>
<tr>
<th align="center">具体分工</th>
<th align="center">引导程序</th>
<th align="center">应用程序</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">编程操作</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">通信协议</td>
<td align="center">　　　　　　　　</td>
<td align="center">完备的通信协议栈</td>
</tr>
<tr>
<td align="center">文件解压</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">差分还原</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody>
</table>

<div class="note success no-icon"><p><strong>优点</strong>：引导程序比较简单，占用空间小，方便维护。</p>
</div>

<div class="note danger no-icon"><p><strong>缺点</strong>：设备中没有应用程序或应用程序异常时无法进行 IAP 升级。</p>
</div>

<h2 id="思路（-3）：两者各取所长"><a href="#思路（-3）：两者各取所长" class="headerlink" title="思路（#3）：两者各取所长"></a>思路（#3）：两者各取所长</h2><table>
<thead>
<tr>
<th align="center">具体分工</th>
<th align="center">引导程序</th>
<th align="center">应用程序</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">编程操作</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">通信协议</td>
<td align="center">基础的通信协议栈</td>
<td align="center">完备的通信协议栈</td>
</tr>
<tr>
<td align="center">文件解压</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">差分还原</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody>
</table>

<div class="note success no-icon"><p><strong>特点</strong>：在引导程序中集成基础的通信协议栈，代码量能接受，应用程序异常时也能在线升级。</p>
</div>

<div class="note success no-icon"><p><strong>特点</strong>：在应用程序中集成完整的通信协议栈、文件解压、差分还原等功能，功能完备。</p>
</div>

<h2 id="方案（-0）"><a href="#方案（-0）" class="headerlink" title="方案（#0）"></a>方案（#0）</h2><table>
<thead>
<tr>
<th align="center">内部flash存储空间划分</th>
<th align="center">内部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>
    <td align="center">中断向量表</td>
</tr>
<tr>
    <td align="center">引导程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center">参数数据存储区</td>
    <td align="center">掉电不丢失的系统参数</td>
</tr>
</tbody>
</table>

<p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除应用程序存储区，然后等待接收新版应用程序（直接写入到升级文件存储区），等接收完毕且校验无误后跳转至应用程序，至此升级完成。</p>
<h2 id="方案（-1）"><a href="#方案（-1）" class="headerlink" title="方案（#1）"></a>方案（#1）</h2><table>
<thead>
<tr>
<th align="center">内部flash存储空间划分</th>
<th align="center">内部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>
    <td align="center">中断向量表</td>
</tr>
<tr>
    <td align="center">引导程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">升级数据存储区</td>
    <td align="center">解压后的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的压缩文件</td>
</tr>
<tr>
    <td align="center">参数数据存储区</td>
    <td align="center">掉电不丢失的系统参数</td>
</tr>
</tbody>
</table>

<p>或</p>
<table>
<thead>
<tr>
<th align="center">内部flash存储空间划分</th>
<th align="center">内部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>
    <td align="center">中断向量表</td>
</tr>
<tr>
    <td align="center">引导程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center">参数数据存储区</td>
    <td align="center">掉电不丢失的系统参数</td>
</tr>
</tbody>
<thead>
<tr>
<th align="center">外部flash存储空间划分</th>
<th align="center">外部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">升级数据存储区</td>
    <td align="center">解压后的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的压缩文件</td>
</tr>
</tbody>
</table>

<h3 id="思路（-1）"><a href="#思路（-1）" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除旧版应用程序，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至应用程序存储区，最后跳转至应用程序，至此升级完成。</p>
<h3 id="思路（-2）"><a href="#思路（-2）" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至新版程序存储区，重启进入或跳转进入引导程序。进入引导程序后对新版程序进行二次校验，校验通过后擦除旧版应用程序，然后将新版程序存储区中的新版应用程序拷贝至应用程序存储区，最后跳转至应用程序，至此升级完成。</p>
<h3 id="思路（-3）"><a href="#思路（-3）" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至新版程序存储区，重启进入或跳转进入引导程序。进入引导程序后对新版程序进行二次校验，校验通过后擦除旧版应用程序，然后将新版程序存储区中的新版应用程序拷贝至应用程序存储区，最后跳转至应用程序，至此升级完成。</p>
<p>抹除应用程序有效标识后，重启进入或跳转进入引导程序。进入引导程序后等待通信，若收到升级指令，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除旧版应用程序，然后将升级文件存储区中的新版应用程序拷贝（不支持解压和差分还原）至应用程序存储区，最后跳转至应用程序，至此升级完成。</p>
<h2 id="方案（-2）"><a href="#方案（-2）" class="headerlink" title="方案（#2）"></a>方案（#2）</h2><table>
<thead>
<tr>
<th align="center">内部flash存储空间划分</th>
<th align="center">内部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>
    <td align="center">中断向量表</td>
</tr>
<tr>
    <td align="center">引导程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区<br>（1）</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区<br>（2）</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center">参数数据存储区</td>
    <td align="center">掉电不丢失的系统参数</td>
</tr>
</tbody>
</table>

<h3 id="思路（-1）-1"><a href="#思路（-1）-1" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p>
<h3 id="思路（-2）-1"><a href="#思路（-2）-1" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>设备收到升级指令后，首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p>
<h3 id="思路（-3）-1"><a href="#思路（-3）-1" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>设备收到升级指令后，首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p>
<p>抹除应用程序有效标识后，重启进入或跳转进入引导程序。进入引导程序后等待通信，若收到升级指令，首先擦除备份应用存储区，然后等待接收新版应用程序（直接写入到备份应用存储区），等接收完毕且校验无误后，翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p>
<h2 id="方案（-3）"><a href="#方案（-3）" class="headerlink" title="方案（#3）"></a>方案（#3）</h2><table>
<thead>
<tr>
<th align="center">内部flash存储空间划分</th>
<th align="center">内部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>
    <td align="center">中断向量表</td>
</tr>
<tr>
    <td align="center">引导程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区<br>（1）</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区<br>（2）</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">升级数据存储区</td>
    <td align="center">解压后的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的压缩文件</td>
</tr>
<tr>
    <td align="center">参数数据存储区</td>
    <td align="center">掉电不丢失的系统参数</td>
</tr>
</tbody>
</table>

<p>或</p>
<table>
<thead>
<tr>
<th align="center">内部flash存储空间划分</th>
<th align="center">内部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">引导程序存储区<br>bootloader</td>
    <td align="center">中断向量表</td>
</tr>
<tr>
    <td align="center">引导程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区<br>（1）</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center" rowspan="2">应用程序存储区<br>（2）</td>
    <td align="center">重定向的中断向量表</td>
</tr>
<tr>
    <td align="center">应用程序</td>
</tr>
<tr>
    <td align="center">参数数据存储区</td>
    <td align="center">掉电不丢失的系统参数</td>
</tr>
</tbody>
<thead>
<tr>
<th align="center">外部flash存储空间划分</th>
<th align="center">外部flash存储空间细分</th>
</tr>
</thead>
<tbody>
<tr>
    <td align="center" rowspan="2">升级数据存储区</td>
    <td align="center">解压后的新版程序</td>
</tr>
<tr>
    <td align="center">接收到的压缩文件</td>
</tr>
</tbody>
</table>

<h3 id="思路（-1）-2"><a href="#思路（-1）-2" class="headerlink" title="思路（#1）"></a>思路（#1）</h3><p>设备收到升级指令后，重启进入或跳转进入引导程序。进入引导程序后首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至备份应用存储区，最后翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p>
<h3 id="思路（-2）-2"><a href="#思路（-2）-2" class="headerlink" title="思路（#2）"></a>思路（#2）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至备份应用存储区，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p>
<h3 id="思路（-3）-2"><a href="#思路（-3）-2" class="headerlink" title="思路（#3）"></a>思路（#3）</h3><p>设备收到升级指令后，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝&#x2F;解压&#x2F;差分还原至备份应用存储区，翻转APP1与APP2的有效标识，重启进入或跳转进入引导程序，在引导程序中根据标识跳转至正确的应用程序，至此升级完成。</p>
<p>抹除应用程序有效标识后，重启进入或跳转进入引导程序。进入引导程序后等待通信，若收到升级指令，首先擦除升级文件存储区，然后等待接收新版应用程序（暂时存放至升级文件存储区），等接收完毕且校验无误后，擦除备份应用存储区，然后将升级文件存储区中的新版应用程序拷贝（不支持解压和差分还原）至备份应用存储区，最后翻转APP1与APP2的有效标识，并根据标识跳转至正确的应用程序，至此升级完成。</p>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#03）流程设计</title>
    <url>/sulfurandcu.io/clnyhr2n3005010rqf3gcgp39.html</url>
    <content><![CDATA[<pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
A1(引导程序之流程)--&gt;B1(......)--&gt;C1(跳转至应用程序)
A2(应用程序之流程)--&gt;B2(......)--&gt;C2(跳转至引导程序)
</pre>

<span id="more"></span>

<h2 id="引导程序流程"><a href="#引导程序流程" class="headerlink" title="引导程序流程"></a>引导程序流程</h2><p>引导程序的设计方案我知道有两种：</p>
<ul>
<li>立即跳转方案</li>
<li>延时跳转方案</li>
</ul>
<p>立即跳转方案在判断出应用程序有效之后会立即执行跳转操作，该方案适用于对启动时间要求比较高的产品。延时跳转方案则是先在引导程序中等待一段时间，在这段时间内如果没有任何请求则时间到了之后会自动跳转至应用程序，否则将停留在引导程序中。</p>
<h3 id="立即跳转方案"><a href="#立即跳转方案" class="headerlink" title="立即跳转方案"></a>立即跳转方案</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
PowerReset(设备上电复位)--&gt;IapStart(引导程序开始)--&gt;IapCheckApp[检查应用程序有效标识]--&gt;IapIsAppValid{是否有效}
IapIsAppValid--是--&gt;IapJumpToApp[跳转进入应用程序]--&gt;IapOver(引导程序结束)
IapIsAppValid--否--&gt;IapRemap[重定向中断向量表]--&gt;IapInit[配置相关外设]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升级数据}
IapIsHaveUpdateData--否--&gt;IapBeforeJump
IapIsHaveUpdateData--是--&gt;IapDoUpdate[执行升级操作]---&gt;IapEraseUpdateData[擦除升级数据]--&gt;IapIsUpdateSucc{升级成功}
IapIsUpdateSucc--是---&gt;IapSetAppValid[修改应用程序有效标识：有效]--&gt;IapBeforeJump[关闭外设和中断]--&gt;IapJumpToApp
IapIsUpdateSucc--否--&gt;IapIsAppErased{应用程序已损毁}
IapIsAppErased--否--&gt;IapBeforeJump
IapIsAppErased--是&lt;br&gt;留在引导程序中--&gt;IapComm[执行通信任务]--&gt;IapIsRecvDone{收到升级数据}
IapIsRecvDone--否--&gt;IapComm
IapIsRecvDone--是--&gt;IapDoUpdate
</pre>

<h3 id="延时跳转方案"><a href="#延时跳转方案" class="headerlink" title="延时跳转方案"></a>延时跳转方案</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
PowerReset(设备上电复位)--&gt;IapStart(引导程序开始)--&gt;IapCheckApp[检查应用程序有效标识]--&gt;IapIsAppValid{是否有效}
IapIsAppValid--是--&gt;IapWait{计数超时&lt;br&gt;（延时跳转）}
IapWait--否--&gt;IapWait
IapWait--是----------&gt;IapJumpToApp[跳转进入应用程序]--&gt;IapOver(引导程序结束)
IapIsAppValid--否--&gt;IapRemap[重定向中断向量表]--&gt;IapInit[配置相关外设]--&gt;IapIsHaveUpdateData{是否存在&lt;br&gt;升级数据}
IapIsHaveUpdateData--否--&gt;IapBeforeJump
IapIsHaveUpdateData--是--&gt;IapDoUpdate[执行升级操作]---&gt;IapEraseUpdateData[擦除升级数据]--&gt;IapIsUpdateSucc{升级成功}
IapIsUpdateSucc--是---&gt;IapSetAppValid[修改应用程序有效标识：有效]--&gt;IapBeforeJump[关闭外设和中断]--&gt;IapJumpToApp
IapIsUpdateSucc--否--&gt;IapIsAppErased{应用程序已损毁}
IapIsAppErased--否--&gt;IapBeforeJump
IapIsAppErased--是&lt;br&gt;留在引导程序中--&gt;IapComm[执行通信任务]--&gt;IapIsRecvDone{收到升级数据}
IapIsRecvDone--否--&gt;IapComm
IapIsRecvDone--是--&gt;IapDoUpdate
</pre>

<h2 id="应用程序流程"><a href="#应用程序流程" class="headerlink" title="应用程序流程"></a>应用程序流程</h2><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
AppStart(应用程序开始)--&gt;AppRemap[重定向中断向量表]--&gt;AppInit[配置相关外设]--&gt;AppTask[执行应用功能]--&gt;AppComm[执行通信任务]--&gt;AppIsRecvDone{收到升级数据}
AppIsRecvDone--否--&gt;AppTask
AppIsRecvDone--是--&gt;AppSetAppInvalid[修改应用程序有效标识：无效]--&gt;AppBeforeJump[关闭外设和中断]--&gt;AppJumpToIap[重启进入引导程序｜跳转进入引导程序]--&gt;AppOver(应用程序结束)
</pre>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#04）技术细节</title>
    <url>/sulfurandcu.io/clnyhr2n4005410rqfyjmedv1.html</url>
    <content><![CDATA[<p>分散加载、中断向量表重定向</p>
<h2 id="调整大小程序时要修改哪些配置？"><a href="#调整大小程序时要修改哪些配置？" class="headerlink" title="调整大小程序时要修改哪些配置？"></a>调整大小程序时要修改哪些配置？</h2><p>➀ 修改 main.sct 分散加载文件。</p>
<p>➁ 修改 ConfigMCU 中大小程序的起始地址及空间大小。</p>
<p>➂ 修改 iap: system_mcumodel.c 中 VECT_TAB_OFFSET 的值（等于小程序的起始地址）。</p>
<p>➃ 修改 app: system_mcumodel.c 中 VECT_TAB_OFFSET 的值（等于大程序的起始地址）。</p>
<h2 id="分散加载"><a href="#分散加载" class="headerlink" title="分散加载"></a>分散加载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- module_select_pattern</span><br><span class="line">  - *</span><br><span class="line">  - *.o</span><br><span class="line">  - .ANY</span><br><span class="line"></span><br><span class="line">- module_select_pattern (input_section_selector)</span><br><span class="line">- module_select_pattern (input_section_selector, input_section_selector, ...)</span><br><span class="line">  - +input_section_attr</span><br><span class="line">    - * (+RO-CODE)</span><br><span class="line">    - * (+RO-DATA)</span><br><span class="line">    - * (+RO)</span><br><span class="line">    - * (+RW-DATA)</span><br><span class="line">    - * (+RW-CODE)</span><br><span class="line">    - * (+RW)</span><br><span class="line">    - * (+XO)</span><br><span class="line">    - * (+ZI)</span><br><span class="line">    - * (+ENTRY)</span><br><span class="line">    -</span><br><span class="line">    - * (+CODE)</span><br><span class="line">    - * (+CONST)</span><br><span class="line">    - * (+TEXT)</span><br><span class="line">    - * (+DATA)</span><br><span class="line">    - * (+BSS)</span><br><span class="line">    -</span><br><span class="line">    - * (+FIRST)</span><br><span class="line">    - * (+LAST)</span><br><span class="line">  - input_section_pattern</span><br><span class="line">    - * (*app_info)</span><br><span class="line">  - input_symbol_pattern</span><br><span class="line">  - section_properties</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#05）增量升级</title>
    <url>/sulfurandcu.io/clnyhr2n4005710rqfv00ckub.html</url>
    <content><![CDATA[<p>全量升级由于要传输新版程序的完整镜像，因此升级时间通常较长，升级失败的概率也更大。那么能不能只传送差异数据呢？答案是可以。这种技术被称作增量升级&#x2F;差量升级&#x2F;差分升级。</p>
<p>常见的方案有：</p>
<ul>
<li>bsdiff&#x2F;bspatch + quicklz</li>
<li>hdifflite&#x2F;hpatchlite + tinyuz</li>
</ul>
<div class="note info no-icon"><p>不过 bsdiff + quicklz 方案的内存开销太大，因此不建议使用。</p>
</div>

<h2 id="全量升级-amp-增量升级"><a href="#全量升级-amp-增量升级" class="headerlink" title="全量升级 &amp; 增量升级"></a>全量升级 &amp; 增量升级</h2><p>增量升级确实降低了传输过程中的数据量，但也带来了版本管理复杂的问题，所以说不能因为有了增量升级，全量升级就不用了。</p>
<p>以往我们做全量升级的时候没有引入压缩技术，在移植 hdiff&#x2F;hpatchlite 的时候我发现，hdiff 生成的差异文件不比原文件小多少，但是其可压缩性非常高，这样就得把解压算法也移植进来。既然解压算法都已经有了，不把增量升级也压缩一下，那岂不是很浪费？</p>
<table>
<tbody>
<tr>
    <td align="center" rowspan="2">全量升级</td>
    <td align="center">未经压缩的新版程序</td>
    <td align="center">（✘）</td>
</tr>
<tr>
    <td align="center">经过压缩的新版程序</td>
    <td align="center">（✔）</td>
</tr>
<tr>
    <td align="center" rowspan="2">增量升级</td>
    <td align="center">未经压缩的差异文件</td>
    <td align="center">（✘）</td>
</tr>
<tr>
    <td align="center">经过压缩的差异文件</td>
    <td align="center">（✔）</td>
</tr>
</tbody>
</table>

<span id="more"></span>

<h2 id="升级包头"><a href="#升级包头" class="headerlink" title="升级包头"></a>升级包头</h2><p>在线升级无非就是把新程序或者更新补丁发送给设备，设备收到后进行升级的过程。</p>
<p>为了保证升级能够顺利进行，除了新程序或者更新补丁外，我们还要向设备发送一些附加信息，这些附加信息通常被添加至升级文件的头部。</p>
<table>
<tbody>
<tr>
    <td align="center">魔术数字</td>
    <td align="center">04B</td>
    <td align="center">全量升级 ('Q','L','S','J')<br>增量升级 ('Z','L','S','J')</td>
</tr>
<tr>
    <td align="center">包头长度</td>
    <td align="center">04B</td>
    <td align="center">支持变长包头 *</td>
</tr>
<tr>
    <td align="center">文件摘要</td>
    <td align="center">04B</td>
    <td align="center">从「文件长度」之后开始计算</td>
</tr>
<tr>
    <td align="center">文件长度</td>
    <td align="center">04B</td>
    <td align="center">从「文件长度」之后开始计算</td>
</tr>
<tr>
    <td align="center">　</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
<tr>
    <td align="center">产品型号</td>
    <td align="center">08B</td>
    <td align="center">产品一型 ('P','N','-','A','0','0','0','1')<br>产品二型 ('P','N','-','A','0','0','0','2')</td>
</tr>
<tr>
    <td align="center">设备地址</td>
    <td align="center">08B</td>
    <td align="center">通配地址 (0xFFFFFFFFFFFFFFFF)<br>单点地址 (0x1111111111111111)</td>
</tr>
<tr>
    <td align="center">　</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
<tr>
    <td align="center">新程序 LEN 值</td>
    <td align="center">04B</td>
    <td align="center" rowspan="6">对旧程序进行摘要值校验<br>或者<br>对旧程序进行差分还原时<br><br>某些可变字段必须以默认值进行处理</td>
</tr>
<tr>
    <td align="center">旧程序 LEN 值</td>
    <td align="center">04B</td>
</tr>
<tr>
    <td align="center">新程序 CRC 值</td>
    <td align="center">04B</td>
</tr>
<tr>
    <td align="center">旧程序 CRC 值</td>
    <td align="center">04B</td>
</tr>
<tr>
    <td align="center">新程序 MD5 值</td>
    <td align="center">16B</td>
</tr>
<tr>
    <td align="center">旧程序 MD5 值</td>
    <td align="center">16B</td>
</tr>
<tr>
    <td align="center">......</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
<tr>
    <td align="center">可以按需增加</td>
    <td align="center"></td>
    <td align="center"></td>
</tr>
</tbody>
</table>

<p><strong>变长包头的优势</strong></p>
<p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.head.scalable.png"></p>
<div class="note info no-icon"><p>升级包头我建议做成变长的，万一哪天包头长度不够用了，扩展后也能兼容现场的老设备。</p>
</div>

<h2 id="升级文件"><a href="#升级文件" class="headerlink" title="升级文件"></a>升级文件</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.1.raw.full.png" alt="未经压缩的全量升级文件结构"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.2.zip.full.png" alt="经过压缩的全量升级文件结构"></div><div class="group-picture-column"><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.file.4.zip.diff.png" alt="经过压缩的增量升级文件结构"></div></div></div>

<h2 id="升级方案"><a href="#升级方案" class="headerlink" title="升级方案"></a>升级方案</h2><h3 id="未经压缩的全量升级-经过压缩的增量升级"><a href="#未经压缩的全量升级-经过压缩的增量升级" class="headerlink" title="未经压缩的全量升级 + 经过压缩的增量升级"></a>未经压缩的全量升级 + 经过压缩的增量升级</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.1.raw.full+zip.diff.png"></p>
<h3 id="经过压缩的全量升级-经过压缩的增量升级"><a href="#经过压缩的全量升级-经过压缩的增量升级" class="headerlink" title="经过压缩的全量升级 + 经过压缩的增量升级"></a>经过压缩的全量升级 + 经过压缩的增量升级</h3><p><img src="/sulfurandcu.io/clnyhr2n4005710rqfv00ckub/update.plan.2.zip.full+zip.diff.png"></p>
<h2 id="升级流程"><a href="#升级流程" class="headerlink" title="升级流程"></a>升级流程</h2><h3 id="接收升级数据"><a href="#接收升级数据" class="headerlink" title="接收升级数据"></a>接收升级数据</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
Start(接收升级数据&lt;br&gt;开始)--&gt;DoRecv[接收数据]--&gt;IsHeadRecvDone{文件头接收完毕}
IsHeadRecvDone--否&#x2F;继续接收--&gt;DoRecv
IsHeadRecvDone--是--&gt;IsHeadParsed{文件头已被处理}
IsHeadParsed--是----&gt;DoWrite[将接收到的数据写入外存&lt;br&gt;如果为「压缩增量升级」则将数据写入〈升级数据存储区〉&lt;br&gt;如果为「压缩全量升级」则将数据写入〈升级数据存储区〉&lt;br&gt;如果为「原版全量升级」则将数据写入〈新版程序存储区〉&lt;br&gt;（如果小程序为旧版本则写入时偏移75字节）]--&gt;IsFileRecvOver{文件传输完毕}
IsFileRecvOver--否&#x2F;继续接收--&gt;DoRecv2[继续接收数据]
IsFileRecvOver--是--&gt;DoCheck[校验接收到的升级文件&lt;br&gt;如果为「压缩增量升级」则从〈升级数据存储区〉中读出数据并计算CRC值&lt;br&gt;如果为「压缩全量升级」则从〈升级数据存储区〉中读出数据并计算CRC值&lt;br&gt;如果为「原版全量升级」则从〈新版程序存储区〉中读出数据并计算CRC值&lt;br&gt;（如果小程序为旧版本则读取时偏移75字节）]--&gt;IsCheckOK{校验是否通过}
IsCheckOK--否--&gt;Over3(结束)
IsCheckOK--是--&gt;DoWriteHead[将文件头中的某些数据写入外存的第一个扇区&lt;br&gt;（如果小程序为旧版本则将“新程序大小”加75字节）]--&gt;DoWriteHeadFlag[将该扇区中的升级标识从0xFFFFFFFF改成0xAABBFFFF]--&gt;IsA{增量升级}
IsA--是--&gt;DoSetA[发起增量升级任务]--&gt;Over4(结束)
IsA--否--&gt;IsB{有压缩的&lt;br&gt;全量升级}
IsB--是--&gt;DoSetB[发起全量升级任务]--&gt;Over4(结束)
IsB--否--&gt;IsC{无压缩的&lt;br&gt;全量升级}
IsC--是--&gt;DoSetC[发起全量升级任务]--&gt;Over4(结束)
IsC--否--&gt;Over5(结束)
IsHeadParsed--否--&gt;IsHeadOK{文件头格式正确}
IsHeadOK--否--&gt;Over1(结束)
IsHeadOK--是--&gt;IsDiffUpdate{是否为增量升级}
IsDiffUpdate--否&#x2F;继续接收--&gt;DoRecv
IsDiffUpdate--是--&gt;IsCRCOK{文件头中的旧程序CRC与&lt;br&gt;当前程序的CRC是否一致}
IsCRCOK--（当前程序中的可变字段以默认值进行处理）&lt;br&gt;&lt;br&gt;不一致--&gt;Over2(结束)
IsCRCOK--是&#x2F;继续接收--&gt;DoRecv
</pre>

<h3 id="执行升级任务"><a href="#执行升级任务" class="headerlink" title="执行升级任务"></a>执行升级任务</h3><pre class="mermaid">
flowchart TB
%%{init: { &quot;flowchart&quot;: { &quot;curve&quot;: &quot;basis&quot; } } }%%
Start(执行升级任务&lt;br&gt;开始)--&gt;IsUpdateFlag{升级文件接收完毕}
IsUpdateFlag--否--&gt;IsUpdateFlag
IsUpdateFlag--是--&gt;DoReadHead[从外存的第一个扇区中读取升级信息]--&gt;IsReadSucc{读取成功}
IsReadSucc--否--&gt;Over1(结束)
IsReadSucc--是--&gt;IsUpdateFlagIsDownload{升级标识&#x3D;&#x3D;0xAABBFFFF}
IsUpdateFlagIsDownload--否--&gt;Over2(结束)
IsUpdateFlagIsDownload--是--&gt;IsUpdateTypeIsZipDiff{是否为压缩增量升级}
IsUpdateTypeIsZipDiff--是--&gt;DoUnDiff[执行差分还原操作]--如果小程序为旧版本&lt;br&gt;则写入时偏移75字节&lt;br&gt;当前程序中的可变字段以默认值进行处理---&gt;DoCheckNewAppCRC
IsUpdateTypeIsZipDiff--否--&gt;IsUpdateTypeIsZipFull{是否为压缩全量升级}
IsUpdateTypeIsZipFull--是--&gt;DoUnZip[执行文件解压操作]--如果小程序为旧版本&lt;br&gt;则写入时偏移75字节---&gt;DoCheckNewAppCRC
IsUpdateTypeIsZipFull--否--&gt;IsUpdateTypeIsRawFull{是否为原版全量升级}
IsUpdateTypeIsRawFull--是--&gt;DoNothing[无需执行任何操作]---&gt;DoCheckNewAppCRC[校验新程序&lt;br&gt;对比文件头中的新程序CRC与&lt;br&gt;新程序存储区中的数据的CRC]
IsUpdateTypeIsRawFull--否--&gt;Over3(结束)
DoCheckNewAppCRC--如果小程序为旧版本&lt;br&gt;则读取时偏移75字节---&gt;IsCRCCheckOK{CRC是否一致}
IsCRCCheckOK--否--&gt;Over4(结束)
IsCRCCheckOK--是--&gt;DoChangeUpdateFlag[将外存中的升级标识从0xAABBFFFF改为0xAABBCCDD]--&gt;IsChangeSucc{修改是否成功}
IsChangeSucc--否--&gt;Over5(结束)
IsChangeSucc--是--&gt;DoChangeInternalFlashUpdateFlag[将内部flash中的0xAABBCCDD改成0x0000CCDD]--&gt;DoReset[一秒后重启进入引导程序]--&gt;OverX(结束)
</pre>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#06）差分还原 hpatchlite 移植</title>
    <url>/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r.html</url>
    <content><![CDATA[<p>最近发现了一个优秀的差分还原算法：hdiff &amp; hpatch，它通过数据流的思想把 O(n) 的空间复杂度转嫁给了硬盘，使得内存的开销极低，非常适合应用于嵌入式领域。</p>
<p><img src="/sulfurandcu.io/cloidefbf00hzv0rqa7zg722r/diff.tools.compare.png"></p>
<span id="more"></span>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="hpatchlite"><a href="#hpatchlite" class="headerlink" title="hpatchlite"></a>hpatchlite</h3><p>时间复杂度：O(oldSize+newSize)<br>空间复杂度：O(1)<br>　　还原代码开销｜ROM &#x3D; 876 字节 (compiled by armcc v5.06 update4 build 422)<br>　　还原内存开销｜RAM &#x3D; 还原缓冲大小 + 解压内存开销</p>
<p>注：还原缓冲大小在还原时指定，至少3个字节，还原缓冲越小还原得越慢。</p>
<h3 id="tinyuz"><a href="#tinyuz" class="headerlink" title="tinyuz"></a>tinyuz</h3><p>时间复杂度：O(oldSize+newSize)<br>空间复杂度：O(1)<br>　　解压代码开销｜流模式｜ROM &#x3D; 1142 字节 (compiled by armcc v5.06 update4 build 422)<br>　　解压内存开销｜流模式｜RAM &#x3D; 压缩字典大小 + 解压缓冲大小</p>
<p>注：压缩字典大小在压缩时指定，至少1个字节，压缩字典越小压缩率越低。<br>注：解压缓冲大小在解压时指定，至少2个字节，解压缓冲越小解压缩越慢。</p>
<h3 id="appendix"><a href="#appendix" class="headerlink" title="appendix"></a>appendix</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</span><br><span class="line"></span><br><span class="line"> 876          0          0          0          0      10783   hpatch_lite.o</span><br><span class="line">1142          0          0          0          0      13541   tuz_dec.o</span><br><span class="line"></span><br><span class="line"> 626         80          0         12          0      12256   hpatch_user.o</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">244           0          0          0          0       2146   bspatch.o</span><br><span class="line">586           6         64          0          0       6749   quicklz.o</span><br><span class="line"></span><br><span class="line">102           4          8          0          0       2821   bspatch_user.o</span><br><span class="line"> 52           0          0          0          0       2096   quicklz_user.o</span><br></pre></td></tr></table></figure>

<h2 id="移植说明"><a href="#移植说明" class="headerlink" title="移植说明"></a>移植说明</h2><p>将 hdiffpatch.hpatchlite &amp; tinyuz 移植至单片机 bare metal 裸机系统（based on hdiffpatch v4）</p>
<h3 id="拿来"><a href="#拿来" class="headerlink" title="拿来"></a>拿来</h3><p>将 tinyuz&#x2F;decompress 目录拷贝至目标工程中。</p>
<p>将 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatch 目录拷贝至目标工程中。</p>
<p>将 HDiffPatch&#x2F;libHDiffPatch&#x2F;HPatchLite 目录拷贝至目标工程中。</p>
<p>将 HPatchLite&#x2F;decompresser_demo.h 文件拷贝至目标工程中。</p>
<h3 id="画瓢"><a href="#画瓢" class="headerlink" title="画瓢"></a>画瓢</h3><p>依 HPatchLite&#x2F;hpatchi.c&#x2F;hpatchi() 函数画瓢：移植还原功能</p>
<p>依 tinyuz&#x2F;tinyuz_demo.cpp&#x2F;_tuz_decompress_stream() 函数画瓢：移植解压功能</p>
<p>done!</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>拿来依葫芦画瓢，说得简单，做起来着实还是费了点功夫，这几年搞嵌入式搞得有些局限了，面对句(gōu)柄这种用法竟感觉无从下手。😅</p>
<p>作者提供了以下两个接口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpatch_lite_open()</span><br><span class="line"></span><br><span class="line">hpatch_lite_patch()</span><br></pre></td></tr></table></figure>

<p>看着挺简单的吧，然而他实际上是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hpatch_lite by stream: hpatch_lite_open()+hpatch_lite_patch() compiled by Mbed Studio is 662 bytes</span></span><br><span class="line"><span class="comment">//   hdiffpatch v4.2.3, other patcher compiled by Mbed Studio:</span></span><br><span class="line"><span class="comment">//      patch_single_stream() 2356 bytes (hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"><span class="comment">//      patch_decompress_with_cache() 2846 bytes (_IS_NEED_CACHE_OLD_BY_COVERS=0,hpatch_StreamPos_t=hpatch_uint32_t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//diff_data must created by create_lite_diff()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span>&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    <span class="comment">//must read data_size data to out_data, from read_from_pos of stream; if read error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    <span class="comment">//must write data_size data to sequence stream; if write error return hpi_FALSE;</span></span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hpatch_lite open</span></span><br><span class="line"><span class="comment">// read lite headinfo from diff_data</span></span><br><span class="line"><span class="comment">// if diff_data uncompress(*out_compress_type==hpi_compressType_no), *out_uncompressSize==0;</span></span><br><span class="line"><span class="comment">// if (*out_compress_type!=hpi_compressType_no), you need open compressed data by decompresser</span></span><br><span class="line"><span class="comment">//      (see https://github.com/sisong/HPatchLite/decompresser_demo.h &amp; https://github.com/sisong/HPatchLite/hpatchi.c)</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,</span></span><br><span class="line"><span class="params">                          hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br><span class="line"><span class="comment">//hpatch_lite patch</span></span><br><span class="line"><span class="comment">//	used temp_cache_size memory + &#123;decompress buffer*1&#125;</span></span><br><span class="line"><span class="comment">//  note: temp_cache_size&gt;=hpi_kMinCacheSize</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,</span></span><br><span class="line"><span class="params">                           hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure>

<p>试着分析一下：</p>
<p><strong>差分包头信息读取接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分包头信息读取接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStreamHandle        diff_data           注意此处入参：差分数据流句柄（个人理解：如果不需要该句柄的话可以将其定义为空指针）</span></span><br><span class="line"><span class="comment"> * @param hpi_TInputStream_read         read_diff           注意此处入参：差分数据流读取函数（用户实现：以数据流的方式读取外部存储中差分数据分区的数据）</span></span><br><span class="line"><span class="comment"> * @param hpi_compressType             *out_compress_type   差分包头信息：差分包压缩类型</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_newSize         差分包头信息：还原数据的长度</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                    *out_uncompressSize  差分包头信息：解压之后的长度（如果差分包未被压缩则*out_uncompressSize输出0）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_open</span><span class="params">(hpi_TInputStreamHandle diff_data,hpi_TInputStream_read read_diff,hpi_compressType* out_compress_type,<span class="type">hpi_pos_t</span>* out_newSize,<span class="type">hpi_pos_t</span>* out_uncompressSize)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>差分包头定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_kHeadSize (2+1+1) <span class="comment">//&quot;hI&quot; + hpi_compressType + (versionCode + newSize_Bytes + uncompressSize_Bytes) &#123; + newSize + uncompressSize&#125; &#123; + dictSize&#125;</span></span></span><br><span class="line">差分包头[<span class="number">0</span>] : 魔术数字 <span class="number">68</span> <span class="string">&#x27;h&#x27;</span></span><br><span class="line">差分包头[<span class="number">1</span>] : 魔术数字 <span class="number">49</span> <span class="string">&#x27;I&#x27;</span></span><br><span class="line">差分包头[<span class="number">2</span>] : 压缩类型</span><br><span class="line">差分包头[<span class="number">3</span>] : 版本代码[<span class="number">7</span>:<span class="number">6</span>]+解压数据长度所占的字节数u[<span class="number">5</span>:<span class="number">3</span>]+还原数据长度所占的字节数n[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">差分包头[<span class="number">4</span> ~ <span class="number">4</span>+n] : 还原数据长度</span><br><span class="line">差分包头[? ~ ?+u] : 解压数据长度</span><br><span class="line"></span><br><span class="line">压缩包头[? ~ ?+<span class="number">4</span>] : 压缩字典大小</span><br></pre></td></tr></table></figure>

<p><strong>差分还原接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 差分还原接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hpatchi_listener_t            listener            详见 hpatchi_listener_t 分析</span></span><br><span class="line"><span class="comment"> * @param hpi_pos_t                     newSize             还原数据的长度</span></span><br><span class="line"><span class="comment"> * @param hpi_byte                     *temp_cache          还原缓冲的地址</span></span><br><span class="line"><span class="comment"> * @param hpi_size_t                    temp_cache_size     还原缓冲的大小（&gt;=2）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">hpi_BOOL <span class="title function_">hpatch_lite_patch</span><span class="params">(<span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> newSize,hpi_byte* temp_cache,<span class="type">hpi_size_t</span> temp_cache_size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>hpatchi_listener_t</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hpatchi_listener_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hpi_TInputStreamHandle  diff_data;</span><br><span class="line">    hpi_TInputStream_read   read_diff;</span><br><span class="line">    hpi_BOOL (*read_old)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">hpi_pos_t</span> read_from_pos,hpi_byte* out_data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">    hpi_BOOL (*write_new)(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span>* listener,<span class="type">const</span> hpi_byte* data,<span class="type">hpi_size_t</span> data_size);</span><br><span class="line">&#125; <span class="type">hpatchi_listener_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong>hpatchi_listener_t 实例（差分包未经压缩）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 差分数据流句柄,</span><br><span class="line">    .read_diff = 差分数据流读取函数,    由用户去实现（从外部存储的差分数据分区读取）（函数一）</span><br><span class="line"></span><br><span class="line">    .read_old  = 旧版数据流读取函数,    由用户去实现（从内部存储的旧版程序分区读取）（函数二）</span><br><span class="line">    .write_new = 还原数据流写入函数,    由用户去实现（写入到外部存储的还原程序分区）（函数三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>hpatchi_listener_t 实例（差分包经过压缩）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tuz_TStream _tuz_stream = <span class="comment">/* 压缩数据流句柄 */</span></span><br><span class="line">&#123;</span><br><span class="line">    .in_Stream = 差分数据流句柄,</span><br><span class="line">    .read_code = 差分数据流读取函数,    由用户去实现（从外部存储的差分数据分区读取）（函数一）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hpatchi_listener_t</span> listener =</span><br><span class="line">&#123;</span><br><span class="line">    .diff_data = 压缩数据流句柄,        _tuz_stream</span><br><span class="line">    .read_diff = 压缩数据流解压函数,    _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line"></span><br><span class="line">    .read_old  = 旧版数据流读取函数,    由用户去实现（从内部存储的旧版程序分区读取）（函数二）</span><br><span class="line">    .write_new = 还原数据流写入函数,    由用户去实现（写入到外部存储的还原程序分区）（函数三）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后需要特别注意的一点是：差分包必须由 create_lite_diff() 函数创建。宏观上来说就是差分包必须要通过 hdiffi.exe 程序生成，不能使用 hdiffz.exe 生成。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hpi_BOOL 差分数据流读取函数()</span><br><span class="line">&#123;</span><br><span class="line">    由用户实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 旧版数据流读取函数()</span><br><span class="line">&#123;</span><br><span class="line">    由用户实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hpi_BOOL 还原数据流写入函数()</span><br><span class="line">&#123;</span><br><span class="line">    由用户实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 hpatch_lite_open() + hpatch_lite_patch() 编写的还原程序</span></span><br><span class="line"><span class="type">hpi_patch_result_t</span> <span class="title function_">hpi_patch</span><span class="params">(接收到的差分包大小, “还原缓冲大小”, “解压缓冲大小”)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 差分数据流句柄：如果不需要该句柄的话可以将其定义为空指针</span></span><br><span class="line">    hpatch_lite_open(“差分数据流句柄”, “差分数据流读取函数”, 输出“差分包信息”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    解压缓冲地址 = <span class="built_in">malloc</span>();</span><br><span class="line">    解压字典大小 = _tuz_TStream_getReservedMemSize(“差分数据流句柄”, “差分数据流读取函数”);</span><br><span class="line">    tuz_TStream_open(_tuz_stream, “差分数据流句柄”, “差分数据流读取函数”, “解压缓冲地址”, “解压字典大小”, “解压缓冲大小”);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    patch_listener</span><br><span class="line">        .diff_data = _tuz_stream</span><br><span class="line">        .read_diff = _tuz_TStream_decompress() <span class="comment">// decompresser_demo.h</span></span><br><span class="line">        .read_old  = 旧版数据流读取函数()</span><br><span class="line">        .write_new = 还原数据流写入函数()</span><br><span class="line"></span><br><span class="line">    还原缓冲地址 = <span class="built_in">malloc</span>();</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(“patch_listener”, “还原数据期望长度”, “还原缓冲地址”, “还原缓冲大小”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><figcaption><span>hpatch_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __hpatch_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __hpatch_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hpi_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span>; <span class="comment">// (差分文件的大小, 差分缓冲大小, 解压缓冲大小)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __hpatch_port_h__ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>hpatch_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hpatch_lite.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;decompresser_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部flash中以数据流的形式读取差分数据（由用户记录数据流的位置：读到哪儿了）（数据流结束时需要将 *data_size 置为当前所读数据的实际长度）（*data_size == decompress_cache_size）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_diff(hpi_TInputStreamHandle input_stream, hpi_byte *data, <span class="type">hpi_size_t</span> *data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="keyword">if</span> ((patch_file_rxd_pos + *data_size) &gt; patch_file_len)</span><br><span class="line">    &#123;</span><br><span class="line">        *data_size = patch_file_len - patch_file_rxd_pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, offset+patch_file_rxd_pos, data, *data_size);</span><br><span class="line">    patch_file_rxd_pos += *data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内部flash中以数据流的形式读取旧版程序</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_read_old(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">hpi_pos_t</span> read_pos, hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_older&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, read_pos, data, data_size);</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将还原数据以数据流的形式写入外部flash中（由用户记录数据流的位置：写到哪儿了）</span></span><br><span class="line"><span class="type">static</span> hpi_BOOL _do_write_new(<span class="keyword">struct</span> <span class="type">hpatchi_listener_t</span> *listener, <span class="type">const</span> hpi_byte *data, <span class="type">hpi_size_t</span> data_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, newer_file_txd_pos, data, data_size);</span><br><span class="line">    newer_file_txd_pos += data_size;</span><br><span class="line">    <span class="keyword">return</span> hpi_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hpi_patch</span><span class="params">(<span class="type">size_t</span> diff_file_size, <span class="type">size_t</span> patch_cache_size, <span class="type">size_t</span> decompress_cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* pmem = <span class="number">0</span>;</span><br><span class="line">    hpi_byte* patch_cache;</span><br><span class="line"></span><br><span class="line">    patch_file_len = diff_file_size;</span><br><span class="line">    patch_file_rxd_pos = <span class="number">0</span>;</span><br><span class="line">    newer_file_txd_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hpi_TInputStreamHandle  void_stream_handle = <span class="literal">NULL</span>;</span><br><span class="line">    hpi_TInputStream_read   diff_stream_read = _do_read_diff;</span><br><span class="line">    hpi_compressType        compress_type;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               new_size;</span><br><span class="line">    <span class="type">hpi_pos_t</span>               uncompress_size;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_open(void_stream_handle, diff_stream_read, &amp;compress_type, &amp;new_size, &amp;uncompress_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">hpatchi_listener_t</span> listener;</span><br><span class="line">    listener.read_old  = _do_read_old;</span><br><span class="line">    listener.write_new = _do_write_new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (compress_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_no:  <span class="comment">// memory size: patch_cache_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(patch_cache_size);</span><br><span class="line">            patch_cache = pmem;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = void_stream_handle;</span><br><span class="line">            listener.read_diff = diff_stream_read;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _CompressPlugin_tuz</span></span><br><span class="line">        <span class="keyword">case</span> hpi_compressType_tuz:  <span class="comment">// requirements memory size: patch_cache_size + decompress_cache_size + decompress_dict_size</span></span><br><span class="line">        &#123;</span><br><span class="line">            tuz_TStream tuz_stream_handle;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> decompress_dict_size  = _tuz_TStream_getReservedMemSize(void_stream_handle, diff_stream_read);</span><br><span class="line"></span><br><span class="line">            pmem = (hpi_byte*)hpi_malloc(decompress_dict_size + decompress_cache_size + patch_cache_size);</span><br><span class="line"></span><br><span class="line">            tuz_TStream_open(&amp;tuz_stream_handle, void_stream_handle, diff_stream_read, pmem, (<span class="type">tuz_size_t</span>)decompress_dict_size, (<span class="type">tuz_size_t</span>)decompress_cache_size);</span><br><span class="line"></span><br><span class="line">            patch_cache = pmem + decompress_dict_size + decompress_cache_size;</span><br><span class="line"></span><br><span class="line">            listener.diff_data = &amp;tuz_stream_handle;</span><br><span class="line">            listener.read_diff = _tuz_TStream_decompress;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> clear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hpatch_lite_patch(&amp;listener, new_size, patch_cache, (<span class="type">hpi_size_t</span>)patch_cache_size);</span><br><span class="line"></span><br><span class="line">clear:</span><br><span class="line">    <span class="keyword">if</span> (pmem) &#123; hpi_free(pmem); pmem=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info no-icon"><p>为了使代码看起来更加简洁，因此例程中没有进行任何异常处理。</p>
</div>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
        <tag>差分还原算法</tag>
        <tag>增量升级</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#08）引导程序 bootloader 升级</title>
    <url>/sulfurandcu.io/clnyhr2n5005a10rq54px6ho5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32L19x 时钟初始化函数存在缺陷</title>
    <url>/sulfurandcu.io/cloqzg643003vmgrq0vxo85xp.html</url>
    <content><![CDATA[<p>hc32l19x_reference_manaul</p>
<p><img src="/sulfurandcu.io/cloqzg643003vmgrq0vxo85xp/clock-tree.png"></p>
<span id="more"></span>

<p>hc32l19x_ddl_rev1.0.3</p>
<figure class="highlight c"><figcaption><span>sysctrl.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">en_result_t</span> <span class="title function_">Sysctrl_SysClkSwitch</span><span class="params">(<span class="type">en_sysctrl_clk_source_t</span> enSource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">en_result_t</span> enRet = Ok;</span><br><span class="line"></span><br><span class="line">    <span class="type">en_sysctrl_clk_source_t</span> ClkNew = enSource;</span><br><span class="line"></span><br><span class="line">    _SysctrlUnlock();</span><br><span class="line">    M0P_SYSCTRL-&gt;SYSCTRL0_f.CLKSW = ClkNew;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Core时钟（HCLK）</span></span><br><span class="line">    SystemCoreClockUpdate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">en_result_t</span> <span class="title function_">Sysctrl_ClkInit</span><span class="params">(<span class="type">stc_sysctrl_clk_cfg_t</span> *pstcCfg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">en_result_t</span> enRet = Ok;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统时钟参数配置</span></span><br><span class="line">    <span class="keyword">switch</span>(pstcCfg-&gt;enClkSrc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SysctrlClkRCH:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SysctrlClkXTH:</span><br><span class="line">            Sysctrl_XTHDriverCfg(SysctrlXtalDriver3);</span><br><span class="line">            Sysctrl_SetXTHStableTime(SysctrlXthStableCycle16384);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SysctrlClkRCL:</span><br><span class="line">            Sysctrl_SetRCLStableTime(SysctrlRclStableCycle256);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SysctrlClkXTL:</span><br><span class="line">            Sysctrl_XTLDriverCfg(SysctrlXtlAmp3, SysctrlXtalDriver3);</span><br><span class="line">            Sysctrl_SetXTLStableTime(SysctrlXtlStableCycle16384);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SysctrlClkPLL:</span><br><span class="line">            Sysctrl_SetPLLStableTime(SysctrlPllStableCycle16384);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            enRet = ErrorInvalidParameter;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟源使能</span></span><br><span class="line">    Sysctrl_ClkSourceEnable(pstcCfg-&gt;enClkSrc, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟源切换</span></span><br><span class="line">    Sysctrl_SysClkSwitch(pstcCfg-&gt;enClkSrc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时钟分频设置</span></span><br><span class="line">    Sysctrl_SetHCLKDiv(pstcCfg-&gt;enHClkDiv);</span><br><span class="line">    Sysctrl_SetPCLKDiv(pstcCfg-&gt;enPClkDiv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sysctrl_SysClkSwitch() 调用了 SystemCoreClockUpdate() 来更新 SystemCoreClock。这没问题，问题是在这之后又去设置了 HCLK 的值，这就会导致 SystemCoreClock 与实际的 HCLK 不一致。</p>
<p>通过修改驱动库，将「时钟源切换」和「时钟分频设置」的执行顺序对调即可解决该问题，若不想直接修改驱动库，可以在调用 Sysctrl_ClkInit() 之后再调用一遍 SystemCoreClockUpdate()。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32L19X</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 IAP 升级功能（#07）压缩解压 tinyuz 移植</title>
    <url>/sulfurandcu.io/cloidh8k000ijv0rq8b5hbdpe.html</url>
    <content><![CDATA[<p>与上文类似，对 tinyuz 也进行二次封装以便上层调用：</p>
<figure class="highlight c"><figcaption><span>tinyuz_port.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __tinyuz_port_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __tinyuz_port_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUZ_DECOMPRESS_SPACE_SIZE       512*1024            <span class="comment">// 外部存储中〈差分文件区〉的空间大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_malloc(x)                   mymalloc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tuz_free(x)                     myfree(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TTinyuzResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TINYUZ_SUCCESS=<span class="number">0</span>,</span><br><span class="line">    TINYUZ_OPTIONS_ERROR,</span><br><span class="line">    TINYUZ_OPENREAD_ERROR,</span><br><span class="line">    TINYUZ_OPENWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILEREAD_ERROR,</span><br><span class="line">    TINYUZ_FILEWRITE_ERROR,</span><br><span class="line">    TINYUZ_FILECLOSE_ERROR,</span><br><span class="line">    TINYUZ_MEM_ERROR,</span><br><span class="line">    TINYUZ_COMPRESS_ERROR,</span><br><span class="line">    TINYUZ_DECOMPRESS_ERROR,</span><br><span class="line">&#125; TTinyuzResult;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __tinyuz_port_h__ */</span></span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight c"><figcaption><span>tinyuz_port.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tinyuz_port.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuz_dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;patch_types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TTuzListener</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> hpatch_TStreamInput*  input_file_stream_handle;</span><br><span class="line">    hpatch_StreamPos_t          readPos;</span><br><span class="line">    tuz_TInputStream_read       _do_read_encompress_file;</span><br><span class="line">&#125;TTuzListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部flash中以数据流的形式读取压缩数据</span></span><br><span class="line">hpatch_BOOL _do_read_encompress_file(<span class="type">const</span> hpatch_TStreamInput* stream, hpatch_StreamPos_t readFromPos, <span class="type">unsigned</span> <span class="type">char</span>* out_data, <span class="type">unsigned</span> <span class="type">char</span>* out_data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> readLen = (<span class="type">size_t</span>)(out_data_end - out_data);</span><br><span class="line">    <span class="keyword">if</span> (readLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> compressed_stream_size = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((readLen &gt; compressed_stream_size) || (readFromPos &gt; compressed_stream_size - readLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_ziped&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_read(partition, readFromPos, out_data, readLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将解压数据以数据流的形式写入外部flash中</span></span><br><span class="line">hpatch_BOOL _do_write_decompress_file(<span class="type">const</span> hpatch_TStreamOutput* stream, hpatch_StreamPos_t writeToPos, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data_end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> writeLen = (<span class="type">size_t</span>)(data_end - data);</span><br><span class="line">    <span class="keyword">if</span> (writeLen == <span class="number">0</span>) <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> write_max_space = stream-&gt;streamSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((writeLen &gt; write_max_space)||(writeToPos &gt; write_max_space - writeLen)) <span class="keyword">return</span> hpatch_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 由用户实现</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> =</span> fal_partition_find(<span class="string">&quot;app_newer&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = fal_partition_write(partition, offset+writeToPos, data, writeLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hpatch_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> tuz_BOOL <span class="title function_">input_file_stream_read_function</span><span class="params">(<span class="type">void</span> *listener, tuz_byte *decompressed_file_stream, <span class="type">tuz_size_t</span> *code_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    TTuzListener *self = (TTuzListener*)listener;</span><br><span class="line">    <span class="type">tuz_size_t</span> r_len = *code_size;</span><br><span class="line">    hpatch_StreamPos_t curReadPos = self-&gt;readPos;</span><br><span class="line">    hpatch_StreamPos_t s_size = self-&gt;input_file_stream_handle-&gt;streamSize - curReadPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_len &gt; s_size)&#123;</span><br><span class="line">        r_len = (<span class="type">tuz_size_t</span>)s_size;</span><br><span class="line">        *code_size = r_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;readPos += r_len;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;input_file_stream_handle-&gt;read(self-&gt;input_file_stream_handle, curReadPos, decompressed_file_stream, decompressed_file_stream + r_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">tuz_decompress</span><span class="params">(<span class="type">size_t</span> compressed_file_size, <span class="type">size_t</span> cache_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    hpatch_TStreamOutput decompressed_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;decompressed_file_stream_handle,</span><br><span class="line">        .streamSize = TUZ_DECOMPRESS_SPACE_SIZE, <span class="comment">// 外部存储中〈差分文件区〉的空间大小</span></span><br><span class="line">        .write = _do_write_decompress_file, <span class="comment">// stream write</span></span><br><span class="line">        .read_writed = <span class="literal">NULL</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    hpatch_TStreamInput input_file_stream_handle = &#123;</span><br><span class="line">        .streamImport = &amp;input_file_stream_handle,</span><br><span class="line">        .streamSize = compressed_file_size, <span class="comment">// 压缩文件的实际大小</span></span><br><span class="line">        .read = _do_read_encompress_file, <span class="comment">// stream read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TTuzListener listener = &#123;&amp;input_file_stream_handle, <span class="number">0</span>, input_file_stream_read_function&#125;;</span><br><span class="line">    tuz_TStream tuz;</span><br><span class="line">    tuz_TResult result = tuz_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩的时候会以指定的字典大小进行压缩｜因此解压的时候要从压缩包头中读取字典大小</span></span><br><span class="line">    <span class="type">tuz_size_t</span> dictSize = tuz_TStream_read_dict_size(&amp;listener, listener._do_read_encompress_file);</span><br><span class="line"></span><br><span class="line">    tuz_byte* decompress_buf = <span class="number">0</span>;</span><br><span class="line">    cache_size &gt;&gt;= <span class="number">1</span>; <span class="comment">// 除二操作</span></span><br><span class="line">    decompress_buf = (tuz_byte*)tuz_malloc(dictSize + cache_size*<span class="number">2</span>); <span class="comment">// 解压过程中要用到的临时空间大小 = 字典大小 + 解压缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decompress_buf == <span class="number">0</span>) <span class="keyword">return</span> TINYUZ_MEM_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tuz_TStream_open 仅仅是用来初始化 tuz 这个勾柄的（tuz后面的参数都是给tuz赋值用的）</span></span><br><span class="line">    result = tuz_TStream_open(&amp;tuz, &amp;listener, listener._do_read_encompress_file, decompress_buf + cache_size, (<span class="type">tuz_size_t</span>)dictSize, (<span class="type">tuz_size_t</span>)cache_size);</span><br><span class="line"></span><br><span class="line">    hpatch_StreamPos_t stream_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (result == tuz_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">tuz_size_t</span> decompress_len = (<span class="type">tuz_size_t</span>)cache_size; <span class="comment">// 给decompress_len赋一个初始值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解压一包数据到 decompress_buf 中｜并得到该包长度 decompress_len</span></span><br><span class="line">        result = tuz_TStream_decompress_partial(&amp;tuz, decompress_buf, &amp;decompress_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt;= tuz_STREAM_END)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前解压的 decompress_buf 中的数据写到 decompressed_file_stream_handle 数据流中</span></span><br><span class="line">            <span class="keyword">if</span> (decompressed_file_stream_handle.write(&amp;decompressed_file_stream_handle, stream_index, decompress_buf, decompress_buf + decompress_len))</span><br><span class="line">            &#123;</span><br><span class="line">                stream_index += decompress_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tuz_free(decompress_buf);</span><br><span class="line">                <span class="keyword">return</span> TINYUZ_OPENWRITE_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tuz_free(decompress_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>嵌入式软件开发</tag>
        <tag>在线升级</tag>
        <tag>压缩解压算法</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 避坑指南之 ICG 寄存器</title>
    <url>/sulfurandcu.io/cloqzaza3003fmgrqdpkl8c5j.html</url>
    <content><![CDATA[<p>在《参考手册》第六章〈初始化配置〉中，八个初始化配置寄存器的复位值是不定的，华大对此的处理方式很巧妙（但是也给移植埋下了一个大坑）：</p>
<figure class="highlight c"><figcaption><span>hc32f460_icg.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!&lt; ICG0 register value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG0_REGISTER_CONSTANT                  (((uint32_t)ICG0_WDT_REG_CONFIG &lt;&lt; 16)  | \</span></span><br><span class="line"><span class="meta">                                                 ((uint32_t)ICG0_SWDT_REG_CONFIG)       | \</span></span><br><span class="line"><span class="meta">                                                 ((uint32_t)0xE000E000ul))</span></span><br><span class="line"><span class="comment">/*!&lt; ICG1 register value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG1_REGISTER_CONSTANT                  (((uint32_t)ICG1_NMI_REG_CONFIG &lt;&lt; 24)  | \</span></span><br><span class="line"><span class="meta">                                                 ((uint32_t)ICG1_VDU0_REG_CONFIG &lt;&lt; 16) | \</span></span><br><span class="line"><span class="meta">                                                 ((uint32_t)ICG1_HRC_REG_CONFIG)        | \</span></span><br><span class="line"><span class="meta">                                                 ((uint32_t)0x03F8FEFEul))</span></span><br><span class="line"><span class="comment">/*!&lt; ICG2~7 register reserved value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG2_REGISTER_CONSTANT                  ((uint32_t)0xFFFFFFFFul)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG3_REGISTER_CONSTANT                  ((uint32_t)0xFFFFFFFFul)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG4_REGISTER_CONSTANT                  ((uint32_t)0xFFFFFFFFul)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG5_REGISTER_CONSTANT                  ((uint32_t)0xFFFFFFFFul)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG6_REGISTER_CONSTANT                  ((uint32_t)0xFFFFFFFFul)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICG7_REGISTER_CONSTANT                  ((uint32_t)0xFFFFFFFFul)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>hc32f460_icg.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined ( __GNUC__ ) &amp;&amp; !defined (__CC_ARM) <span class="comment">/* GNU Compiler */</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> u32ICG[] __attribute__((section(<span class="string">&quot;.icg_sec&quot;</span>))) =</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__CC_ARM)</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> u32ICG[] __attribute__((at(<span class="number">0x400</span>))) =</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__ICCARM__)</span></span><br><span class="line">__root <span class="type">const</span> <span class="type">uint32_t</span> u32ICG[] @ <span class="number">0x400</span> =</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;unsupported compiler!!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ICG 0~ 3 */</span></span><br><span class="line">    ICG0_REGISTER_CONSTANT,</span><br><span class="line">    ICG1_REGISTER_CONSTANT,</span><br><span class="line">    ICG2_REGISTER_CONSTANT,</span><br><span class="line">    ICG3_REGISTER_CONSTANT,</span><br><span class="line">    <span class="comment">/* ICG 4~ 7 */</span></span><br><span class="line">    ICG4_REGISTER_CONSTANT,</span><br><span class="line">    ICG5_REGISTER_CONSTANT,</span><br><span class="line">    ICG6_REGISTER_CONSTANT,</span><br><span class="line">    ICG7_REGISTER_CONSTANT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过定义常量的方式，在程序加载阶段，将数据 load 至指定的寄存器。</p>
<h2 id="避坑指北"><a href="#避坑指北" class="headerlink" title="避坑指北"></a>避坑指北</h2><p>如果项目由 bootloader 和 app 两部分组成，那么只能在 bootloader 中添加上述源文件，在 app 中不能添加该文件，否则会出现异常。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 程序烧录异常</title>
    <url>/sulfurandcu.io/cloqyh9rx0027mgrq1e9f3vv2.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JLink info:</span><br><span class="line">------------</span><br><span class="line">DLL: V7.50 , compiled Jul  1 2021 17:37:28</span><br><span class="line">Firmware: J-Link V9 compiled May  7 2021 16:26:12</span><br><span class="line">Hardware: V9.60</span><br><span class="line">S/N : 69667985</span><br><span class="line">Feature(s) : RDI, GDB, FlashDL, FlashBP, JFlash</span><br><span class="line"></span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: Scanning AP map to find all available APs</span><br><span class="line">* JLink Info: AP[1]: Stopped AP scan as end of AP map has been reached</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: 0x24770011)</span><br><span class="line">* JLink Info: Iterating through AP map to find AHB-AP to use</span><br><span class="line">* JLink Info: AP[0]: Core found</span><br><span class="line">* JLink Info: AP[0]: AHB-AP ROM base: 0xE00FF000</span><br><span class="line">* JLink Info: CPUID register: 0x410FC241. Implementer code: 0x41 (ARM)</span><br><span class="line">* JLink Info: Found Cortex-M4 r0p1, Little endian.</span><br><span class="line">* JLink Info: FPUnit: 6 code (BP) slots and 2 literal slots</span><br><span class="line">* JLink Info: CoreSight components:</span><br><span class="line">* JLink Info: ROMTbl[0] @ E00FF000</span><br><span class="line">* JLink Info: ROMTbl[0][0]: E000E000, CID: B105E00D, PID: 000BB00C SCS-M7</span><br><span class="line">* JLink Info: ROMTbl[0][1]: E0001000, CID: B105E00D, PID: 003BB002 DWT</span><br><span class="line">* JLink Info: ROMTbl[0][2]: E0002000, CID: B105E00D, PID: 002BB003 FPB</span><br><span class="line">* JLink Info: ROMTbl[0][3]: E0000000, CID: B105E00D, PID: 003BB001 ITM</span><br><span class="line">* JLink Info: ROMTbl[0][4]: E0040000, CID: B105900D, PID: 000BB9A1 TPIU</span><br><span class="line">ROMTableAddr = 0xE00FF000</span><br><span class="line">* JLink Info: Reset: Halt core after reset via DEMCR.VC_CORERESET.</span><br><span class="line">* JLink Info: Reset: Reset device via AIRCR.SYSRESETREQ.</span><br><span class="line">* JLink Info: Reset: S_RESET_ST never gets cleared. CPU seems to be kept in reset forever.</span><br><span class="line">* JLink Info: Reset: Using fallback: Reset pin.</span><br><span class="line">* JLink Info: Reset: Halt core after reset via DEMCR.VC_CORERESET.</span><br><span class="line">* JLink Info: Reset: Reset device via reset pin</span><br><span class="line">* JLink Info: Reset: VC_CORERESET did not halt CPU. (Debug logic also reset by reset pin?).</span><br><span class="line">* JLink Info: Reset: Reconnecting and manually halting CPU.</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: AP map detection skipped. Manually configured AP map found.</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: Not set)</span><br><span class="line">* JLink Info: AP[0]: Core found</span><br><span class="line">* JLink Info: AP[0]: AHB-AP ROM base: 0xE00FF000</span><br><span class="line">* JLink Info: CPUID register: 0x410FC241. Implementer code: 0x41 (ARM)</span><br><span class="line">* JLink Info: Found Cortex-M4 r0p1, Little endian.</span><br><span class="line">* JLink Info: CPU could not be halted</span><br><span class="line">* JLink Info: Reset: Core did not halt after reset, trying to disable WDT.</span><br><span class="line">* JLink Info: Reset: Halt core after reset via DEMCR.VC_CORERESET.</span><br><span class="line">* JLink Info: Reset: Reset device via reset pin</span><br><span class="line">* JLink Info: Reset: VC_CORERESET did not halt CPU. (Debug logic also reset by reset pin?).</span><br><span class="line">* JLink Info: Reset: Reconnecting and manually halting CPU.</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: AP map detection skipped. Manually configured AP map found.</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: Not set)</span><br><span class="line">* JLink Info: AP[0]: Core found</span><br><span class="line">* JLink Info: AP[0]: AHB-AP ROM base: 0xE00FF000</span><br><span class="line">* JLink Info: CPUID register: 0x410FC241. Implementer code: 0x41 (ARM)</span><br><span class="line">* JLink Info: Found Cortex-M4 r0p1, Little endian.</span><br><span class="line">* JLink Info: CPU could not be halted</span><br><span class="line">* JLink Info: Reset: Failed. Toggling reset pin and trying reset strategy again.</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: AP map detection skipped. Manually configured AP map found.</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: Not set)</span><br><span class="line">* JLink Info: AP[0]: Core found</span><br><span class="line">* JLink Info: AP[0]: AHB-AP ROM base: 0xE00FF000</span><br><span class="line">* JLink Info: CPUID register: 0x410FC241. Implementer code: 0x41 (ARM)</span><br><span class="line">* JLink Info: Found Cortex-M4 r0p1, Little endian.</span><br><span class="line">* JLink Info: Reset: Halt core after reset via DEMCR.VC_CORERESET.</span><br><span class="line">* JLink Info: Reset: Reset device via AIRCR.SYSRESETREQ.</span><br><span class="line">* JLink Info: Reset: S_RESET_ST never gets cleared. CPU seems to be kept in reset forever.</span><br><span class="line">* JLink Info: Reset: Using fallback: Reset pin.</span><br><span class="line">* JLink Info: Reset: Halt core after reset via DEMCR.VC_CORERESET.</span><br><span class="line">* JLink Info: Reset: Reset device via reset pin</span><br><span class="line">* JLink Info: Reset: VC_CORERESET did not halt CPU. (Debug logic also reset by reset pin?).</span><br><span class="line">* JLink Info: Reset: Reconnecting and manually halting CPU.</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: AP map detection skipped. Manually configured AP map found.</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: Not set)</span><br><span class="line">* JLink Info: AP[0]: Core found</span><br><span class="line">* JLink Info: AP[0]: AHB-AP ROM base: 0xE00FF000</span><br><span class="line">* JLink Info: CPUID register: 0x410FC241. Implementer code: 0x41 (ARM)</span><br><span class="line">* JLink Info: Found Cortex-M4 r0p1, Little endian.</span><br><span class="line">* JLink Info: CPU could not be halted</span><br><span class="line">* JLink Info: Reset: Core did not halt after reset, trying to disable WDT.</span><br><span class="line">* JLink Info: Reset: Halt core after reset via DEMCR.VC_CORERESET.</span><br><span class="line">* JLink Info: Reset: Reset device via reset pin</span><br><span class="line">* JLink Info: Reset: VC_CORERESET did not halt CPU. (Debug logic also reset by reset pin?).</span><br><span class="line">* JLink Info: Reset: Reconnecting and manually halting CPU.</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: AP map detection skipped. Manually configured AP map found.</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: Not set)</span><br><span class="line">* JLink Info: AP[0]: Core found</span><br><span class="line">* JLink Info: AP[0]: AHB-AP ROM base: 0xE00FF000</span><br><span class="line">* JLink Info: CPUID register: 0x410FC241. Implementer code: 0x41 (ARM)</span><br><span class="line">* JLink Info: Found Cortex-M4 r0p1, Little endian.</span><br><span class="line">* JLink Info: CPU could not be halted</span><br><span class="line">* JLink Info: CPU could not be halted</span><br><span class="line">***JLink Error: Failed to halt CPU.</span><br><span class="line">* JLink Info: CPU could not be halted</span><br><span class="line">Error: Flash Download failed  -  Target DLL has been cancelled</span><br><span class="line">Flash Load finished at 09:01:53</span><br></pre></td></tr></table></figure>

<p>* JLink Info: Reset: S_RESET_ST never gets cleared. CPU seems to be kept in reset forever.</p>
<p>很可能是外部复位电路失效，导致复位引脚被拉低，进而导致内核一直处于复位状态。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 超频过猛导致 MCU 宕机</title>
    <url>/sulfurandcu.io/cloqxdq0v001nmgrq2um386nw.html</url>
    <content><![CDATA[<p>最近又把 MCU 给干废了，现象如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load &quot;main.axf&quot;</span><br><span class="line">* JLink Info: Device &quot;CORTEX-M4&quot; selected.</span><br><span class="line">Set JLink Project File to &quot;JLinkSettings.ini&quot;</span><br><span class="line">* JLink Info: Device &quot;CORTEX-M4&quot; selected.</span><br><span class="line"></span><br><span class="line">JLink info:</span><br><span class="line">------------</span><br><span class="line">DLL: V7.22b, compiled Jun 17 2021 17:22:49</span><br><span class="line">Firmware: J-Link V9 compiled May  7 2021 16:26:12</span><br><span class="line">Hardware: V9.60</span><br><span class="line">S/N : 69667602</span><br><span class="line">Feature(s) : RDI, GDB, FlashDL, FlashBP, JFlash</span><br><span class="line"></span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: Scanning AP map to find all available APs</span><br><span class="line">* JLink Info: AP[1]: Stopped AP scan as end of AP map has been reached</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: 0x24770011)</span><br><span class="line">* JLink Info: Iterating through AP map to find AHB-AP to use</span><br><span class="line">* JLink Info: AP[0]: Skipped. Invalid implementer code read from CPUIDVal[31:24] = 0x00</span><br><span class="line">* JLink Info: Found SW-DP with ID 0x2BA01477</span><br><span class="line">* JLink Info: DPIDR: 0x2BA01477</span><br><span class="line">* JLink Info: Scanning AP map to find all available APs</span><br><span class="line">* JLink Info: AP[1]: Stopped AP scan as end of AP map has been reached</span><br><span class="line">* JLink Info: AP[0]: AHB-AP (IDR: 0x24770011)</span><br><span class="line">* JLink Info: Iterating through AP map to find AHB-AP to use</span><br><span class="line">* JLink Info: AP[0]: Skipped. Invalid implementer code read from CPUIDVal[31:24] = 0x00</span><br><span class="line"></span><br><span class="line">***JLink Error: Could not find core in Coresight setup</span><br><span class="line"></span><br><span class="line">Error: Flash Download failed  -  Target DLL has been cancelled</span><br><span class="line">Flash Load finished at 10:35:22</span><br></pre></td></tr></table></figure>

<p>事情经过是这样的，某款产品第一版硬件的时钟源选用的是 6MHz 的外部晶振，内部倍频至 128MHz 作为系统主频，而第二版则改成了 24MHz 的外部晶振，第二版硬件出来后，将第一版程序直接烧录进第二版硬件后 MCU 无法正常启动且无法被识别。</p>
<p>初步推测，应该是外部晶振频率提高，但是程序没有进行适当地分频，导致系统主频远远超过数据手册中规定的频率上限（200MHz）。</p>
<!--
公式使用工具 https://latexlive.com/ 生成
\begin{align}
& 128MHz × (24MHz / 6MHz) = 512MHz \ \ \ > \ \ \ MAX(200MHz) \\
\end{align}
-->
</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd></mtd><mtd><mn>128</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo>×</mo><mo stretchy="false">(</mo><mn>24</mn><mi>M</mi><mi>H</mi><mi>z</mi><mrow><mo>/</mo></mrow><mn>6</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>512</mn><mi>M</mi><mi>H</mi><mi>z</mi><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mo>&gt;</mo><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mi>M</mi><mi>A</mi><mi>X</mi><mo stretchy="false">(</mo><mn>200</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></math>
<br>

<p>后面通过调试，证实程序的确是在 <code>M4_SYSREG-&gt;CMU_CKSWR_f.CKSW = enTargetSysSrc;</code> 处出现异常。</p>
<p>上述操作其实就是「超频」，只是超得有点猛，导致芯片直接宕机。这种情况借助华大的离线下载器重新烧录程序即可恢复正常。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>开发指南：华大 HC32F460 图解复用引脚</title>
    <url>/sulfurandcu.io/cloqsamml003og4rq88xkh2ls.html</url>
    <content><![CDATA[<h2 id="HC32F460-LQFP64"><a href="#HC32F460-LQFP64" class="headerlink" title="HC32F460-LQFP64"></a>HC32F460-LQFP64</h2><br>

<p><img src="/sulfurandcu.io/cloqsamml003og4rq88xkh2ls/HC32F460.png"></p>
<center>
功能分组
</center><br><br>

<span id="more"></span>

<p><img src="/sulfurandcu.io/cloqsamml003og4rq88xkh2ls/HC32F460-ADC.png"></p>
<center>
模数转换
</center><br><br>

<p><img src="/sulfurandcu.io/cloqsamml003og4rq88xkh2ls/HC32F460-CMP.png"></p>
<center>
电压比较
</center><br><br>

<p><img src="/sulfurandcu.io/cloqsamml003og4rq88xkh2ls/HC32F460-PWM.png"></p>
<center>
脉宽调制
</center><br><br>
]]></content>
      <categories>
        <category>开发指南</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 程序烧录异常</title>
    <url>/sulfurandcu.io/cloqsamml003qg4rqax6x02nz.html</url>
    <content><![CDATA[<p>最近给 HC32F460 烧程序时，出现了烧录失败的现象。</p>
<p>操作流程：</p>
<ul>
<li>在引导程序的 icg.h 文件中配置开启 SWDT 看门狗</li>
<li>烧录引导程序</li>
<li>烧录应用程序</li>
<li>读取整个芯片的镜像</li>
<li>把读取出来的镜像再烧回去</li>
</ul>
<p>诡异的是，最后一步总是失败。</p>
<p>后面又进行了详细的测试：</p>
<table>
<thead>
<tr>
<th align="center">测试记录</th>
<th align="center">编程算法</th>
<th align="center">SWDT</th>
<th align="center">烧录结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">旧版</td>
<td align="center">关闭<br>或者延长狗叫时间</td>
<td align="center">烧录成功</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">旧版</td>
<td align="center">开启</td>
<td align="center">在烧录回去之前，做一次整片擦除，但是不断电：烧录失败<br>在烧录回去之前，做一次整片擦除，断电再上电：烧录成功</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">新版</td>
<td align="center">X</td>
<td align="center">均可烧录成功</td>
</tr>
</tbody></table>
<p>猜测应该是编程算法在烧录过程中没有屏蔽 SWDT 所致，更换新版编程算法即可解决。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 切换运行模式导致宕机</title>
    <url>/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4.html</url>
    <content><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><ul>
<li>从高速&#x2F;超高速模式向超低速模式切换时 mcu 异常死机</li>
</ul>
<h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><ul>
<li>当前使用华大 2.2.0 版驱动程序</li>
<li>当前使用华大 1.2.1 版参考手册</li>
</ul>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>通过调试发现每次运行至 <code>M4_SYSREG-&gt;PWR_PWRC2</code> 赋值时程序就会跑飞😶</p>
<p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2-Register.png" alt="电源模式控制寄存器 2"></p>
<figure class="highlight c"><figcaption><span>hc32f460_pwc.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">en_result_t</span> <span class="title function_">PWC_HS2LS</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    M4_SYSREG-&gt;PWR_PWRC2 = <span class="number">0xE1</span>U;</span><br><span class="line">    M4_SYSREG-&gt;PWR_MDSWCR = <span class="number">0x10</span>U;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">en_result_t</span> <span class="title function_">PWC_HP2LS</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    M4_SYSREG-&gt;PWR_PWRC2 = <span class="number">0xD1</span>U;</span><br><span class="line">    M4_SYSREG-&gt;PWR_MDSWCR = <span class="number">0x10</span>U;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>瞅了一眼《参考手册 Rev1.2.1》好像也没啥问题，又看了《参考手册 Rev1.3》后，我得发…🙄！</p>
<p>两版手册竟然不一样！</p>
<span id="more"></span>

<h3 id="Rev1-2-1"><a href="#Rev1-2-1" class="headerlink" title="Rev1.2.1"></a>Rev1.2.1</h3><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.2.png" alt="运行模式的切换流程（Rev1.2）"></p>
<h3 id="Rev1-3-0"><a href="#Rev1-3-0" class="headerlink" title="Rev1.3.0"></a>Rev1.3.0</h3><p><img src="/sulfurandcu.io/cloqsamms004qg4rq5jubc4h4/HC32F460-RM-Rev1.3.png" alt="运行模式的切换流程（Rev1.3）"></p>
<p>这妥妥的是华大的锅了…</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>开发指南：华大 HC32F460 时钟控制单元</title>
    <url>/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup.html</url>
    <content><![CDATA[<h2 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-tree-sketch.png"></p>
<span id="more"></span>

<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-tree-manual.png"></p>
<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-work.png"></p>
<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-work-manual.png"></p>
<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/clock-work-note.png"></p>
<h2 id="pll"><a href="#pll" class="headerlink" title="pll"></a>pll</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/pll.png"></p>
<h2 id="systick"><a href="#systick" class="headerlink" title="systick"></a>systick</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/systick.png"></p>
<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/systick-manual.jpg"></p>
<center>《ARM ® CortexM4 Devices Generic User Guide》</center><br>

<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/systick-register.png"></p>
<center>hc32f460's systick control and status register</center><br>

<div class="note danger no-icon"><p>华大 HC32F460 的 systick 嘀嗒定时器使用内核时钟（HCLK）</p>
</div>

<figure class="highlight c"><figcaption><span>HC32F460.h</span></figcaption><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line">* @file  HC32F460.h</span><br><span class="line">* @brief Headerfile <span class="keyword">for</span> HC32F460 series MCU</span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line">Configuration of the Cortex-M4 Processor and Core Peripherals</span><br><span class="line">********************************************************************************</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CM4_REV                 1     <span class="comment">// !&lt; Core revision r0p1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FPU_PRESENT             1     <span class="comment">// !&lt; FPU present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU_PRESENT             1     <span class="comment">// !&lt; HC32F460 provides an MPU</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NVIC_PRIO_BITS          4     <span class="comment">// !&lt; HC32F460 uses 4 Bits for the Priority Levels</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Vendor_SysTickConfig    0     <span class="comment">// !&lt; Set to 1 if different SysTick Config is used</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>core_cm4.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (__Vendor_SysTickConfig) &amp;&amp; (__Vendor_SysTickConfig == 0U)</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<div class="note danger no-icon"><p>华大 HC32F460 的 systick 嘀嗒定时器使用 cmsis(core_cm4.h) 中默认的配置函数</p>
</div>

<h2 id="外设时钟源（URT）"><a href="#外设时钟源（URT）" class="headerlink" title="外设时钟源（URT）"></a>外设时钟源（URT）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-URT.png"></p>
<center>÷2 表示开启过采样功能</center>

<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-URT-example.png"></p>
<p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-URT-baudrate-manual.jpg"></p>
<!--
公式使用工具 https://latexlive.com/ 生成
\begin{align}
& Baudrate = \frac{串口频率}{08\ \times\ (1\ +整数分频寄存器)} \ \ \ \ (关闭过采样) \\
& Baudrate = \frac{串口频率}{16\ \times\ (1\ +整数分频寄存器)} \ \ \ \ (开启过采样) \\
\end{align}
-->
</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt" displaystyle="true"><mtr><mtd></mtd><mtd><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mo>串口频率</mo></mrow><mrow><mn>08</mn><mtext>&nbsp;</mtext><mo>×</mo><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mn>1</mn><mtext>&nbsp;</mtext><mo>+</mo><mo>整数分频寄存器</mo><mo stretchy="false">)</mo></mrow></mfrac><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mo>关闭过采样</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></math>
<br>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt" displaystyle="true"><mtr><mtd></mtd><mtd><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mo>串口频率</mo></mrow><mrow><mn>16</mn><mtext>&nbsp;</mtext><mo>×</mo><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mn>1</mn><mtext>&nbsp;</mtext><mo>+</mo><mo>整数分频寄存器</mo><mo stretchy="false">)</mo></mrow></mfrac><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mo>开启过采样</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></math>
<br>

<div class="note info no-icon"><p>公式中整数分频寄存器的取值范围为 0x00 ~ 0xFF（USART_BRR[b15~b08]）</p>
</div>

<h2 id="外设时钟源（SPI）"><a href="#外设时钟源（SPI）" class="headerlink" title="外设时钟源（SPI）"></a>外设时钟源（SPI）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK1-SPI.png"></p>
<h2 id="外设时钟源（I2C）"><a href="#外设时钟源（I2C）" class="headerlink" title="外设时钟源（I2C）"></a>外设时钟源（I2C）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK3-I2C.png"></p>
<h2 id="外设时钟源（CMP）"><a href="#外设时钟源（CMP）" class="headerlink" title="外设时钟源（CMP）"></a>外设时钟源（CMP）</h2><p><img src="/sulfurandcu.io/cloqtbfnv000dmgrq0l3acbup/PCLK3-CMP.png"></p>
<div class="note danger no-icon"><p>比较滤波器的采样频率越低→滤波效果越好！</p>
</div>
]]></content>
      <categories>
        <category>开发指南</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 滤波电路失效</title>
    <url>/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss.html</url>
    <content><![CDATA[<p>最近在使用电压比较器时发现硬件滤波电路会出现失效的情况，经分析是其采样频率过高所致。</p>
<p><img src="/sulfurandcu.io/clorxokmu004nmgrq9tl4hiss/manual.png"></p>
<p>参考手册中绘制的是理想条件下的波形，真实情况并非如此，INP 在逼近 INM 时会伴随着噪声&#x2F;抖动。我们可以使用硬件滤波电路来消除这种抖动，图中绿色线段表示各采样点，其频率即为采样频率。</p>
<iframe src="https://www.desmos.com/calculator/7r0bi5urxv?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<p>采样频率较低时，滤波电路可以正常工作，但是随着采样频率的升高，其可靠性反而会降低。</p>
<span id="more"></span>

<iframe src="https://www.desmos.com/calculator/2kz1rewo6h?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>

<iframe src="https://www.desmos.com/calculator/2py3qizn5x?embed" width="800" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录：华大 HC32F460 内存边界禁止非对齐访问</title>
    <url>/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1.html</url>
    <content><![CDATA[<h2 id="文章更新（2023-11-14）"><a href="#文章更新（2023-11-14）" class="headerlink" title="文章更新（2023-11-14）"></a>文章更新（2023-11-14）</h2><p>经过排查，本文所述异常现象并非由「非对齐访问」所致，而是因为 SRAM3 开启 ECC 校验时仅支持以字为单位进行访问。</p>
<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><ul>
<li>程序无法正常启动</li>
<li>有时会进入 hard fault 中断</li>
<li>有时候会出现以下异常：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Call Stack + Locals                                                                    ✘</span><br><span class="line">    Name                                Location/Value                          Type</span><br><span class="line">    __scatterload_zeroinit              0x00074C56                              function</span><br><span class="line">    __scatterload                       0x00018DFE                              function</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><h3 id="芯片资源"><a href="#芯片资源" class="headerlink" title="芯片资源"></a>芯片资源</h3><ul>
<li>RAM 192KB&#x2F;0x30000</li>
<li>ROM 512KB&#x2F;0x80000（其中通过分散加载给应用程序分配的空间为 416KB&#x2F;0x68000）</li>
</ul>
<h3 id="链接数据"><a href="#链接数据" class="headerlink" title="链接数据"></a>链接数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">    Total RO  Size (Code + RO Data)               419844 ( 410.00kB)</span><br><span class="line">    Total RW  Size (RW Data + ZI Data)            163952 ( 160.11kB)</span><br><span class="line">    Total ROM Size (Code + RO Data + RW Data)     421056 ( 411.19kB)</span><br><span class="line"></span><br><span class="line">==============================================================================</span><br></pre></td></tr></table></figure>

<h3 id="分散加载"><a href="#分散加载" class="headerlink" title="分散加载"></a>分散加载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line"></span><br><span class="line">	; 中断向量</span><br><span class="line">	ER_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line">		*.o (RESET, +First)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 程序信息</span><br><span class="line">	ER_IROM2 + 0 &#123;</span><br><span class="line">		*.o (SECTION_INFO_APP, +First)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 程序代码</span><br><span class="line">	ER_IROM3 + 0 &#123;</span><br><span class="line">		*(InRoot$$Sections)</span><br><span class="line">		.ANY (+RO)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 内存空间</span><br><span class="line">	RW_IRAM1 0x1FFF8000 0x00030000 &#123;</span><br><span class="line">		.ANY (+RW +ZI)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>由于代码量比较临界，起初我以为是 flash 的问题。但是 map 文件中显示 ROM 只占用了 411.19kB 的空间，并没有超过 416KB 的总量。那 RAM 呢？RAM 只用了 160.11KB 也没有超过 192KB 的总量，邪了门儿了真是！哎，等等！这款芯片的 RAM 我记得好像是分成了两块，怎么说的来着，瞅一眼《参考手册》：</p>
<p><img src="/sulfurandcu.io/cloqi184y000s8wrqg4ga0ei1/HC32F460-manual.png"></p>
<p>果然，两块 RAM 间不支持非对齐访问，再一看 SRAMH 的大小：32KB！<del>破案了！现在 RAM 的用量不正好到达 160KB（192KB - 32KB &#x3D; 160KB）这个临界点了么！</del></p>
<blockquote>
<p>超过 160KB 确实会出现异常，但不是因达到 SRAMH 所致（SRAMH 地址最小，始终会用到）而是因达到 SRAM3 且使能 ECC 校验所致。注意看红线上面的那句话：「在允许 RAM ECC 校验错误产生 NMI 中断和复位的情况下，必须对所用 RAM 空间以字（16bit）为单位进行访问」。</p>
</blockquote>
<p>按照现有分散加载文件的写法，两块内存会被认为是一个整体，那么就必然存在「在内存边界处进行非对齐访问」的可能。</p>
<h2 id="规避方法"><a href="#规避方法" class="headerlink" title="规避方法"></a>规避方法</h2><p>非对齐访问的风险可以在分散加载文件中将两块内存断开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line"></span><br><span class="line">	; 中断向量</span><br><span class="line">	ER_IROM1 0x00018000 0x00068000 &#123;</span><br><span class="line">		*.o (RESET, +First)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 程序信息</span><br><span class="line">	ER_IROM2 + 0 &#123;</span><br><span class="line">		*.o (SECTION_INFO_APP, +First)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 程序代码</span><br><span class="line">	ER_IROM3 + 0 &#123;</span><br><span class="line">		*(InRoot$$Sections)</span><br><span class="line">		.ANY (+RO)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 内存空间</span><br><span class="line">	RW_IRAM1 0x1FFF8000 0x00007FF0 &#123; ; 空出若干字节不用，以避免非对齐访问。</span><br><span class="line">		.ANY (+RW +ZI)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	; 内存空间</span><br><span class="line">	RW_IRAM2 0x20000000 0x00028000 &#123;</span><br><span class="line">		.ANY (+RW +ZI)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SRAM3 开启 ECC 后仅支持以字为单位进行访问的问题可以通过禁用 ECC 功能来解决。当然如果你一定要用 ECC 的话，那这块空间肯定不能用来让编译器自动分配内存，而是要自己来手动管理。</p>
]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
      </tags>
  </entry>
  <entry>
    <title>开发指南：华大 HC32F460 &amp; HC32F4A0 比较</title>
    <url>/sulfurandcu.io/cm04je64700adckrq3udz79n5.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">对比条目</th>
<th align="center">HC32F460</th>
<th align="center">HC32F4A0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作频率</td>
<td align="center">200MHz</td>
<td align="center">240MHz</td>
</tr>
<tr>
<td align="center">内核架构</td>
<td align="center">Cortex-M4 + FPU + DSP + MPU</td>
<td align="center">Cortex-M4 + FPU + DSP + MPU</td>
</tr>
<tr>
<td align="center">芯片封装</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ROM</td>
<td align="center">512KB | 256KB</td>
<td align="center">1024KB | 2048KB</td>
</tr>
<tr>
<td align="center">RAM</td>
<td align="center">192KB</td>
<td align="center">516KB</td>
</tr>
<tr>
<td align="center">PGA</td>
<td align="center">×1</td>
<td align="center">×4</td>
</tr>
<tr>
<td align="center">CMP</td>
<td align="center">×3</td>
<td align="center">×4</td>
</tr>
<tr>
<td align="center">ADC</td>
<td align="center">×2</td>
<td align="center">×3</td>
</tr>
<tr>
<td align="center">DAC</td>
<td align="center">×2</td>
<td align="center">×4</td>
</tr>
<tr>
<td align="center">TMR</td>
<td align="center">Timer6 ×3 (16bit 高级 PWM Timer)<br>Timer4 ×3 (16bit 电机 PWM Timer)<br>TimerA ×6 (16bit 通用 PWM Timer)<br><br>Timer0 ×2 (16bit 通用 ___ Timer)</td>
<td align="center">Timer6  ×8 (16bit 高级 PWM Timer)<br>Timer4  ×3 (16bit 电机 PWM Timer)<br>TimerA ×C (16bit 通用 PWM Timer)<br>Timer2  ×4 (16bit 通用 ___ Timer)<br>Timer0  ×2 (16bit 通用 ___ Timer)</td>
</tr>
<tr>
<td align="center">RTC</td>
<td align="center">×1</td>
<td align="center">×1</td>
</tr>
<tr>
<td align="center">WDT</td>
<td align="center">WDT &amp; SWDT</td>
<td align="center">WDT &amp; SWDT</td>
</tr>
<tr>
<td align="center">URT</td>
<td align="center">×4</td>
<td align="center">×10</td>
</tr>
<tr>
<td align="center">SPI</td>
<td align="center">×4</td>
<td align="center">×6</td>
</tr>
<tr>
<td align="center">QSPI</td>
<td align="center">×1</td>
<td align="center">×1</td>
</tr>
<tr>
<td align="center">I2C</td>
<td align="center">×3</td>
<td align="center">×6</td>
</tr>
<tr>
<td align="center">I2S</td>
<td align="center">×4</td>
<td align="center">×4</td>
</tr>
<tr>
<td align="center">CAN</td>
<td align="center">×1</td>
<td align="center">×2</td>
</tr>
<tr>
<td align="center">USB</td>
<td align="center">×1</td>
<td align="center">×1</td>
</tr>
<tr>
<td align="center">ETH</td>
<td align="center">-</td>
<td align="center">×1</td>
</tr>
<tr>
<td align="center">SDIO</td>
<td align="center">×2</td>
<td align="center">×2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发指南</category>
      </categories>
      <tags>
        <tag>华大半导体</tag>
        <tag>HC32F460</tag>
        <tag>HC32F4A0</tag>
      </tags>
  </entry>
</search>
